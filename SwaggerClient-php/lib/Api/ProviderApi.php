<?php
/**
 * ProviderApi
 * PHP version 5
 *
 * @category Class
 * @package  Delta/Voip
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Ivoz Provider
 *
 * Brand REST API
 *
 * OpenAPI spec version: 2.17.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.29
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Delta/Voip\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Delta/Voip\ApiException;
use Delta/Voip\Configuration;
use Delta/Voip\HeaderSelector;
use Delta/Voip\ObjectSerializer;

/**
 * ProviderApi Class Doc Comment
 *
 * @category Class
 * @package  Delta/Voip
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ProviderApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation brandLogoBrandItem
     *
     * Retrieves a Brand resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function brandLogoBrandItem($id)
    {
        $this->brandLogoBrandItemWithHttpInfo($id);
    }

    /**
     * Operation brandLogoBrandItemWithHttpInfo
     *
     * Retrieves a Brand resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function brandLogoBrandItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->brandLogoBrandItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation brandLogoBrandItemAsync
     *
     * Retrieves a Brand resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function brandLogoBrandItemAsync($id)
    {
        return $this->brandLogoBrandItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation brandLogoBrandItemAsyncWithHttpInfo
     *
     * Retrieves a Brand resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function brandLogoBrandItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->brandLogoBrandItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'brandLogoBrandItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function brandLogoBrandItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling brandLogoBrandItem'
            );
        }

        $resourcePath = '/brands/{id}/logo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callcsvreportCsvCallCsvReportItem
     *
     * Retrieves a CallCsvReport resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callcsvreportCsvCallCsvReportItem($id)
    {
        $this->callcsvreportCsvCallCsvReportItemWithHttpInfo($id);
    }

    /**
     * Operation callcsvreportCsvCallCsvReportItemWithHttpInfo
     *
     * Retrieves a CallCsvReport resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callcsvreportCsvCallCsvReportItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->callcsvreportCsvCallCsvReportItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callcsvreportCsvCallCsvReportItemAsync
     *
     * Retrieves a CallCsvReport resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callcsvreportCsvCallCsvReportItemAsync($id)
    {
        return $this->callcsvreportCsvCallCsvReportItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callcsvreportCsvCallCsvReportItemAsyncWithHttpInfo
     *
     * Retrieves a CallCsvReport resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callcsvreportCsvCallCsvReportItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->callcsvreportCsvCallCsvReportItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callcsvreportCsvCallCsvReportItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callcsvreportCsvCallCsvReportItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling callcsvreportCsvCallCsvReportItem'
            );
        }

        $resourcePath = '/call_csv_reports/{id}/csv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAdministratorItem
     *
     * Removes the Administrator resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAdministratorItem($id)
    {
        $this->deleteAdministratorItemWithHttpInfo($id);
    }

    /**
     * Operation deleteAdministratorItemWithHttpInfo
     *
     * Removes the Administrator resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAdministratorItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteAdministratorItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAdministratorItemAsync
     *
     * Removes the Administrator resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAdministratorItemAsync($id)
    {
        return $this->deleteAdministratorItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAdministratorItemAsyncWithHttpInfo
     *
     * Removes the Administrator resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAdministratorItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteAdministratorItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAdministratorItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAdministratorItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteAdministratorItem'
            );
        }

        $resourcePath = '/administrators/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBalanceNotificationItem
     *
     * Removes the BalanceNotification resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBalanceNotificationItem($id)
    {
        $this->deleteBalanceNotificationItemWithHttpInfo($id);
    }

    /**
     * Operation deleteBalanceNotificationItemWithHttpInfo
     *
     * Removes the BalanceNotification resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBalanceNotificationItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteBalanceNotificationItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBalanceNotificationItemAsync
     *
     * Removes the BalanceNotification resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBalanceNotificationItemAsync($id)
    {
        return $this->deleteBalanceNotificationItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBalanceNotificationItemAsyncWithHttpInfo
     *
     * Removes the BalanceNotification resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBalanceNotificationItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteBalanceNotificationItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBalanceNotificationItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBalanceNotificationItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteBalanceNotificationItem'
            );
        }

        $resourcePath = '/balance_notifications/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBannedAddressItem
     *
     * Removes the BannedAddress resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBannedAddressItem($id)
    {
        $this->deleteBannedAddressItemWithHttpInfo($id);
    }

    /**
     * Operation deleteBannedAddressItemWithHttpInfo
     *
     * Removes the BannedAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBannedAddressItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteBannedAddressItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBannedAddressItemAsync
     *
     * Removes the BannedAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBannedAddressItemAsync($id)
    {
        return $this->deleteBannedAddressItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBannedAddressItemAsyncWithHttpInfo
     *
     * Removes the BannedAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBannedAddressItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteBannedAddressItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBannedAddressItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBannedAddressItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteBannedAddressItem'
            );
        }

        $resourcePath = '/banned_addresses/antibruteforce/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBrandServiceItem
     *
     * Removes the BrandService resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBrandServiceItem($id)
    {
        $this->deleteBrandServiceItemWithHttpInfo($id);
    }

    /**
     * Operation deleteBrandServiceItemWithHttpInfo
     *
     * Removes the BrandService resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBrandServiceItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteBrandServiceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBrandServiceItemAsync
     *
     * Removes the BrandService resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBrandServiceItemAsync($id)
    {
        return $this->deleteBrandServiceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBrandServiceItemAsyncWithHttpInfo
     *
     * Removes the BrandService resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBrandServiceItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteBrandServiceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBrandServiceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBrandServiceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteBrandServiceItem'
            );
        }

        $resourcePath = '/brand_services/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCallCsvSchedulerItem
     *
     * Removes the CallCsvScheduler resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCallCsvSchedulerItem($id)
    {
        $this->deleteCallCsvSchedulerItemWithHttpInfo($id);
    }

    /**
     * Operation deleteCallCsvSchedulerItemWithHttpInfo
     *
     * Removes the CallCsvScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCallCsvSchedulerItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteCallCsvSchedulerItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCallCsvSchedulerItemAsync
     *
     * Removes the CallCsvScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCallCsvSchedulerItemAsync($id)
    {
        return $this->deleteCallCsvSchedulerItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCallCsvSchedulerItemAsyncWithHttpInfo
     *
     * Removes the CallCsvScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCallCsvSchedulerItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteCallCsvSchedulerItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCallCsvSchedulerItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCallCsvSchedulerItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteCallCsvSchedulerItem'
            );
        }

        $resourcePath = '/call_csv_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCarrierItem
     *
     * Removes the Carrier resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCarrierItem($id)
    {
        $this->deleteCarrierItemWithHttpInfo($id);
    }

    /**
     * Operation deleteCarrierItemWithHttpInfo
     *
     * Removes the Carrier resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCarrierItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteCarrierItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCarrierItemAsync
     *
     * Removes the Carrier resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCarrierItemAsync($id)
    {
        return $this->deleteCarrierItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCarrierItemAsyncWithHttpInfo
     *
     * Removes the Carrier resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCarrierItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteCarrierItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCarrierItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCarrierItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteCarrierItem'
            );
        }

        $resourcePath = '/carriers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCarrierServerItem
     *
     * Removes the CarrierServer resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCarrierServerItem($id)
    {
        $this->deleteCarrierServerItemWithHttpInfo($id);
    }

    /**
     * Operation deleteCarrierServerItemWithHttpInfo
     *
     * Removes the CarrierServer resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCarrierServerItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteCarrierServerItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCarrierServerItemAsync
     *
     * Removes the CarrierServer resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCarrierServerItemAsync($id)
    {
        return $this->deleteCarrierServerItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCarrierServerItemAsyncWithHttpInfo
     *
     * Removes the CarrierServer resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCarrierServerItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteCarrierServerItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCarrierServerItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCarrierServerItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteCarrierServerItem'
            );
        }

        $resourcePath = '/carrier_servers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCompanyItem
     *
     * Removes the Company resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCompanyItem($id)
    {
        $this->deleteCompanyItemWithHttpInfo($id);
    }

    /**
     * Operation deleteCompanyItemWithHttpInfo
     *
     * Removes the Company resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCompanyItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteCompanyItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCompanyItemAsync
     *
     * Removes the Company resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCompanyItemAsync($id)
    {
        return $this->deleteCompanyItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCompanyItemAsyncWithHttpInfo
     *
     * Removes the Company resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCompanyItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteCompanyItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCompanyItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCompanyItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteCompanyItem'
            );
        }

        $resourcePath = '/companies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDdiItem
     *
     * Removes the Ddi resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDdiItem($id)
    {
        $this->deleteDdiItemWithHttpInfo($id);
    }

    /**
     * Operation deleteDdiItemWithHttpInfo
     *
     * Removes the Ddi resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDdiItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDdiItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDdiItemAsync
     *
     * Removes the Ddi resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDdiItemAsync($id)
    {
        return $this->deleteDdiItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDdiItemAsyncWithHttpInfo
     *
     * Removes the Ddi resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDdiItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDdiItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDdiItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDdiItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDdiItem'
            );
        }

        $resourcePath = '/ddis/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDdiProviderAddressItem
     *
     * Removes the DdiProviderAddress resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDdiProviderAddressItem($id)
    {
        $this->deleteDdiProviderAddressItemWithHttpInfo($id);
    }

    /**
     * Operation deleteDdiProviderAddressItemWithHttpInfo
     *
     * Removes the DdiProviderAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDdiProviderAddressItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDdiProviderAddressItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDdiProviderAddressItemAsync
     *
     * Removes the DdiProviderAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDdiProviderAddressItemAsync($id)
    {
        return $this->deleteDdiProviderAddressItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDdiProviderAddressItemAsyncWithHttpInfo
     *
     * Removes the DdiProviderAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDdiProviderAddressItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDdiProviderAddressItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDdiProviderAddressItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDdiProviderAddressItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDdiProviderAddressItem'
            );
        }

        $resourcePath = '/ddi_provider_addresses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDdiProviderItem
     *
     * Removes the DdiProvider resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDdiProviderItem($id)
    {
        $this->deleteDdiProviderItemWithHttpInfo($id);
    }

    /**
     * Operation deleteDdiProviderItemWithHttpInfo
     *
     * Removes the DdiProvider resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDdiProviderItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDdiProviderItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDdiProviderItemAsync
     *
     * Removes the DdiProvider resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDdiProviderItemAsync($id)
    {
        return $this->deleteDdiProviderItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDdiProviderItemAsyncWithHttpInfo
     *
     * Removes the DdiProvider resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDdiProviderItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDdiProviderItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDdiProviderItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDdiProviderItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDdiProviderItem'
            );
        }

        $resourcePath = '/ddi_providers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDdiProviderRegistrationItem
     *
     * Removes the DdiProviderRegistration resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDdiProviderRegistrationItem($id)
    {
        $this->deleteDdiProviderRegistrationItemWithHttpInfo($id);
    }

    /**
     * Operation deleteDdiProviderRegistrationItemWithHttpInfo
     *
     * Removes the DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDdiProviderRegistrationItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDdiProviderRegistrationItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDdiProviderRegistrationItemAsync
     *
     * Removes the DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDdiProviderRegistrationItemAsync($id)
    {
        return $this->deleteDdiProviderRegistrationItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDdiProviderRegistrationItemAsyncWithHttpInfo
     *
     * Removes the DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDdiProviderRegistrationItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDdiProviderRegistrationItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDdiProviderRegistrationItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDdiProviderRegistrationItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDdiProviderRegistrationItem'
            );
        }

        $resourcePath = '/ddi_provider_registrations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDestinationItem
     *
     * Removes the Destination resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDestinationItem($id)
    {
        $this->deleteDestinationItemWithHttpInfo($id);
    }

    /**
     * Operation deleteDestinationItemWithHttpInfo
     *
     * Removes the Destination resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDestinationItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDestinationItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDestinationItemAsync
     *
     * Removes the Destination resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDestinationItemAsync($id)
    {
        return $this->deleteDestinationItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDestinationItemAsyncWithHttpInfo
     *
     * Removes the Destination resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDestinationItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDestinationItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDestinationItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDestinationItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDestinationItem'
            );
        }

        $resourcePath = '/destinations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDestinationRateGroupItem
     *
     * Removes the DestinationRateGroup resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDestinationRateGroupItem($id)
    {
        $this->deleteDestinationRateGroupItemWithHttpInfo($id);
    }

    /**
     * Operation deleteDestinationRateGroupItemWithHttpInfo
     *
     * Removes the DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDestinationRateGroupItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDestinationRateGroupItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDestinationRateGroupItemAsync
     *
     * Removes the DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDestinationRateGroupItemAsync($id)
    {
        return $this->deleteDestinationRateGroupItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDestinationRateGroupItemAsyncWithHttpInfo
     *
     * Removes the DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDestinationRateGroupItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDestinationRateGroupItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDestinationRateGroupItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDestinationRateGroupItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDestinationRateGroupItem'
            );
        }

        $resourcePath = '/destination_rate_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDestinationRateItem
     *
     * Removes the DestinationRate resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDestinationRateItem($id)
    {
        $this->deleteDestinationRateItemWithHttpInfo($id);
    }

    /**
     * Operation deleteDestinationRateItemWithHttpInfo
     *
     * Removes the DestinationRate resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDestinationRateItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDestinationRateItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDestinationRateItemAsync
     *
     * Removes the DestinationRate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDestinationRateItemAsync($id)
    {
        return $this->deleteDestinationRateItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDestinationRateItemAsyncWithHttpInfo
     *
     * Removes the DestinationRate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDestinationRateItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteDestinationRateItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDestinationRateItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDestinationRateItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDestinationRateItem'
            );
        }

        $resourcePath = '/destination_rates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFeaturesRelCompanyItem
     *
     * Removes the FeaturesRelCompany resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFeaturesRelCompanyItem($id)
    {
        $this->deleteFeaturesRelCompanyItemWithHttpInfo($id);
    }

    /**
     * Operation deleteFeaturesRelCompanyItemWithHttpInfo
     *
     * Removes the FeaturesRelCompany resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFeaturesRelCompanyItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFeaturesRelCompanyItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFeaturesRelCompanyItemAsync
     *
     * Removes the FeaturesRelCompany resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeaturesRelCompanyItemAsync($id)
    {
        return $this->deleteFeaturesRelCompanyItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFeaturesRelCompanyItemAsyncWithHttpInfo
     *
     * Removes the FeaturesRelCompany resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeaturesRelCompanyItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFeaturesRelCompanyItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFeaturesRelCompanyItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFeaturesRelCompanyItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteFeaturesRelCompanyItem'
            );
        }

        $resourcePath = '/features_rel_companies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFixedCostItem
     *
     * Removes the FixedCost resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFixedCostItem($id)
    {
        $this->deleteFixedCostItemWithHttpInfo($id);
    }

    /**
     * Operation deleteFixedCostItemWithHttpInfo
     *
     * Removes the FixedCost resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFixedCostItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFixedCostItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFixedCostItemAsync
     *
     * Removes the FixedCost resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFixedCostItemAsync($id)
    {
        return $this->deleteFixedCostItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFixedCostItemAsyncWithHttpInfo
     *
     * Removes the FixedCost resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFixedCostItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFixedCostItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFixedCostItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFixedCostItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteFixedCostItem'
            );
        }

        $resourcePath = '/fixed_costs/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFixedCostsRelInvoiceItem
     *
     * Removes the FixedCostsRelInvoice resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFixedCostsRelInvoiceItem($id)
    {
        $this->deleteFixedCostsRelInvoiceItemWithHttpInfo($id);
    }

    /**
     * Operation deleteFixedCostsRelInvoiceItemWithHttpInfo
     *
     * Removes the FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFixedCostsRelInvoiceItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFixedCostsRelInvoiceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFixedCostsRelInvoiceItemAsync
     *
     * Removes the FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFixedCostsRelInvoiceItemAsync($id)
    {
        return $this->deleteFixedCostsRelInvoiceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFixedCostsRelInvoiceItemAsyncWithHttpInfo
     *
     * Removes the FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFixedCostsRelInvoiceItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFixedCostsRelInvoiceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFixedCostsRelInvoiceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFixedCostsRelInvoiceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteFixedCostsRelInvoiceItem'
            );
        }

        $resourcePath = '/fixed_costs_rel_invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFixedCostsRelInvoiceSchedulerItem
     *
     * Removes the FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFixedCostsRelInvoiceSchedulerItem($id)
    {
        $this->deleteFixedCostsRelInvoiceSchedulerItemWithHttpInfo($id);
    }

    /**
     * Operation deleteFixedCostsRelInvoiceSchedulerItemWithHttpInfo
     *
     * Removes the FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFixedCostsRelInvoiceSchedulerItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFixedCostsRelInvoiceSchedulerItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFixedCostsRelInvoiceSchedulerItemAsync
     *
     * Removes the FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFixedCostsRelInvoiceSchedulerItemAsync($id)
    {
        return $this->deleteFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo
     *
     * Removes the FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFixedCostsRelInvoiceSchedulerItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFixedCostsRelInvoiceSchedulerItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFixedCostsRelInvoiceSchedulerItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteFixedCostsRelInvoiceSchedulerItem'
            );
        }

        $resourcePath = '/fixed_costs_rel_invoice_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFriendItem
     *
     * Removes the Friend resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFriendItem($id)
    {
        $this->deleteFriendItemWithHttpInfo($id);
    }

    /**
     * Operation deleteFriendItemWithHttpInfo
     *
     * Removes the Friend resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFriendItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFriendItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFriendItemAsync
     *
     * Removes the Friend resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFriendItemAsync($id)
    {
        return $this->deleteFriendItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFriendItemAsyncWithHttpInfo
     *
     * Removes the Friend resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFriendItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteFriendItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFriendItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFriendItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteFriendItem'
            );
        }

        $resourcePath = '/friends/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInvoiceItem
     *
     * Removes the Invoice resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInvoiceItem($id)
    {
        $this->deleteInvoiceItemWithHttpInfo($id);
    }

    /**
     * Operation deleteInvoiceItemWithHttpInfo
     *
     * Removes the Invoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInvoiceItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteInvoiceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInvoiceItemAsync
     *
     * Removes the Invoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceItemAsync($id)
    {
        return $this->deleteInvoiceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInvoiceItemAsyncWithHttpInfo
     *
     * Removes the Invoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteInvoiceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInvoiceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInvoiceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteInvoiceItem'
            );
        }

        $resourcePath = '/invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInvoiceNumberSequenceItem
     *
     * Removes the InvoiceNumberSequence resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInvoiceNumberSequenceItem($id)
    {
        $this->deleteInvoiceNumberSequenceItemWithHttpInfo($id);
    }

    /**
     * Operation deleteInvoiceNumberSequenceItemWithHttpInfo
     *
     * Removes the InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInvoiceNumberSequenceItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteInvoiceNumberSequenceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInvoiceNumberSequenceItemAsync
     *
     * Removes the InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceNumberSequenceItemAsync($id)
    {
        return $this->deleteInvoiceNumberSequenceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInvoiceNumberSequenceItemAsyncWithHttpInfo
     *
     * Removes the InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceNumberSequenceItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteInvoiceNumberSequenceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInvoiceNumberSequenceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInvoiceNumberSequenceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteInvoiceNumberSequenceItem'
            );
        }

        $resourcePath = '/invoice_number_sequences/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInvoiceSchedulerItem
     *
     * Removes the InvoiceScheduler resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInvoiceSchedulerItem($id)
    {
        $this->deleteInvoiceSchedulerItemWithHttpInfo($id);
    }

    /**
     * Operation deleteInvoiceSchedulerItemWithHttpInfo
     *
     * Removes the InvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInvoiceSchedulerItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteInvoiceSchedulerItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInvoiceSchedulerItemAsync
     *
     * Removes the InvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceSchedulerItemAsync($id)
    {
        return $this->deleteInvoiceSchedulerItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInvoiceSchedulerItemAsyncWithHttpInfo
     *
     * Removes the InvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceSchedulerItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteInvoiceSchedulerItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInvoiceSchedulerItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInvoiceSchedulerItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteInvoiceSchedulerItem'
            );
        }

        $resourcePath = '/invoice_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInvoiceTemplateItem
     *
     * Removes the InvoiceTemplate resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInvoiceTemplateItem($id)
    {
        $this->deleteInvoiceTemplateItemWithHttpInfo($id);
    }

    /**
     * Operation deleteInvoiceTemplateItemWithHttpInfo
     *
     * Removes the InvoiceTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInvoiceTemplateItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteInvoiceTemplateItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInvoiceTemplateItemAsync
     *
     * Removes the InvoiceTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceTemplateItemAsync($id)
    {
        return $this->deleteInvoiceTemplateItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInvoiceTemplateItemAsyncWithHttpInfo
     *
     * Removes the InvoiceTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceTemplateItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteInvoiceTemplateItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInvoiceTemplateItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInvoiceTemplateItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteInvoiceTemplateItem'
            );
        }

        $resourcePath = '/invoice_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNotificationTemplateContentItem
     *
     * Removes the NotificationTemplateContent resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNotificationTemplateContentItem($id)
    {
        $this->deleteNotificationTemplateContentItemWithHttpInfo($id);
    }

    /**
     * Operation deleteNotificationTemplateContentItemWithHttpInfo
     *
     * Removes the NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNotificationTemplateContentItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteNotificationTemplateContentItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNotificationTemplateContentItemAsync
     *
     * Removes the NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNotificationTemplateContentItemAsync($id)
    {
        return $this->deleteNotificationTemplateContentItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNotificationTemplateContentItemAsyncWithHttpInfo
     *
     * Removes the NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNotificationTemplateContentItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteNotificationTemplateContentItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNotificationTemplateContentItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNotificationTemplateContentItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteNotificationTemplateContentItem'
            );
        }

        $resourcePath = '/notification_template_contents/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNotificationTemplateItem
     *
     * Removes the NotificationTemplate resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNotificationTemplateItem($id)
    {
        $this->deleteNotificationTemplateItemWithHttpInfo($id);
    }

    /**
     * Operation deleteNotificationTemplateItemWithHttpInfo
     *
     * Removes the NotificationTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNotificationTemplateItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteNotificationTemplateItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNotificationTemplateItemAsync
     *
     * Removes the NotificationTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNotificationTemplateItemAsync($id)
    {
        return $this->deleteNotificationTemplateItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNotificationTemplateItemAsyncWithHttpInfo
     *
     * Removes the NotificationTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNotificationTemplateItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteNotificationTemplateItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNotificationTemplateItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNotificationTemplateItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteNotificationTemplateItem'
            );
        }

        $resourcePath = '/notification_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOutgoingRoutingItem
     *
     * Removes the OutgoingRouting resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOutgoingRoutingItem($id)
    {
        $this->deleteOutgoingRoutingItemWithHttpInfo($id);
    }

    /**
     * Operation deleteOutgoingRoutingItemWithHttpInfo
     *
     * Removes the OutgoingRouting resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOutgoingRoutingItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteOutgoingRoutingItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOutgoingRoutingItemAsync
     *
     * Removes the OutgoingRouting resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOutgoingRoutingItemAsync($id)
    {
        return $this->deleteOutgoingRoutingItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOutgoingRoutingItemAsyncWithHttpInfo
     *
     * Removes the OutgoingRouting resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOutgoingRoutingItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteOutgoingRoutingItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOutgoingRoutingItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteOutgoingRoutingItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteOutgoingRoutingItem'
            );
        }

        $resourcePath = '/outgoing_routings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRatingPlanGroupItem
     *
     * Removes the RatingPlanGroup resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRatingPlanGroupItem($id)
    {
        $this->deleteRatingPlanGroupItemWithHttpInfo($id);
    }

    /**
     * Operation deleteRatingPlanGroupItemWithHttpInfo
     *
     * Removes the RatingPlanGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRatingPlanGroupItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRatingPlanGroupItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRatingPlanGroupItemAsync
     *
     * Removes the RatingPlanGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRatingPlanGroupItemAsync($id)
    {
        return $this->deleteRatingPlanGroupItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRatingPlanGroupItemAsyncWithHttpInfo
     *
     * Removes the RatingPlanGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRatingPlanGroupItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRatingPlanGroupItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRatingPlanGroupItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRatingPlanGroupItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRatingPlanGroupItem'
            );
        }

        $resourcePath = '/rating_plan_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRatingPlanItem
     *
     * Removes the RatingPlan resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRatingPlanItem($id)
    {
        $this->deleteRatingPlanItemWithHttpInfo($id);
    }

    /**
     * Operation deleteRatingPlanItemWithHttpInfo
     *
     * Removes the RatingPlan resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRatingPlanItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRatingPlanItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRatingPlanItemAsync
     *
     * Removes the RatingPlan resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRatingPlanItemAsync($id)
    {
        return $this->deleteRatingPlanItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRatingPlanItemAsyncWithHttpInfo
     *
     * Removes the RatingPlan resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRatingPlanItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRatingPlanItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRatingPlanItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRatingPlanItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRatingPlanItem'
            );
        }

        $resourcePath = '/rating_plans/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRatingProfileItem
     *
     * Removes the RatingProfile resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRatingProfileItem($id)
    {
        $this->deleteRatingProfileItemWithHttpInfo($id);
    }

    /**
     * Operation deleteRatingProfileItemWithHttpInfo
     *
     * Removes the RatingProfile resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRatingProfileItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRatingProfileItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRatingProfileItemAsync
     *
     * Removes the RatingProfile resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRatingProfileItemAsync($id)
    {
        return $this->deleteRatingProfileItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRatingProfileItemAsyncWithHttpInfo
     *
     * Removes the RatingProfile resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRatingProfileItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRatingProfileItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRatingProfileItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRatingProfileItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRatingProfileItem'
            );
        }

        $resourcePath = '/rating_profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteResidentialDeviceItem
     *
     * Removes the ResidentialDevice resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteResidentialDeviceItem($id)
    {
        $this->deleteResidentialDeviceItemWithHttpInfo($id);
    }

    /**
     * Operation deleteResidentialDeviceItemWithHttpInfo
     *
     * Removes the ResidentialDevice resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteResidentialDeviceItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteResidentialDeviceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteResidentialDeviceItemAsync
     *
     * Removes the ResidentialDevice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteResidentialDeviceItemAsync($id)
    {
        return $this->deleteResidentialDeviceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteResidentialDeviceItemAsyncWithHttpInfo
     *
     * Removes the ResidentialDevice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteResidentialDeviceItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteResidentialDeviceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteResidentialDeviceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteResidentialDeviceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteResidentialDeviceItem'
            );
        }

        $resourcePath = '/residential_devices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRetailAccountItem
     *
     * Removes the RetailAccount resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRetailAccountItem($id)
    {
        $this->deleteRetailAccountItemWithHttpInfo($id);
    }

    /**
     * Operation deleteRetailAccountItemWithHttpInfo
     *
     * Removes the RetailAccount resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRetailAccountItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRetailAccountItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRetailAccountItemAsync
     *
     * Removes the RetailAccount resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRetailAccountItemAsync($id)
    {
        return $this->deleteRetailAccountItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRetailAccountItemAsyncWithHttpInfo
     *
     * Removes the RetailAccount resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRetailAccountItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRetailAccountItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRetailAccountItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRetailAccountItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRetailAccountItem'
            );
        }

        $resourcePath = '/retail_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRoutingPatternGroupItem
     *
     * Removes the RoutingPatternGroup resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRoutingPatternGroupItem($id)
    {
        $this->deleteRoutingPatternGroupItemWithHttpInfo($id);
    }

    /**
     * Operation deleteRoutingPatternGroupItemWithHttpInfo
     *
     * Removes the RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRoutingPatternGroupItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRoutingPatternGroupItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRoutingPatternGroupItemAsync
     *
     * Removes the RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoutingPatternGroupItemAsync($id)
    {
        return $this->deleteRoutingPatternGroupItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRoutingPatternGroupItemAsyncWithHttpInfo
     *
     * Removes the RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoutingPatternGroupItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRoutingPatternGroupItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRoutingPatternGroupItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRoutingPatternGroupItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRoutingPatternGroupItem'
            );
        }

        $resourcePath = '/routing_pattern_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRoutingPatternGroupsRelPatternItem
     *
     * Removes the RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRoutingPatternGroupsRelPatternItem($id)
    {
        $this->deleteRoutingPatternGroupsRelPatternItemWithHttpInfo($id);
    }

    /**
     * Operation deleteRoutingPatternGroupsRelPatternItemWithHttpInfo
     *
     * Removes the RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRoutingPatternGroupsRelPatternItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRoutingPatternGroupsRelPatternItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRoutingPatternGroupsRelPatternItemAsync
     *
     * Removes the RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoutingPatternGroupsRelPatternItemAsync($id)
    {
        return $this->deleteRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo
     *
     * Removes the RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRoutingPatternGroupsRelPatternItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRoutingPatternGroupsRelPatternItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRoutingPatternGroupsRelPatternItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRoutingPatternGroupsRelPatternItem'
            );
        }

        $resourcePath = '/routing_pattern_groups_rel_patterns/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRoutingPatternItem
     *
     * Removes the RoutingPattern resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRoutingPatternItem($id)
    {
        $this->deleteRoutingPatternItemWithHttpInfo($id);
    }

    /**
     * Operation deleteRoutingPatternItemWithHttpInfo
     *
     * Removes the RoutingPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRoutingPatternItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRoutingPatternItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRoutingPatternItemAsync
     *
     * Removes the RoutingPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoutingPatternItemAsync($id)
    {
        return $this->deleteRoutingPatternItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRoutingPatternItemAsyncWithHttpInfo
     *
     * Removes the RoutingPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoutingPatternItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRoutingPatternItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRoutingPatternItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRoutingPatternItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRoutingPatternItem'
            );
        }

        $resourcePath = '/routing_patterns/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRoutingTagItem
     *
     * Removes the RoutingTag resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRoutingTagItem($id)
    {
        $this->deleteRoutingTagItemWithHttpInfo($id);
    }

    /**
     * Operation deleteRoutingTagItemWithHttpInfo
     *
     * Removes the RoutingTag resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRoutingTagItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRoutingTagItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRoutingTagItemAsync
     *
     * Removes the RoutingTag resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoutingTagItemAsync($id)
    {
        return $this->deleteRoutingTagItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRoutingTagItemAsyncWithHttpInfo
     *
     * Removes the RoutingTag resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoutingTagItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteRoutingTagItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRoutingTagItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRoutingTagItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRoutingTagItem'
            );
        }

        $resourcePath = '/routing_tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSpecialNumberItem
     *
     * Removes the SpecialNumber resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSpecialNumberItem($id)
    {
        $this->deleteSpecialNumberItemWithHttpInfo($id);
    }

    /**
     * Operation deleteSpecialNumberItemWithHttpInfo
     *
     * Removes the SpecialNumber resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSpecialNumberItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteSpecialNumberItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSpecialNumberItemAsync
     *
     * Removes the SpecialNumber resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSpecialNumberItemAsync($id)
    {
        return $this->deleteSpecialNumberItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSpecialNumberItemAsyncWithHttpInfo
     *
     * Removes the SpecialNumber resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSpecialNumberItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteSpecialNumberItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSpecialNumberItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSpecialNumberItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteSpecialNumberItem'
            );
        }

        $resourcePath = '/special_numbers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTransformationRuleItem
     *
     * Removes the TransformationRule resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTransformationRuleItem($id)
    {
        $this->deleteTransformationRuleItemWithHttpInfo($id);
    }

    /**
     * Operation deleteTransformationRuleItemWithHttpInfo
     *
     * Removes the TransformationRule resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTransformationRuleItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteTransformationRuleItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTransformationRuleItemAsync
     *
     * Removes the TransformationRule resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTransformationRuleItemAsync($id)
    {
        return $this->deleteTransformationRuleItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTransformationRuleItemAsyncWithHttpInfo
     *
     * Removes the TransformationRule resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTransformationRuleItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteTransformationRuleItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTransformationRuleItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTransformationRuleItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteTransformationRuleItem'
            );
        }

        $resourcePath = '/transformation_rules/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTransformationRuleSetItem
     *
     * Removes the TransformationRuleSet resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTransformationRuleSetItem($id)
    {
        $this->deleteTransformationRuleSetItemWithHttpInfo($id);
    }

    /**
     * Operation deleteTransformationRuleSetItemWithHttpInfo
     *
     * Removes the TransformationRuleSet resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTransformationRuleSetItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteTransformationRuleSetItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTransformationRuleSetItemAsync
     *
     * Removes the TransformationRuleSet resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTransformationRuleSetItemAsync($id)
    {
        return $this->deleteTransformationRuleSetItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTransformationRuleSetItemAsyncWithHttpInfo
     *
     * Removes the TransformationRuleSet resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTransformationRuleSetItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteTransformationRuleSetItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTransformationRuleSetItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTransformationRuleSetItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteTransformationRuleSetItem'
            );
        }

        $resourcePath = '/transformation_rule_sets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebPortalItem
     *
     * Removes the WebPortal resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebPortalItem($id)
    {
        $this->deleteWebPortalItemWithHttpInfo($id);
    }

    /**
     * Operation deleteWebPortalItemWithHttpInfo
     *
     * Removes the WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebPortalItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteWebPortalItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebPortalItemAsync
     *
     * Removes the WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebPortalItemAsync($id)
    {
        return $this->deleteWebPortalItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebPortalItemAsyncWithHttpInfo
     *
     * Removes the WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebPortalItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteWebPortalItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebPortalItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteWebPortalItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteWebPortalItem'
            );
        }

        $resourcePath = '/web_portals/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destinationrategroupFileDestinationRateGroupItem
     *
     * Retrieves a DestinationRateGroup resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function destinationrategroupFileDestinationRateGroupItem($id)
    {
        $this->destinationrategroupFileDestinationRateGroupItemWithHttpInfo($id);
    }

    /**
     * Operation destinationrategroupFileDestinationRateGroupItemWithHttpInfo
     *
     * Retrieves a DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function destinationrategroupFileDestinationRateGroupItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->destinationrategroupFileDestinationRateGroupItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation destinationrategroupFileDestinationRateGroupItemAsync
     *
     * Retrieves a DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destinationrategroupFileDestinationRateGroupItemAsync($id)
    {
        return $this->destinationrategroupFileDestinationRateGroupItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destinationrategroupFileDestinationRateGroupItemAsyncWithHttpInfo
     *
     * Retrieves a DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destinationrategroupFileDestinationRateGroupItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->destinationrategroupFileDestinationRateGroupItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destinationrategroupFileDestinationRateGroupItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destinationrategroupFileDestinationRateGroupItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling destinationrategroupFileDestinationRateGroupItem'
            );
        }

        $resourcePath = '/destination_rate_groups/{id}/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdministratorCollection
     *
     * Retrieves the collection of Administrator resources.
     *
     * @param  bool $active active (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  bool $company_exists company_exists (optional)
     * @param  string $email email (optional)
     * @param  string $email_end email_end (optional)
     * @param  string $email_exact email_exact (optional)
     * @param  string $email_partial email_partial (optional)
     * @param  string $email_start email_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $lastname lastname (optional)
     * @param  string $lastname_end lastname_end (optional)
     * @param  string $lastname_exact lastname_exact (optional)
     * @param  bool $lastname_exists lastname_exists (optional)
     * @param  string $lastname_partial lastname_partial (optional)
     * @param  string $lastname_start lastname_start (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  bool $name_exists name_exists (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  bool $restricted restricted (optional)
     * @param  string $timezone timezone (optional)
     * @param  string $timezone2 timezone2 (optional)
     * @param  bool $timezone_exists timezone_exists (optional)
     * @param  string $username username (optional)
     * @param  string $username_end username_end (optional)
     * @param  string $username_exact username_exact (optional)
     * @param  string $username_partial username_partial (optional)
     * @param  string $username_start username_start (optional)
     * @param  string $_order_active _order_active (optional)
     * @param  string $_order_email _order_email (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_lastname _order_lastname (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_restricted _order_restricted (optional)
     * @param  string $_order_username _order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\AdministratorCollection[]
     */
    public function getAdministratorCollection($active = null, $company = null, $company2 = null, $company_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $id_exact = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_exists = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $restricted = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_active = null, $_order_email = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_order_restricted = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getAdministratorCollectionWithHttpInfo($active, $company, $company2, $company_exists, $email, $email_end, $email_exact, $email_partial, $email_start, $id_exact, $lastname, $lastname_end, $lastname_exact, $lastname_exists, $lastname_partial, $lastname_start, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $restricted, $timezone, $timezone2, $timezone_exists, $username, $username_end, $username_exact, $username_partial, $username_start, $_order_active, $_order_email, $_order_id, $_order_lastname, $_order_name, $_order_restricted, $_order_username, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getAdministratorCollectionWithHttpInfo
     *
     * Retrieves the collection of Administrator resources.
     *
     * @param  bool $active (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $lastname (optional)
     * @param  string $lastname_end (optional)
     * @param  string $lastname_exact (optional)
     * @param  bool $lastname_exists (optional)
     * @param  string $lastname_partial (optional)
     * @param  string $lastname_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  bool $restricted (optional)
     * @param  string $timezone (optional)
     * @param  string $timezone2 (optional)
     * @param  bool $timezone_exists (optional)
     * @param  string $username (optional)
     * @param  string $username_end (optional)
     * @param  string $username_exact (optional)
     * @param  string $username_partial (optional)
     * @param  string $username_start (optional)
     * @param  string $_order_active (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_lastname (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_restricted (optional)
     * @param  string $_order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\AdministratorCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdministratorCollectionWithHttpInfo($active = null, $company = null, $company2 = null, $company_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $id_exact = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_exists = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $restricted = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_active = null, $_order_email = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_order_restricted = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\AdministratorCollection[]';
        $request = $this->getAdministratorCollectionRequest($active, $company, $company2, $company_exists, $email, $email_end, $email_exact, $email_partial, $email_start, $id_exact, $lastname, $lastname_end, $lastname_exact, $lastname_exists, $lastname_partial, $lastname_start, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $restricted, $timezone, $timezone2, $timezone_exists, $username, $username_end, $username_exact, $username_partial, $username_start, $_order_active, $_order_email, $_order_id, $_order_lastname, $_order_name, $_order_restricted, $_order_username, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\AdministratorCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdministratorCollectionAsync
     *
     * Retrieves the collection of Administrator resources.
     *
     * @param  bool $active (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $lastname (optional)
     * @param  string $lastname_end (optional)
     * @param  string $lastname_exact (optional)
     * @param  bool $lastname_exists (optional)
     * @param  string $lastname_partial (optional)
     * @param  string $lastname_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  bool $restricted (optional)
     * @param  string $timezone (optional)
     * @param  string $timezone2 (optional)
     * @param  bool $timezone_exists (optional)
     * @param  string $username (optional)
     * @param  string $username_end (optional)
     * @param  string $username_exact (optional)
     * @param  string $username_partial (optional)
     * @param  string $username_start (optional)
     * @param  string $_order_active (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_lastname (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_restricted (optional)
     * @param  string $_order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdministratorCollectionAsync($active = null, $company = null, $company2 = null, $company_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $id_exact = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_exists = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $restricted = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_active = null, $_order_email = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_order_restricted = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getAdministratorCollectionAsyncWithHttpInfo($active, $company, $company2, $company_exists, $email, $email_end, $email_exact, $email_partial, $email_start, $id_exact, $lastname, $lastname_end, $lastname_exact, $lastname_exists, $lastname_partial, $lastname_start, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $restricted, $timezone, $timezone2, $timezone_exists, $username, $username_end, $username_exact, $username_partial, $username_start, $_order_active, $_order_email, $_order_id, $_order_lastname, $_order_name, $_order_restricted, $_order_username, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdministratorCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Administrator resources.
     *
     * @param  bool $active (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $lastname (optional)
     * @param  string $lastname_end (optional)
     * @param  string $lastname_exact (optional)
     * @param  bool $lastname_exists (optional)
     * @param  string $lastname_partial (optional)
     * @param  string $lastname_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  bool $restricted (optional)
     * @param  string $timezone (optional)
     * @param  string $timezone2 (optional)
     * @param  bool $timezone_exists (optional)
     * @param  string $username (optional)
     * @param  string $username_end (optional)
     * @param  string $username_exact (optional)
     * @param  string $username_partial (optional)
     * @param  string $username_start (optional)
     * @param  string $_order_active (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_lastname (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_restricted (optional)
     * @param  string $_order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdministratorCollectionAsyncWithHttpInfo($active = null, $company = null, $company2 = null, $company_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $id_exact = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_exists = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $restricted = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_active = null, $_order_email = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_order_restricted = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\AdministratorCollection[]';
        $request = $this->getAdministratorCollectionRequest($active, $company, $company2, $company_exists, $email, $email_end, $email_exact, $email_partial, $email_start, $id_exact, $lastname, $lastname_end, $lastname_exact, $lastname_exists, $lastname_partial, $lastname_start, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $restricted, $timezone, $timezone2, $timezone_exists, $username, $username_end, $username_exact, $username_partial, $username_start, $_order_active, $_order_email, $_order_id, $_order_lastname, $_order_name, $_order_restricted, $_order_username, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdministratorCollection'
     *
     * @param  bool $active (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $lastname (optional)
     * @param  string $lastname_end (optional)
     * @param  string $lastname_exact (optional)
     * @param  bool $lastname_exists (optional)
     * @param  string $lastname_partial (optional)
     * @param  string $lastname_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  bool $restricted (optional)
     * @param  string $timezone (optional)
     * @param  string $timezone2 (optional)
     * @param  bool $timezone_exists (optional)
     * @param  string $username (optional)
     * @param  string $username_end (optional)
     * @param  string $username_exact (optional)
     * @param  string $username_partial (optional)
     * @param  string $username_start (optional)
     * @param  string $_order_active (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_lastname (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_restricted (optional)
     * @param  string $_order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdministratorCollectionRequest($active = null, $company = null, $company2 = null, $company_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $id_exact = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_exists = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $restricted = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_active = null, $_order_email = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_order_restricted = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/administrators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($company_exists !== null) {
            $queryParams['company[exists]'] = ObjectSerializer::toQueryValue($company_exists);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($email_end !== null) {
            $queryParams['email[end]'] = ObjectSerializer::toQueryValue($email_end);
        }
        // query params
        if ($email_exact !== null) {
            $queryParams['email[exact]'] = ObjectSerializer::toQueryValue($email_exact);
        }
        // query params
        if ($email_partial !== null) {
            $queryParams['email[partial]'] = ObjectSerializer::toQueryValue($email_partial);
        }
        // query params
        if ($email_start !== null) {
            $queryParams['email[start]'] = ObjectSerializer::toQueryValue($email_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($lastname !== null) {
            $queryParams['lastname'] = ObjectSerializer::toQueryValue($lastname);
        }
        // query params
        if ($lastname_end !== null) {
            $queryParams['lastname[end]'] = ObjectSerializer::toQueryValue($lastname_end);
        }
        // query params
        if ($lastname_exact !== null) {
            $queryParams['lastname[exact]'] = ObjectSerializer::toQueryValue($lastname_exact);
        }
        // query params
        if ($lastname_exists !== null) {
            $queryParams['lastname[exists]'] = ObjectSerializer::toQueryValue($lastname_exists);
        }
        // query params
        if ($lastname_partial !== null) {
            $queryParams['lastname[partial]'] = ObjectSerializer::toQueryValue($lastname_partial);
        }
        // query params
        if ($lastname_start !== null) {
            $queryParams['lastname[start]'] = ObjectSerializer::toQueryValue($lastname_start);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_exists !== null) {
            $queryParams['name[exists]'] = ObjectSerializer::toQueryValue($name_exists);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($restricted !== null) {
            $queryParams['restricted'] = ObjectSerializer::toQueryValue($restricted);
        }
        // query params
        if ($timezone !== null) {
            $queryParams['timezone'] = ObjectSerializer::toQueryValue($timezone);
        }
        // query params
        if ($timezone2 !== null) {
            $queryParams['timezone[]'] = ObjectSerializer::toQueryValue($timezone2);
        }
        // query params
        if ($timezone_exists !== null) {
            $queryParams['timezone[exists]'] = ObjectSerializer::toQueryValue($timezone_exists);
        }
        // query params
        if ($username !== null) {
            $queryParams['username'] = ObjectSerializer::toQueryValue($username);
        }
        // query params
        if ($username_end !== null) {
            $queryParams['username[end]'] = ObjectSerializer::toQueryValue($username_end);
        }
        // query params
        if ($username_exact !== null) {
            $queryParams['username[exact]'] = ObjectSerializer::toQueryValue($username_exact);
        }
        // query params
        if ($username_partial !== null) {
            $queryParams['username[partial]'] = ObjectSerializer::toQueryValue($username_partial);
        }
        // query params
        if ($username_start !== null) {
            $queryParams['username[start]'] = ObjectSerializer::toQueryValue($username_start);
        }
        // query params
        if ($_order_active !== null) {
            $queryParams['_order[active]'] = ObjectSerializer::toQueryValue($_order_active);
        }
        // query params
        if ($_order_email !== null) {
            $queryParams['_order[email]'] = ObjectSerializer::toQueryValue($_order_email);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_lastname !== null) {
            $queryParams['_order[lastname]'] = ObjectSerializer::toQueryValue($_order_lastname);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_restricted !== null) {
            $queryParams['_order[restricted]'] = ObjectSerializer::toQueryValue($_order_restricted);
        }
        // query params
        if ($_order_username !== null) {
            $queryParams['_order[username]'] = ObjectSerializer::toQueryValue($_order_username);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdministratorItem
     *
     * Retrieves a Administrator resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\AdministratorDetailed
     */
    public function getAdministratorItem($id)
    {
        list($response) = $this->getAdministratorItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getAdministratorItemWithHttpInfo
     *
     * Retrieves a Administrator resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\AdministratorDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdministratorItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\AdministratorDetailed';
        $request = $this->getAdministratorItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\AdministratorDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdministratorItemAsync
     *
     * Retrieves a Administrator resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdministratorItemAsync($id)
    {
        return $this->getAdministratorItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdministratorItemAsyncWithHttpInfo
     *
     * Retrieves a Administrator resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdministratorItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\AdministratorDetailed';
        $request = $this->getAdministratorItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdministratorItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdministratorItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAdministratorItem'
            );
        }

        $resourcePath = '/administrators/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdministratorRelPublicEntityCollection
     *
     * Retrieves the collection of AdministratorRelPublicEntity resources.
     *
     * @param  string $administrator administrator (optional)
     * @param  string $administrator2 administrator2 (optional)
     * @param  bool $create create (optional)
     * @param  bool $delete delete (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $public_entity public_entity (optional)
     * @param  string $public_entity2 public_entity2 (optional)
     * @param  bool $read read (optional)
     * @param  bool $update update (optional)
     * @param  string $_order_create _order_create (optional)
     * @param  string $_order_delete _order_delete (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_read _order_read (optional)
     * @param  string $_order_update _order_update (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\AdministratorRelPublicEntityCollection[]
     */
    public function getAdministratorRelPublicEntityCollection($administrator = null, $administrator2 = null, $create = null, $delete = null, $id_exact = null, $public_entity = null, $public_entity2 = null, $read = null, $update = null, $_order_create = null, $_order_delete = null, $_order_id = null, $_order_read = null, $_order_update = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getAdministratorRelPublicEntityCollectionWithHttpInfo($administrator, $administrator2, $create, $delete, $id_exact, $public_entity, $public_entity2, $read, $update, $_order_create, $_order_delete, $_order_id, $_order_read, $_order_update, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getAdministratorRelPublicEntityCollectionWithHttpInfo
     *
     * Retrieves the collection of AdministratorRelPublicEntity resources.
     *
     * @param  string $administrator (optional)
     * @param  string $administrator2 (optional)
     * @param  bool $create (optional)
     * @param  bool $delete (optional)
     * @param  int $id_exact (optional)
     * @param  string $public_entity (optional)
     * @param  string $public_entity2 (optional)
     * @param  bool $read (optional)
     * @param  bool $update (optional)
     * @param  string $_order_create (optional)
     * @param  string $_order_delete (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_read (optional)
     * @param  string $_order_update (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\AdministratorRelPublicEntityCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdministratorRelPublicEntityCollectionWithHttpInfo($administrator = null, $administrator2 = null, $create = null, $delete = null, $id_exact = null, $public_entity = null, $public_entity2 = null, $read = null, $update = null, $_order_create = null, $_order_delete = null, $_order_id = null, $_order_read = null, $_order_update = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\AdministratorRelPublicEntityCollection[]';
        $request = $this->getAdministratorRelPublicEntityCollectionRequest($administrator, $administrator2, $create, $delete, $id_exact, $public_entity, $public_entity2, $read, $update, $_order_create, $_order_delete, $_order_id, $_order_read, $_order_update, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\AdministratorRelPublicEntityCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdministratorRelPublicEntityCollectionAsync
     *
     * Retrieves the collection of AdministratorRelPublicEntity resources.
     *
     * @param  string $administrator (optional)
     * @param  string $administrator2 (optional)
     * @param  bool $create (optional)
     * @param  bool $delete (optional)
     * @param  int $id_exact (optional)
     * @param  string $public_entity (optional)
     * @param  string $public_entity2 (optional)
     * @param  bool $read (optional)
     * @param  bool $update (optional)
     * @param  string $_order_create (optional)
     * @param  string $_order_delete (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_read (optional)
     * @param  string $_order_update (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdministratorRelPublicEntityCollectionAsync($administrator = null, $administrator2 = null, $create = null, $delete = null, $id_exact = null, $public_entity = null, $public_entity2 = null, $read = null, $update = null, $_order_create = null, $_order_delete = null, $_order_id = null, $_order_read = null, $_order_update = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getAdministratorRelPublicEntityCollectionAsyncWithHttpInfo($administrator, $administrator2, $create, $delete, $id_exact, $public_entity, $public_entity2, $read, $update, $_order_create, $_order_delete, $_order_id, $_order_read, $_order_update, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdministratorRelPublicEntityCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of AdministratorRelPublicEntity resources.
     *
     * @param  string $administrator (optional)
     * @param  string $administrator2 (optional)
     * @param  bool $create (optional)
     * @param  bool $delete (optional)
     * @param  int $id_exact (optional)
     * @param  string $public_entity (optional)
     * @param  string $public_entity2 (optional)
     * @param  bool $read (optional)
     * @param  bool $update (optional)
     * @param  string $_order_create (optional)
     * @param  string $_order_delete (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_read (optional)
     * @param  string $_order_update (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdministratorRelPublicEntityCollectionAsyncWithHttpInfo($administrator = null, $administrator2 = null, $create = null, $delete = null, $id_exact = null, $public_entity = null, $public_entity2 = null, $read = null, $update = null, $_order_create = null, $_order_delete = null, $_order_id = null, $_order_read = null, $_order_update = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\AdministratorRelPublicEntityCollection[]';
        $request = $this->getAdministratorRelPublicEntityCollectionRequest($administrator, $administrator2, $create, $delete, $id_exact, $public_entity, $public_entity2, $read, $update, $_order_create, $_order_delete, $_order_id, $_order_read, $_order_update, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdministratorRelPublicEntityCollection'
     *
     * @param  string $administrator (optional)
     * @param  string $administrator2 (optional)
     * @param  bool $create (optional)
     * @param  bool $delete (optional)
     * @param  int $id_exact (optional)
     * @param  string $public_entity (optional)
     * @param  string $public_entity2 (optional)
     * @param  bool $read (optional)
     * @param  bool $update (optional)
     * @param  string $_order_create (optional)
     * @param  string $_order_delete (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_read (optional)
     * @param  string $_order_update (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdministratorRelPublicEntityCollectionRequest($administrator = null, $administrator2 = null, $create = null, $delete = null, $id_exact = null, $public_entity = null, $public_entity2 = null, $read = null, $update = null, $_order_create = null, $_order_delete = null, $_order_id = null, $_order_read = null, $_order_update = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/administrator_rel_public_entities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($administrator !== null) {
            $queryParams['administrator'] = ObjectSerializer::toQueryValue($administrator);
        }
        // query params
        if ($administrator2 !== null) {
            $queryParams['administrator[]'] = ObjectSerializer::toQueryValue($administrator2);
        }
        // query params
        if ($create !== null) {
            $queryParams['create'] = ObjectSerializer::toQueryValue($create);
        }
        // query params
        if ($delete !== null) {
            $queryParams['delete'] = ObjectSerializer::toQueryValue($delete);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($public_entity !== null) {
            $queryParams['publicEntity'] = ObjectSerializer::toQueryValue($public_entity);
        }
        // query params
        if ($public_entity2 !== null) {
            $queryParams['publicEntity[]'] = ObjectSerializer::toQueryValue($public_entity2);
        }
        // query params
        if ($read !== null) {
            $queryParams['read'] = ObjectSerializer::toQueryValue($read);
        }
        // query params
        if ($update !== null) {
            $queryParams['update'] = ObjectSerializer::toQueryValue($update);
        }
        // query params
        if ($_order_create !== null) {
            $queryParams['_order[create]'] = ObjectSerializer::toQueryValue($_order_create);
        }
        // query params
        if ($_order_delete !== null) {
            $queryParams['_order[delete]'] = ObjectSerializer::toQueryValue($_order_delete);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_read !== null) {
            $queryParams['_order[read]'] = ObjectSerializer::toQueryValue($_order_read);
        }
        // query params
        if ($_order_update !== null) {
            $queryParams['_order[update]'] = ObjectSerializer::toQueryValue($_order_update);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdministratorRelPublicEntityItem
     *
     * Retrieves a AdministratorRelPublicEntity resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\AdministratorRelPublicEntityDetailed
     */
    public function getAdministratorRelPublicEntityItem($id)
    {
        list($response) = $this->getAdministratorRelPublicEntityItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getAdministratorRelPublicEntityItemWithHttpInfo
     *
     * Retrieves a AdministratorRelPublicEntity resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\AdministratorRelPublicEntityDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdministratorRelPublicEntityItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\AdministratorRelPublicEntityDetailed';
        $request = $this->getAdministratorRelPublicEntityItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\AdministratorRelPublicEntityDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdministratorRelPublicEntityItemAsync
     *
     * Retrieves a AdministratorRelPublicEntity resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdministratorRelPublicEntityItemAsync($id)
    {
        return $this->getAdministratorRelPublicEntityItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdministratorRelPublicEntityItemAsyncWithHttpInfo
     *
     * Retrieves a AdministratorRelPublicEntity resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdministratorRelPublicEntityItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\AdministratorRelPublicEntityDetailed';
        $request = $this->getAdministratorRelPublicEntityItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdministratorRelPublicEntityItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdministratorRelPublicEntityItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAdministratorRelPublicEntityItem'
            );
        }

        $resourcePath = '/administrator_rel_public_entities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalanceNotificationCollection
     *
     * Retrieves the collection of BalanceNotification resources.
     *
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  bool $company_exists company_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $notification_template notification_template (optional)
     * @param  string $notification_template2 notification_template2 (optional)
     * @param  bool $notification_template_exists notification_template_exists (optional)
     * @param  string $threshold threshold (optional)
     * @param  string $threshold_between threshold_between (optional)
     * @param  bool $threshold_exists threshold_exists (optional)
     * @param  string $threshold_gt threshold_gt (optional)
     * @param  string $threshold_gte threshold_gte (optional)
     * @param  string $threshold_lt threshold_lt (optional)
     * @param  string $threshold_lte threshold_lte (optional)
     * @param  string $to_address to_address (optional)
     * @param  string $to_address_end to_address_end (optional)
     * @param  string $to_address_exact to_address_exact (optional)
     * @param  bool $to_address_exists to_address_exists (optional)
     * @param  string $to_address_partial to_address_partial (optional)
     * @param  string $to_address_start to_address_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_threshold _order_threshold (optional)
     * @param  string $_order_to_address _order_to_address (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BalanceNotificationCollection[]
     */
    public function getBalanceNotificationCollection($company = null, $company2 = null, $company_exists = null, $id_exact = null, $notification_template = null, $notification_template2 = null, $notification_template_exists = null, $threshold = null, $threshold_between = null, $threshold_exists = null, $threshold_gt = null, $threshold_gte = null, $threshold_lt = null, $threshold_lte = null, $to_address = null, $to_address_end = null, $to_address_exact = null, $to_address_exists = null, $to_address_partial = null, $to_address_start = null, $_order_id = null, $_order_threshold = null, $_order_to_address = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getBalanceNotificationCollectionWithHttpInfo($company, $company2, $company_exists, $id_exact, $notification_template, $notification_template2, $notification_template_exists, $threshold, $threshold_between, $threshold_exists, $threshold_gt, $threshold_gte, $threshold_lt, $threshold_lte, $to_address, $to_address_end, $to_address_exact, $to_address_exists, $to_address_partial, $to_address_start, $_order_id, $_order_threshold, $_order_to_address, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getBalanceNotificationCollectionWithHttpInfo
     *
     * Retrieves the collection of BalanceNotification resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $notification_template (optional)
     * @param  string $notification_template2 (optional)
     * @param  bool $notification_template_exists (optional)
     * @param  string $threshold (optional)
     * @param  string $threshold_between (optional)
     * @param  bool $threshold_exists (optional)
     * @param  string $threshold_gt (optional)
     * @param  string $threshold_gte (optional)
     * @param  string $threshold_lt (optional)
     * @param  string $threshold_lte (optional)
     * @param  string $to_address (optional)
     * @param  string $to_address_end (optional)
     * @param  string $to_address_exact (optional)
     * @param  bool $to_address_exists (optional)
     * @param  string $to_address_partial (optional)
     * @param  string $to_address_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_threshold (optional)
     * @param  string $_order_to_address (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BalanceNotificationCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalanceNotificationCollectionWithHttpInfo($company = null, $company2 = null, $company_exists = null, $id_exact = null, $notification_template = null, $notification_template2 = null, $notification_template_exists = null, $threshold = null, $threshold_between = null, $threshold_exists = null, $threshold_gt = null, $threshold_gte = null, $threshold_lt = null, $threshold_lte = null, $to_address = null, $to_address_end = null, $to_address_exact = null, $to_address_exists = null, $to_address_partial = null, $to_address_start = null, $_order_id = null, $_order_threshold = null, $_order_to_address = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\BalanceNotificationCollection[]';
        $request = $this->getBalanceNotificationCollectionRequest($company, $company2, $company_exists, $id_exact, $notification_template, $notification_template2, $notification_template_exists, $threshold, $threshold_between, $threshold_exists, $threshold_gt, $threshold_gte, $threshold_lt, $threshold_lte, $to_address, $to_address_end, $to_address_exact, $to_address_exists, $to_address_partial, $to_address_start, $_order_id, $_order_threshold, $_order_to_address, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BalanceNotificationCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBalanceNotificationCollectionAsync
     *
     * Retrieves the collection of BalanceNotification resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $notification_template (optional)
     * @param  string $notification_template2 (optional)
     * @param  bool $notification_template_exists (optional)
     * @param  string $threshold (optional)
     * @param  string $threshold_between (optional)
     * @param  bool $threshold_exists (optional)
     * @param  string $threshold_gt (optional)
     * @param  string $threshold_gte (optional)
     * @param  string $threshold_lt (optional)
     * @param  string $threshold_lte (optional)
     * @param  string $to_address (optional)
     * @param  string $to_address_end (optional)
     * @param  string $to_address_exact (optional)
     * @param  bool $to_address_exists (optional)
     * @param  string $to_address_partial (optional)
     * @param  string $to_address_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_threshold (optional)
     * @param  string $_order_to_address (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceNotificationCollectionAsync($company = null, $company2 = null, $company_exists = null, $id_exact = null, $notification_template = null, $notification_template2 = null, $notification_template_exists = null, $threshold = null, $threshold_between = null, $threshold_exists = null, $threshold_gt = null, $threshold_gte = null, $threshold_lt = null, $threshold_lte = null, $to_address = null, $to_address_end = null, $to_address_exact = null, $to_address_exists = null, $to_address_partial = null, $to_address_start = null, $_order_id = null, $_order_threshold = null, $_order_to_address = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getBalanceNotificationCollectionAsyncWithHttpInfo($company, $company2, $company_exists, $id_exact, $notification_template, $notification_template2, $notification_template_exists, $threshold, $threshold_between, $threshold_exists, $threshold_gt, $threshold_gte, $threshold_lt, $threshold_lte, $to_address, $to_address_end, $to_address_exact, $to_address_exists, $to_address_partial, $to_address_start, $_order_id, $_order_threshold, $_order_to_address, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalanceNotificationCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of BalanceNotification resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $notification_template (optional)
     * @param  string $notification_template2 (optional)
     * @param  bool $notification_template_exists (optional)
     * @param  string $threshold (optional)
     * @param  string $threshold_between (optional)
     * @param  bool $threshold_exists (optional)
     * @param  string $threshold_gt (optional)
     * @param  string $threshold_gte (optional)
     * @param  string $threshold_lt (optional)
     * @param  string $threshold_lte (optional)
     * @param  string $to_address (optional)
     * @param  string $to_address_end (optional)
     * @param  string $to_address_exact (optional)
     * @param  bool $to_address_exists (optional)
     * @param  string $to_address_partial (optional)
     * @param  string $to_address_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_threshold (optional)
     * @param  string $_order_to_address (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceNotificationCollectionAsyncWithHttpInfo($company = null, $company2 = null, $company_exists = null, $id_exact = null, $notification_template = null, $notification_template2 = null, $notification_template_exists = null, $threshold = null, $threshold_between = null, $threshold_exists = null, $threshold_gt = null, $threshold_gte = null, $threshold_lt = null, $threshold_lte = null, $to_address = null, $to_address_end = null, $to_address_exact = null, $to_address_exists = null, $to_address_partial = null, $to_address_start = null, $_order_id = null, $_order_threshold = null, $_order_to_address = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\BalanceNotificationCollection[]';
        $request = $this->getBalanceNotificationCollectionRequest($company, $company2, $company_exists, $id_exact, $notification_template, $notification_template2, $notification_template_exists, $threshold, $threshold_between, $threshold_exists, $threshold_gt, $threshold_gte, $threshold_lt, $threshold_lte, $to_address, $to_address_end, $to_address_exact, $to_address_exists, $to_address_partial, $to_address_start, $_order_id, $_order_threshold, $_order_to_address, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalanceNotificationCollection'
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $notification_template (optional)
     * @param  string $notification_template2 (optional)
     * @param  bool $notification_template_exists (optional)
     * @param  string $threshold (optional)
     * @param  string $threshold_between (optional)
     * @param  bool $threshold_exists (optional)
     * @param  string $threshold_gt (optional)
     * @param  string $threshold_gte (optional)
     * @param  string $threshold_lt (optional)
     * @param  string $threshold_lte (optional)
     * @param  string $to_address (optional)
     * @param  string $to_address_end (optional)
     * @param  string $to_address_exact (optional)
     * @param  bool $to_address_exists (optional)
     * @param  string $to_address_partial (optional)
     * @param  string $to_address_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_threshold (optional)
     * @param  string $_order_to_address (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBalanceNotificationCollectionRequest($company = null, $company2 = null, $company_exists = null, $id_exact = null, $notification_template = null, $notification_template2 = null, $notification_template_exists = null, $threshold = null, $threshold_between = null, $threshold_exists = null, $threshold_gt = null, $threshold_gte = null, $threshold_lt = null, $threshold_lte = null, $to_address = null, $to_address_end = null, $to_address_exact = null, $to_address_exists = null, $to_address_partial = null, $to_address_start = null, $_order_id = null, $_order_threshold = null, $_order_to_address = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/balance_notifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($company_exists !== null) {
            $queryParams['company[exists]'] = ObjectSerializer::toQueryValue($company_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($notification_template !== null) {
            $queryParams['notificationTemplate'] = ObjectSerializer::toQueryValue($notification_template);
        }
        // query params
        if ($notification_template2 !== null) {
            $queryParams['notificationTemplate[]'] = ObjectSerializer::toQueryValue($notification_template2);
        }
        // query params
        if ($notification_template_exists !== null) {
            $queryParams['notificationTemplate[exists]'] = ObjectSerializer::toQueryValue($notification_template_exists);
        }
        // query params
        if ($threshold !== null) {
            $queryParams['threshold'] = ObjectSerializer::toQueryValue($threshold);
        }
        // query params
        if ($threshold_between !== null) {
            $queryParams['threshold[between]'] = ObjectSerializer::toQueryValue($threshold_between);
        }
        // query params
        if ($threshold_exists !== null) {
            $queryParams['threshold[exists]'] = ObjectSerializer::toQueryValue($threshold_exists);
        }
        // query params
        if ($threshold_gt !== null) {
            $queryParams['threshold[gt]'] = ObjectSerializer::toQueryValue($threshold_gt);
        }
        // query params
        if ($threshold_gte !== null) {
            $queryParams['threshold[gte]'] = ObjectSerializer::toQueryValue($threshold_gte);
        }
        // query params
        if ($threshold_lt !== null) {
            $queryParams['threshold[lt]'] = ObjectSerializer::toQueryValue($threshold_lt);
        }
        // query params
        if ($threshold_lte !== null) {
            $queryParams['threshold[lte]'] = ObjectSerializer::toQueryValue($threshold_lte);
        }
        // query params
        if ($to_address !== null) {
            $queryParams['toAddress'] = ObjectSerializer::toQueryValue($to_address);
        }
        // query params
        if ($to_address_end !== null) {
            $queryParams['toAddress[end]'] = ObjectSerializer::toQueryValue($to_address_end);
        }
        // query params
        if ($to_address_exact !== null) {
            $queryParams['toAddress[exact]'] = ObjectSerializer::toQueryValue($to_address_exact);
        }
        // query params
        if ($to_address_exists !== null) {
            $queryParams['toAddress[exists]'] = ObjectSerializer::toQueryValue($to_address_exists);
        }
        // query params
        if ($to_address_partial !== null) {
            $queryParams['toAddress[partial]'] = ObjectSerializer::toQueryValue($to_address_partial);
        }
        // query params
        if ($to_address_start !== null) {
            $queryParams['toAddress[start]'] = ObjectSerializer::toQueryValue($to_address_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_threshold !== null) {
            $queryParams['_order[threshold]'] = ObjectSerializer::toQueryValue($_order_threshold);
        }
        // query params
        if ($_order_to_address !== null) {
            $queryParams['_order[toAddress]'] = ObjectSerializer::toQueryValue($_order_to_address);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalanceNotificationItem
     *
     * Retrieves a BalanceNotification resource.
     *
     * @param  string $id id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BalanceNotificationDetailed
     */
    public function getBalanceNotificationItem($id, $_timezone = null)
    {
        list($response) = $this->getBalanceNotificationItemWithHttpInfo($id, $_timezone);
        return $response;
    }

    /**
     * Operation getBalanceNotificationItemWithHttpInfo
     *
     * Retrieves a BalanceNotification resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BalanceNotificationDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalanceNotificationItemWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BalanceNotificationDetailed';
        $request = $this->getBalanceNotificationItemRequest($id, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BalanceNotificationDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBalanceNotificationItemAsync
     *
     * Retrieves a BalanceNotification resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceNotificationItemAsync($id, $_timezone = null)
    {
        return $this->getBalanceNotificationItemAsyncWithHttpInfo($id, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalanceNotificationItemAsyncWithHttpInfo
     *
     * Retrieves a BalanceNotification resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceNotificationItemAsyncWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BalanceNotificationDetailed';
        $request = $this->getBalanceNotificationItemRequest($id, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalanceNotificationItem'
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBalanceNotificationItemRequest($id, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBalanceNotificationItem'
            );
        }

        $resourcePath = '/balance_notifications/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBannedAddressCollection
     *
     * Retrieves the collection of BannedAddress resources.
     *
     * @param  string $aor aor (optional)
     * @param  string $aor_end aor_end (optional)
     * @param  string $aor_exact aor_exact (optional)
     * @param  bool $aor_exists aor_exists (optional)
     * @param  string $aor_partial aor_partial (optional)
     * @param  string $aor_start aor_start (optional)
     * @param  string $blocker blocker (optional)
     * @param  string $blocker_end blocker_end (optional)
     * @param  string $blocker_exact blocker_exact (optional)
     * @param  bool $blocker_exists blocker_exists (optional)
     * @param  string $blocker_partial blocker_partial (optional)
     * @param  string $blocker_start blocker_start (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  bool $company_exists company_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $ip ip (optional)
     * @param  string $ip_end ip_end (optional)
     * @param  string $ip_exact ip_exact (optional)
     * @param  bool $ip_exists ip_exists (optional)
     * @param  string $ip_partial ip_partial (optional)
     * @param  string $ip_start ip_start (optional)
     * @param  string $last_time_banned last_time_banned (optional)
     * @param  string $last_time_banned_after last_time_banned_after (optional)
     * @param  string $last_time_banned_before last_time_banned_before (optional)
     * @param  bool $last_time_banned_exists last_time_banned_exists (optional)
     * @param  string $last_time_banned_start last_time_banned_start (optional)
     * @param  string $last_time_banned_strictly_after last_time_banned_strictly_after (optional)
     * @param  string $last_time_banned_strictly_before last_time_banned_strictly_before (optional)
     * @param  string $_order_aor _order_aor (optional)
     * @param  string $_order_blocker _order_blocker (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_ip _order_ip (optional)
     * @param  string $_order_last_time_banned _order_last_time_banned (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BannedAddressCollection[]
     */
    public function getBannedAddressCollection($aor = null, $aor_end = null, $aor_exact = null, $aor_exists = null, $aor_partial = null, $aor_start = null, $blocker = null, $blocker_end = null, $blocker_exact = null, $blocker_exists = null, $blocker_partial = null, $blocker_start = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $last_time_banned = null, $last_time_banned_after = null, $last_time_banned_before = null, $last_time_banned_exists = null, $last_time_banned_start = null, $last_time_banned_strictly_after = null, $last_time_banned_strictly_before = null, $_order_aor = null, $_order_blocker = null, $_order_id = null, $_order_ip = null, $_order_last_time_banned = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        list($response) = $this->getBannedAddressCollectionWithHttpInfo($aor, $aor_end, $aor_exact, $aor_exists, $aor_partial, $aor_start, $blocker, $blocker_end, $blocker_exact, $blocker_exists, $blocker_partial, $blocker_start, $company, $company2, $company_exists, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $last_time_banned, $last_time_banned_after, $last_time_banned_before, $last_time_banned_exists, $last_time_banned_start, $last_time_banned_strictly_after, $last_time_banned_strictly_before, $_order_aor, $_order_blocker, $_order_id, $_order_ip, $_order_last_time_banned, $_items_per_page, $_page, $_properties, $_timezone);
        return $response;
    }

    /**
     * Operation getBannedAddressCollectionWithHttpInfo
     *
     * Retrieves the collection of BannedAddress resources.
     *
     * @param  string $aor (optional)
     * @param  string $aor_end (optional)
     * @param  string $aor_exact (optional)
     * @param  bool $aor_exists (optional)
     * @param  string $aor_partial (optional)
     * @param  string $aor_start (optional)
     * @param  string $blocker (optional)
     * @param  string $blocker_end (optional)
     * @param  string $blocker_exact (optional)
     * @param  bool $blocker_exists (optional)
     * @param  string $blocker_partial (optional)
     * @param  string $blocker_start (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $last_time_banned (optional)
     * @param  string $last_time_banned_after (optional)
     * @param  string $last_time_banned_before (optional)
     * @param  bool $last_time_banned_exists (optional)
     * @param  string $last_time_banned_start (optional)
     * @param  string $last_time_banned_strictly_after (optional)
     * @param  string $last_time_banned_strictly_before (optional)
     * @param  string $_order_aor (optional)
     * @param  string $_order_blocker (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_last_time_banned (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BannedAddressCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBannedAddressCollectionWithHttpInfo($aor = null, $aor_end = null, $aor_exact = null, $aor_exists = null, $aor_partial = null, $aor_start = null, $blocker = null, $blocker_end = null, $blocker_exact = null, $blocker_exists = null, $blocker_partial = null, $blocker_start = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $last_time_banned = null, $last_time_banned_after = null, $last_time_banned_before = null, $last_time_banned_exists = null, $last_time_banned_start = null, $last_time_banned_strictly_after = null, $last_time_banned_strictly_before = null, $_order_aor = null, $_order_blocker = null, $_order_id = null, $_order_ip = null, $_order_last_time_banned = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BannedAddressCollection[]';
        $request = $this->getBannedAddressCollectionRequest($aor, $aor_end, $aor_exact, $aor_exists, $aor_partial, $aor_start, $blocker, $blocker_end, $blocker_exact, $blocker_exists, $blocker_partial, $blocker_start, $company, $company2, $company_exists, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $last_time_banned, $last_time_banned_after, $last_time_banned_before, $last_time_banned_exists, $last_time_banned_start, $last_time_banned_strictly_after, $last_time_banned_strictly_before, $_order_aor, $_order_blocker, $_order_id, $_order_ip, $_order_last_time_banned, $_items_per_page, $_page, $_properties, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BannedAddressCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBannedAddressCollectionAsync
     *
     * Retrieves the collection of BannedAddress resources.
     *
     * @param  string $aor (optional)
     * @param  string $aor_end (optional)
     * @param  string $aor_exact (optional)
     * @param  bool $aor_exists (optional)
     * @param  string $aor_partial (optional)
     * @param  string $aor_start (optional)
     * @param  string $blocker (optional)
     * @param  string $blocker_end (optional)
     * @param  string $blocker_exact (optional)
     * @param  bool $blocker_exists (optional)
     * @param  string $blocker_partial (optional)
     * @param  string $blocker_start (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $last_time_banned (optional)
     * @param  string $last_time_banned_after (optional)
     * @param  string $last_time_banned_before (optional)
     * @param  bool $last_time_banned_exists (optional)
     * @param  string $last_time_banned_start (optional)
     * @param  string $last_time_banned_strictly_after (optional)
     * @param  string $last_time_banned_strictly_before (optional)
     * @param  string $_order_aor (optional)
     * @param  string $_order_blocker (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_last_time_banned (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBannedAddressCollectionAsync($aor = null, $aor_end = null, $aor_exact = null, $aor_exists = null, $aor_partial = null, $aor_start = null, $blocker = null, $blocker_end = null, $blocker_exact = null, $blocker_exists = null, $blocker_partial = null, $blocker_start = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $last_time_banned = null, $last_time_banned_after = null, $last_time_banned_before = null, $last_time_banned_exists = null, $last_time_banned_start = null, $last_time_banned_strictly_after = null, $last_time_banned_strictly_before = null, $_order_aor = null, $_order_blocker = null, $_order_id = null, $_order_ip = null, $_order_last_time_banned = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        return $this->getBannedAddressCollectionAsyncWithHttpInfo($aor, $aor_end, $aor_exact, $aor_exists, $aor_partial, $aor_start, $blocker, $blocker_end, $blocker_exact, $blocker_exists, $blocker_partial, $blocker_start, $company, $company2, $company_exists, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $last_time_banned, $last_time_banned_after, $last_time_banned_before, $last_time_banned_exists, $last_time_banned_start, $last_time_banned_strictly_after, $last_time_banned_strictly_before, $_order_aor, $_order_blocker, $_order_id, $_order_ip, $_order_last_time_banned, $_items_per_page, $_page, $_properties, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBannedAddressCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of BannedAddress resources.
     *
     * @param  string $aor (optional)
     * @param  string $aor_end (optional)
     * @param  string $aor_exact (optional)
     * @param  bool $aor_exists (optional)
     * @param  string $aor_partial (optional)
     * @param  string $aor_start (optional)
     * @param  string $blocker (optional)
     * @param  string $blocker_end (optional)
     * @param  string $blocker_exact (optional)
     * @param  bool $blocker_exists (optional)
     * @param  string $blocker_partial (optional)
     * @param  string $blocker_start (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $last_time_banned (optional)
     * @param  string $last_time_banned_after (optional)
     * @param  string $last_time_banned_before (optional)
     * @param  bool $last_time_banned_exists (optional)
     * @param  string $last_time_banned_start (optional)
     * @param  string $last_time_banned_strictly_after (optional)
     * @param  string $last_time_banned_strictly_before (optional)
     * @param  string $_order_aor (optional)
     * @param  string $_order_blocker (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_last_time_banned (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBannedAddressCollectionAsyncWithHttpInfo($aor = null, $aor_end = null, $aor_exact = null, $aor_exists = null, $aor_partial = null, $aor_start = null, $blocker = null, $blocker_end = null, $blocker_exact = null, $blocker_exists = null, $blocker_partial = null, $blocker_start = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $last_time_banned = null, $last_time_banned_after = null, $last_time_banned_before = null, $last_time_banned_exists = null, $last_time_banned_start = null, $last_time_banned_strictly_after = null, $last_time_banned_strictly_before = null, $_order_aor = null, $_order_blocker = null, $_order_id = null, $_order_ip = null, $_order_last_time_banned = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BannedAddressCollection[]';
        $request = $this->getBannedAddressCollectionRequest($aor, $aor_end, $aor_exact, $aor_exists, $aor_partial, $aor_start, $blocker, $blocker_end, $blocker_exact, $blocker_exists, $blocker_partial, $blocker_start, $company, $company2, $company_exists, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $last_time_banned, $last_time_banned_after, $last_time_banned_before, $last_time_banned_exists, $last_time_banned_start, $last_time_banned_strictly_after, $last_time_banned_strictly_before, $_order_aor, $_order_blocker, $_order_id, $_order_ip, $_order_last_time_banned, $_items_per_page, $_page, $_properties, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBannedAddressCollection'
     *
     * @param  string $aor (optional)
     * @param  string $aor_end (optional)
     * @param  string $aor_exact (optional)
     * @param  bool $aor_exists (optional)
     * @param  string $aor_partial (optional)
     * @param  string $aor_start (optional)
     * @param  string $blocker (optional)
     * @param  string $blocker_end (optional)
     * @param  string $blocker_exact (optional)
     * @param  bool $blocker_exists (optional)
     * @param  string $blocker_partial (optional)
     * @param  string $blocker_start (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $last_time_banned (optional)
     * @param  string $last_time_banned_after (optional)
     * @param  string $last_time_banned_before (optional)
     * @param  bool $last_time_banned_exists (optional)
     * @param  string $last_time_banned_start (optional)
     * @param  string $last_time_banned_strictly_after (optional)
     * @param  string $last_time_banned_strictly_before (optional)
     * @param  string $_order_aor (optional)
     * @param  string $_order_blocker (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_last_time_banned (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBannedAddressCollectionRequest($aor = null, $aor_end = null, $aor_exact = null, $aor_exists = null, $aor_partial = null, $aor_start = null, $blocker = null, $blocker_end = null, $blocker_exact = null, $blocker_exists = null, $blocker_partial = null, $blocker_start = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $last_time_banned = null, $last_time_banned_after = null, $last_time_banned_before = null, $last_time_banned_exists = null, $last_time_banned_start = null, $last_time_banned_strictly_after = null, $last_time_banned_strictly_before = null, $_order_aor = null, $_order_blocker = null, $_order_id = null, $_order_ip = null, $_order_last_time_banned = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {

        $resourcePath = '/banned_addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($aor !== null) {
            $queryParams['aor'] = ObjectSerializer::toQueryValue($aor);
        }
        // query params
        if ($aor_end !== null) {
            $queryParams['aor[end]'] = ObjectSerializer::toQueryValue($aor_end);
        }
        // query params
        if ($aor_exact !== null) {
            $queryParams['aor[exact]'] = ObjectSerializer::toQueryValue($aor_exact);
        }
        // query params
        if ($aor_exists !== null) {
            $queryParams['aor[exists]'] = ObjectSerializer::toQueryValue($aor_exists);
        }
        // query params
        if ($aor_partial !== null) {
            $queryParams['aor[partial]'] = ObjectSerializer::toQueryValue($aor_partial);
        }
        // query params
        if ($aor_start !== null) {
            $queryParams['aor[start]'] = ObjectSerializer::toQueryValue($aor_start);
        }
        // query params
        if ($blocker !== null) {
            $queryParams['blocker'] = ObjectSerializer::toQueryValue($blocker);
        }
        // query params
        if ($blocker_end !== null) {
            $queryParams['blocker[end]'] = ObjectSerializer::toQueryValue($blocker_end);
        }
        // query params
        if ($blocker_exact !== null) {
            $queryParams['blocker[exact]'] = ObjectSerializer::toQueryValue($blocker_exact);
        }
        // query params
        if ($blocker_exists !== null) {
            $queryParams['blocker[exists]'] = ObjectSerializer::toQueryValue($blocker_exists);
        }
        // query params
        if ($blocker_partial !== null) {
            $queryParams['blocker[partial]'] = ObjectSerializer::toQueryValue($blocker_partial);
        }
        // query params
        if ($blocker_start !== null) {
            $queryParams['blocker[start]'] = ObjectSerializer::toQueryValue($blocker_start);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($company_exists !== null) {
            $queryParams['company[exists]'] = ObjectSerializer::toQueryValue($company_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }
        // query params
        if ($ip_end !== null) {
            $queryParams['ip[end]'] = ObjectSerializer::toQueryValue($ip_end);
        }
        // query params
        if ($ip_exact !== null) {
            $queryParams['ip[exact]'] = ObjectSerializer::toQueryValue($ip_exact);
        }
        // query params
        if ($ip_exists !== null) {
            $queryParams['ip[exists]'] = ObjectSerializer::toQueryValue($ip_exists);
        }
        // query params
        if ($ip_partial !== null) {
            $queryParams['ip[partial]'] = ObjectSerializer::toQueryValue($ip_partial);
        }
        // query params
        if ($ip_start !== null) {
            $queryParams['ip[start]'] = ObjectSerializer::toQueryValue($ip_start);
        }
        // query params
        if ($last_time_banned !== null) {
            $queryParams['lastTimeBanned'] = ObjectSerializer::toQueryValue($last_time_banned);
        }
        // query params
        if ($last_time_banned_after !== null) {
            $queryParams['lastTimeBanned[after]'] = ObjectSerializer::toQueryValue($last_time_banned_after);
        }
        // query params
        if ($last_time_banned_before !== null) {
            $queryParams['lastTimeBanned[before]'] = ObjectSerializer::toQueryValue($last_time_banned_before);
        }
        // query params
        if ($last_time_banned_exists !== null) {
            $queryParams['lastTimeBanned[exists]'] = ObjectSerializer::toQueryValue($last_time_banned_exists);
        }
        // query params
        if ($last_time_banned_start !== null) {
            $queryParams['lastTimeBanned[start]'] = ObjectSerializer::toQueryValue($last_time_banned_start);
        }
        // query params
        if ($last_time_banned_strictly_after !== null) {
            $queryParams['lastTimeBanned[strictly_after]'] = ObjectSerializer::toQueryValue($last_time_banned_strictly_after);
        }
        // query params
        if ($last_time_banned_strictly_before !== null) {
            $queryParams['lastTimeBanned[strictly_before]'] = ObjectSerializer::toQueryValue($last_time_banned_strictly_before);
        }
        // query params
        if ($_order_aor !== null) {
            $queryParams['_order[aor]'] = ObjectSerializer::toQueryValue($_order_aor);
        }
        // query params
        if ($_order_blocker !== null) {
            $queryParams['_order[blocker]'] = ObjectSerializer::toQueryValue($_order_blocker);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_ip !== null) {
            $queryParams['_order[ip]'] = ObjectSerializer::toQueryValue($_order_ip);
        }
        // query params
        if ($_order_last_time_banned !== null) {
            $queryParams['_order[lastTimeBanned]'] = ObjectSerializer::toQueryValue($_order_last_time_banned);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBannedAddressItem
     *
     * Retrieves a BannedAddress resource.
     *
     * @param  string $id id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BannedAddressDetailed
     */
    public function getBannedAddressItem($id, $_timezone = null)
    {
        list($response) = $this->getBannedAddressItemWithHttpInfo($id, $_timezone);
        return $response;
    }

    /**
     * Operation getBannedAddressItemWithHttpInfo
     *
     * Retrieves a BannedAddress resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BannedAddressDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBannedAddressItemWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BannedAddressDetailed';
        $request = $this->getBannedAddressItemRequest($id, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BannedAddressDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBannedAddressItemAsync
     *
     * Retrieves a BannedAddress resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBannedAddressItemAsync($id, $_timezone = null)
    {
        return $this->getBannedAddressItemAsyncWithHttpInfo($id, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBannedAddressItemAsyncWithHttpInfo
     *
     * Retrieves a BannedAddress resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBannedAddressItemAsyncWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BannedAddressDetailed';
        $request = $this->getBannedAddressItemRequest($id, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBannedAddressItem'
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBannedAddressItemRequest($id, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBannedAddressItem'
            );
        }

        $resourcePath = '/banned_addresses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBillableCallCollection
     *
     * Retrieves the collection of BillableCall resources.
     *
     * @param  string $callee callee (optional)
     * @param  string $callee_end callee_end (optional)
     * @param  string $callee_exact callee_exact (optional)
     * @param  bool $callee_exists callee_exists (optional)
     * @param  string $callee_partial callee_partial (optional)
     * @param  string $callee_start callee_start (optional)
     * @param  string $caller caller (optional)
     * @param  string $caller_end caller_end (optional)
     * @param  string $caller_exact caller_exact (optional)
     * @param  bool $caller_exists caller_exists (optional)
     * @param  string $caller_partial caller_partial (optional)
     * @param  string $caller_start caller_start (optional)
     * @param  string $callid callid (optional)
     * @param  string $callid_end callid_end (optional)
     * @param  string $callid_exact callid_exact (optional)
     * @param  bool $callid_exists callid_exists (optional)
     * @param  string $callid_partial callid_partial (optional)
     * @param  string $callid_start callid_start (optional)
     * @param  string $carrier carrier (optional)
     * @param  string $carrier2 carrier2 (optional)
     * @param  bool $carrier_exists carrier_exists (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  bool $company_exists company_exists (optional)
     * @param  string $cost cost (optional)
     * @param  string $cost_between cost_between (optional)
     * @param  bool $cost_exists cost_exists (optional)
     * @param  string $cost_gt cost_gt (optional)
     * @param  string $cost_gte cost_gte (optional)
     * @param  string $cost_lt cost_lt (optional)
     * @param  string $cost_lte cost_lte (optional)
     * @param  string $ddi ddi (optional)
     * @param  string $ddi_provider ddi_provider (optional)
     * @param  string $ddi_provider2 ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists ddi_provider_exists (optional)
     * @param  string $ddi2 ddi2 (optional)
     * @param  bool $ddi_exists ddi_exists (optional)
     * @param  string $destination destination (optional)
     * @param  string $destination2 destination2 (optional)
     * @param  bool $destination_exists destination_exists (optional)
     * @param  string $direction direction (optional)
     * @param  string $direction_end direction_end (optional)
     * @param  string $direction_exact direction_exact (optional)
     * @param  bool $direction_exists direction_exists (optional)
     * @param  string $direction_partial direction_partial (optional)
     * @param  string $direction_start direction_start (optional)
     * @param  float $duration duration (optional)
     * @param  string $duration_between duration_between (optional)
     * @param  string $duration_gt duration_gt (optional)
     * @param  string $duration_gte duration_gte (optional)
     * @param  string $duration_lt duration_lt (optional)
     * @param  string $duration_lte duration_lte (optional)
     * @param  int $endpoint_id endpoint_id (optional)
     * @param  string $endpoint_id_between endpoint_id_between (optional)
     * @param  bool $endpoint_id_exists endpoint_id_exists (optional)
     * @param  string $endpoint_id_gt endpoint_id_gt (optional)
     * @param  string $endpoint_id_gte endpoint_id_gte (optional)
     * @param  string $endpoint_id_lt endpoint_id_lt (optional)
     * @param  string $endpoint_id_lte endpoint_id_lte (optional)
     * @param  string $endpoint_name endpoint_name (optional)
     * @param  string $endpoint_name_end endpoint_name_end (optional)
     * @param  string $endpoint_name_exact endpoint_name_exact (optional)
     * @param  bool $endpoint_name_exists endpoint_name_exists (optional)
     * @param  string $endpoint_name_partial endpoint_name_partial (optional)
     * @param  string $endpoint_name_start endpoint_name_start (optional)
     * @param  string $endpoint_type endpoint_type (optional)
     * @param  string $endpoint_type_end endpoint_type_end (optional)
     * @param  string $endpoint_type_exact endpoint_type_exact (optional)
     * @param  bool $endpoint_type_exists endpoint_type_exists (optional)
     * @param  string $endpoint_type_partial endpoint_type_partial (optional)
     * @param  string $endpoint_type_start endpoint_type_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $invoice invoice (optional)
     * @param  string $invoice2 invoice2 (optional)
     * @param  bool $invoice_exists invoice_exists (optional)
     * @param  string $price price (optional)
     * @param  string $price_between price_between (optional)
     * @param  bool $price_exists price_exists (optional)
     * @param  string $price_gt price_gt (optional)
     * @param  string $price_gte price_gte (optional)
     * @param  string $price_lt price_lt (optional)
     * @param  string $price_lte price_lte (optional)
     * @param  string $rating_plan_group rating_plan_group (optional)
     * @param  string $rating_plan_group2 rating_plan_group2 (optional)
     * @param  bool $rating_plan_group_exists rating_plan_group_exists (optional)
     * @param  string $start_time start_time (optional)
     * @param  string $start_time_after start_time_after (optional)
     * @param  string $start_time_before start_time_before (optional)
     * @param  bool $start_time_exists start_time_exists (optional)
     * @param  string $start_time_start start_time_start (optional)
     * @param  string $start_time_strictly_after start_time_strictly_after (optional)
     * @param  string $start_time_strictly_before start_time_strictly_before (optional)
     * @param  string $_order_callee _order_callee (optional)
     * @param  string $_order_caller _order_caller (optional)
     * @param  string $_order_callid _order_callid (optional)
     * @param  string $_order_cost _order_cost (optional)
     * @param  string $_order_direction _order_direction (optional)
     * @param  string $_order_duration _order_duration (optional)
     * @param  string $_order_endpoint_id _order_endpoint_id (optional)
     * @param  string $_order_endpoint_name _order_endpoint_name (optional)
     * @param  string $_order_endpoint_type _order_endpoint_type (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_price _order_price (optional)
     * @param  string $_order_start_time _order_start_time (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BillableCallCollection[]
     */
    public function getBillableCallCollection($callee = null, $callee_end = null, $callee_exact = null, $callee_exists = null, $callee_partial = null, $callee_start = null, $caller = null, $caller_end = null, $caller_exact = null, $caller_exists = null, $caller_partial = null, $caller_start = null, $callid = null, $callid_end = null, $callid_exact = null, $callid_exists = null, $callid_partial = null, $callid_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $cost = null, $cost_between = null, $cost_exists = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $destination = null, $destination2 = null, $destination_exists = null, $direction = null, $direction_end = null, $direction_exact = null, $direction_exists = null, $direction_partial = null, $direction_start = null, $duration = null, $duration_between = null, $duration_gt = null, $duration_gte = null, $duration_lt = null, $duration_lte = null, $endpoint_id = null, $endpoint_id_between = null, $endpoint_id_exists = null, $endpoint_id_gt = null, $endpoint_id_gte = null, $endpoint_id_lt = null, $endpoint_id_lte = null, $endpoint_name = null, $endpoint_name_end = null, $endpoint_name_exact = null, $endpoint_name_exists = null, $endpoint_name_partial = null, $endpoint_name_start = null, $endpoint_type = null, $endpoint_type_end = null, $endpoint_type_exact = null, $endpoint_type_exists = null, $endpoint_type_partial = null, $endpoint_type_start = null, $id_exact = null, $invoice = null, $invoice2 = null, $invoice_exists = null, $price = null, $price_between = null, $price_exists = null, $price_gt = null, $price_gte = null, $price_lt = null, $price_lte = null, $rating_plan_group = null, $rating_plan_group2 = null, $rating_plan_group_exists = null, $start_time = null, $start_time_after = null, $start_time_before = null, $start_time_exists = null, $start_time_start = null, $start_time_strictly_after = null, $start_time_strictly_before = null, $_order_callee = null, $_order_caller = null, $_order_callid = null, $_order_cost = null, $_order_direction = null, $_order_duration = null, $_order_endpoint_id = null, $_order_endpoint_name = null, $_order_endpoint_type = null, $_order_id = null, $_order_price = null, $_order_start_time = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null, $_timezone = null)
    {
        list($response) = $this->getBillableCallCollectionWithHttpInfo($callee, $callee_end, $callee_exact, $callee_exists, $callee_partial, $callee_start, $caller, $caller_end, $caller_exact, $caller_exists, $caller_partial, $caller_start, $callid, $callid_end, $callid_exact, $callid_exists, $callid_partial, $callid_start, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $cost, $cost_between, $cost_exists, $cost_gt, $cost_gte, $cost_lt, $cost_lte, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi2, $ddi_exists, $destination, $destination2, $destination_exists, $direction, $direction_end, $direction_exact, $direction_exists, $direction_partial, $direction_start, $duration, $duration_between, $duration_gt, $duration_gte, $duration_lt, $duration_lte, $endpoint_id, $endpoint_id_between, $endpoint_id_exists, $endpoint_id_gt, $endpoint_id_gte, $endpoint_id_lt, $endpoint_id_lte, $endpoint_name, $endpoint_name_end, $endpoint_name_exact, $endpoint_name_exists, $endpoint_name_partial, $endpoint_name_start, $endpoint_type, $endpoint_type_end, $endpoint_type_exact, $endpoint_type_exists, $endpoint_type_partial, $endpoint_type_start, $id_exact, $invoice, $invoice2, $invoice_exists, $price, $price_between, $price_exists, $price_gt, $price_gte, $price_lt, $price_lte, $rating_plan_group, $rating_plan_group2, $rating_plan_group_exists, $start_time, $start_time_after, $start_time_before, $start_time_exists, $start_time_start, $start_time_strictly_after, $start_time_strictly_before, $_order_callee, $_order_caller, $_order_callid, $_order_cost, $_order_direction, $_order_duration, $_order_endpoint_id, $_order_endpoint_name, $_order_endpoint_type, $_order_id, $_order_price, $_order_start_time, $_items_per_page, $_page, $_properties, $_pagination, $_timezone);
        return $response;
    }

    /**
     * Operation getBillableCallCollectionWithHttpInfo
     *
     * Retrieves the collection of BillableCall resources.
     *
     * @param  string $callee (optional)
     * @param  string $callee_end (optional)
     * @param  string $callee_exact (optional)
     * @param  bool $callee_exists (optional)
     * @param  string $callee_partial (optional)
     * @param  string $callee_start (optional)
     * @param  string $caller (optional)
     * @param  string $caller_end (optional)
     * @param  string $caller_exact (optional)
     * @param  bool $caller_exists (optional)
     * @param  string $caller_partial (optional)
     * @param  string $caller_start (optional)
     * @param  string $callid (optional)
     * @param  string $callid_end (optional)
     * @param  string $callid_exact (optional)
     * @param  bool $callid_exists (optional)
     * @param  string $callid_partial (optional)
     * @param  string $callid_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $cost (optional)
     * @param  string $cost_between (optional)
     * @param  bool $cost_exists (optional)
     * @param  string $cost_gt (optional)
     * @param  string $cost_gte (optional)
     * @param  string $cost_lt (optional)
     * @param  string $cost_lte (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi2 (optional)
     * @param  bool $ddi_exists (optional)
     * @param  string $destination (optional)
     * @param  string $destination2 (optional)
     * @param  bool $destination_exists (optional)
     * @param  string $direction (optional)
     * @param  string $direction_end (optional)
     * @param  string $direction_exact (optional)
     * @param  bool $direction_exists (optional)
     * @param  string $direction_partial (optional)
     * @param  string $direction_start (optional)
     * @param  float $duration (optional)
     * @param  string $duration_between (optional)
     * @param  string $duration_gt (optional)
     * @param  string $duration_gte (optional)
     * @param  string $duration_lt (optional)
     * @param  string $duration_lte (optional)
     * @param  int $endpoint_id (optional)
     * @param  string $endpoint_id_between (optional)
     * @param  bool $endpoint_id_exists (optional)
     * @param  string $endpoint_id_gt (optional)
     * @param  string $endpoint_id_gte (optional)
     * @param  string $endpoint_id_lt (optional)
     * @param  string $endpoint_id_lte (optional)
     * @param  string $endpoint_name (optional)
     * @param  string $endpoint_name_end (optional)
     * @param  string $endpoint_name_exact (optional)
     * @param  bool $endpoint_name_exists (optional)
     * @param  string $endpoint_name_partial (optional)
     * @param  string $endpoint_name_start (optional)
     * @param  string $endpoint_type (optional)
     * @param  string $endpoint_type_end (optional)
     * @param  string $endpoint_type_exact (optional)
     * @param  bool $endpoint_type_exists (optional)
     * @param  string $endpoint_type_partial (optional)
     * @param  string $endpoint_type_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice (optional)
     * @param  string $invoice2 (optional)
     * @param  bool $invoice_exists (optional)
     * @param  string $price (optional)
     * @param  string $price_between (optional)
     * @param  bool $price_exists (optional)
     * @param  string $price_gt (optional)
     * @param  string $price_gte (optional)
     * @param  string $price_lt (optional)
     * @param  string $price_lte (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  bool $rating_plan_group_exists (optional)
     * @param  string $start_time (optional)
     * @param  string $start_time_after (optional)
     * @param  string $start_time_before (optional)
     * @param  bool $start_time_exists (optional)
     * @param  string $start_time_start (optional)
     * @param  string $start_time_strictly_after (optional)
     * @param  string $start_time_strictly_before (optional)
     * @param  string $_order_callee (optional)
     * @param  string $_order_caller (optional)
     * @param  string $_order_callid (optional)
     * @param  string $_order_cost (optional)
     * @param  string $_order_direction (optional)
     * @param  string $_order_duration (optional)
     * @param  string $_order_endpoint_id (optional)
     * @param  string $_order_endpoint_name (optional)
     * @param  string $_order_endpoint_type (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_price (optional)
     * @param  string $_order_start_time (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BillableCallCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillableCallCollectionWithHttpInfo($callee = null, $callee_end = null, $callee_exact = null, $callee_exists = null, $callee_partial = null, $callee_start = null, $caller = null, $caller_end = null, $caller_exact = null, $caller_exists = null, $caller_partial = null, $caller_start = null, $callid = null, $callid_end = null, $callid_exact = null, $callid_exists = null, $callid_partial = null, $callid_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $cost = null, $cost_between = null, $cost_exists = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $destination = null, $destination2 = null, $destination_exists = null, $direction = null, $direction_end = null, $direction_exact = null, $direction_exists = null, $direction_partial = null, $direction_start = null, $duration = null, $duration_between = null, $duration_gt = null, $duration_gte = null, $duration_lt = null, $duration_lte = null, $endpoint_id = null, $endpoint_id_between = null, $endpoint_id_exists = null, $endpoint_id_gt = null, $endpoint_id_gte = null, $endpoint_id_lt = null, $endpoint_id_lte = null, $endpoint_name = null, $endpoint_name_end = null, $endpoint_name_exact = null, $endpoint_name_exists = null, $endpoint_name_partial = null, $endpoint_name_start = null, $endpoint_type = null, $endpoint_type_end = null, $endpoint_type_exact = null, $endpoint_type_exists = null, $endpoint_type_partial = null, $endpoint_type_start = null, $id_exact = null, $invoice = null, $invoice2 = null, $invoice_exists = null, $price = null, $price_between = null, $price_exists = null, $price_gt = null, $price_gte = null, $price_lt = null, $price_lte = null, $rating_plan_group = null, $rating_plan_group2 = null, $rating_plan_group_exists = null, $start_time = null, $start_time_after = null, $start_time_before = null, $start_time_exists = null, $start_time_start = null, $start_time_strictly_after = null, $start_time_strictly_before = null, $_order_callee = null, $_order_caller = null, $_order_callid = null, $_order_cost = null, $_order_direction = null, $_order_duration = null, $_order_endpoint_id = null, $_order_endpoint_name = null, $_order_endpoint_type = null, $_order_id = null, $_order_price = null, $_order_start_time = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BillableCallCollection[]';
        $request = $this->getBillableCallCollectionRequest($callee, $callee_end, $callee_exact, $callee_exists, $callee_partial, $callee_start, $caller, $caller_end, $caller_exact, $caller_exists, $caller_partial, $caller_start, $callid, $callid_end, $callid_exact, $callid_exists, $callid_partial, $callid_start, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $cost, $cost_between, $cost_exists, $cost_gt, $cost_gte, $cost_lt, $cost_lte, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi2, $ddi_exists, $destination, $destination2, $destination_exists, $direction, $direction_end, $direction_exact, $direction_exists, $direction_partial, $direction_start, $duration, $duration_between, $duration_gt, $duration_gte, $duration_lt, $duration_lte, $endpoint_id, $endpoint_id_between, $endpoint_id_exists, $endpoint_id_gt, $endpoint_id_gte, $endpoint_id_lt, $endpoint_id_lte, $endpoint_name, $endpoint_name_end, $endpoint_name_exact, $endpoint_name_exists, $endpoint_name_partial, $endpoint_name_start, $endpoint_type, $endpoint_type_end, $endpoint_type_exact, $endpoint_type_exists, $endpoint_type_partial, $endpoint_type_start, $id_exact, $invoice, $invoice2, $invoice_exists, $price, $price_between, $price_exists, $price_gt, $price_gte, $price_lt, $price_lte, $rating_plan_group, $rating_plan_group2, $rating_plan_group_exists, $start_time, $start_time_after, $start_time_before, $start_time_exists, $start_time_start, $start_time_strictly_after, $start_time_strictly_before, $_order_callee, $_order_caller, $_order_callid, $_order_cost, $_order_direction, $_order_duration, $_order_endpoint_id, $_order_endpoint_name, $_order_endpoint_type, $_order_id, $_order_price, $_order_start_time, $_items_per_page, $_page, $_properties, $_pagination, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BillableCallCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBillableCallCollectionAsync
     *
     * Retrieves the collection of BillableCall resources.
     *
     * @param  string $callee (optional)
     * @param  string $callee_end (optional)
     * @param  string $callee_exact (optional)
     * @param  bool $callee_exists (optional)
     * @param  string $callee_partial (optional)
     * @param  string $callee_start (optional)
     * @param  string $caller (optional)
     * @param  string $caller_end (optional)
     * @param  string $caller_exact (optional)
     * @param  bool $caller_exists (optional)
     * @param  string $caller_partial (optional)
     * @param  string $caller_start (optional)
     * @param  string $callid (optional)
     * @param  string $callid_end (optional)
     * @param  string $callid_exact (optional)
     * @param  bool $callid_exists (optional)
     * @param  string $callid_partial (optional)
     * @param  string $callid_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $cost (optional)
     * @param  string $cost_between (optional)
     * @param  bool $cost_exists (optional)
     * @param  string $cost_gt (optional)
     * @param  string $cost_gte (optional)
     * @param  string $cost_lt (optional)
     * @param  string $cost_lte (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi2 (optional)
     * @param  bool $ddi_exists (optional)
     * @param  string $destination (optional)
     * @param  string $destination2 (optional)
     * @param  bool $destination_exists (optional)
     * @param  string $direction (optional)
     * @param  string $direction_end (optional)
     * @param  string $direction_exact (optional)
     * @param  bool $direction_exists (optional)
     * @param  string $direction_partial (optional)
     * @param  string $direction_start (optional)
     * @param  float $duration (optional)
     * @param  string $duration_between (optional)
     * @param  string $duration_gt (optional)
     * @param  string $duration_gte (optional)
     * @param  string $duration_lt (optional)
     * @param  string $duration_lte (optional)
     * @param  int $endpoint_id (optional)
     * @param  string $endpoint_id_between (optional)
     * @param  bool $endpoint_id_exists (optional)
     * @param  string $endpoint_id_gt (optional)
     * @param  string $endpoint_id_gte (optional)
     * @param  string $endpoint_id_lt (optional)
     * @param  string $endpoint_id_lte (optional)
     * @param  string $endpoint_name (optional)
     * @param  string $endpoint_name_end (optional)
     * @param  string $endpoint_name_exact (optional)
     * @param  bool $endpoint_name_exists (optional)
     * @param  string $endpoint_name_partial (optional)
     * @param  string $endpoint_name_start (optional)
     * @param  string $endpoint_type (optional)
     * @param  string $endpoint_type_end (optional)
     * @param  string $endpoint_type_exact (optional)
     * @param  bool $endpoint_type_exists (optional)
     * @param  string $endpoint_type_partial (optional)
     * @param  string $endpoint_type_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice (optional)
     * @param  string $invoice2 (optional)
     * @param  bool $invoice_exists (optional)
     * @param  string $price (optional)
     * @param  string $price_between (optional)
     * @param  bool $price_exists (optional)
     * @param  string $price_gt (optional)
     * @param  string $price_gte (optional)
     * @param  string $price_lt (optional)
     * @param  string $price_lte (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  bool $rating_plan_group_exists (optional)
     * @param  string $start_time (optional)
     * @param  string $start_time_after (optional)
     * @param  string $start_time_before (optional)
     * @param  bool $start_time_exists (optional)
     * @param  string $start_time_start (optional)
     * @param  string $start_time_strictly_after (optional)
     * @param  string $start_time_strictly_before (optional)
     * @param  string $_order_callee (optional)
     * @param  string $_order_caller (optional)
     * @param  string $_order_callid (optional)
     * @param  string $_order_cost (optional)
     * @param  string $_order_direction (optional)
     * @param  string $_order_duration (optional)
     * @param  string $_order_endpoint_id (optional)
     * @param  string $_order_endpoint_name (optional)
     * @param  string $_order_endpoint_type (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_price (optional)
     * @param  string $_order_start_time (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillableCallCollectionAsync($callee = null, $callee_end = null, $callee_exact = null, $callee_exists = null, $callee_partial = null, $callee_start = null, $caller = null, $caller_end = null, $caller_exact = null, $caller_exists = null, $caller_partial = null, $caller_start = null, $callid = null, $callid_end = null, $callid_exact = null, $callid_exists = null, $callid_partial = null, $callid_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $cost = null, $cost_between = null, $cost_exists = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $destination = null, $destination2 = null, $destination_exists = null, $direction = null, $direction_end = null, $direction_exact = null, $direction_exists = null, $direction_partial = null, $direction_start = null, $duration = null, $duration_between = null, $duration_gt = null, $duration_gte = null, $duration_lt = null, $duration_lte = null, $endpoint_id = null, $endpoint_id_between = null, $endpoint_id_exists = null, $endpoint_id_gt = null, $endpoint_id_gte = null, $endpoint_id_lt = null, $endpoint_id_lte = null, $endpoint_name = null, $endpoint_name_end = null, $endpoint_name_exact = null, $endpoint_name_exists = null, $endpoint_name_partial = null, $endpoint_name_start = null, $endpoint_type = null, $endpoint_type_end = null, $endpoint_type_exact = null, $endpoint_type_exists = null, $endpoint_type_partial = null, $endpoint_type_start = null, $id_exact = null, $invoice = null, $invoice2 = null, $invoice_exists = null, $price = null, $price_between = null, $price_exists = null, $price_gt = null, $price_gte = null, $price_lt = null, $price_lte = null, $rating_plan_group = null, $rating_plan_group2 = null, $rating_plan_group_exists = null, $start_time = null, $start_time_after = null, $start_time_before = null, $start_time_exists = null, $start_time_start = null, $start_time_strictly_after = null, $start_time_strictly_before = null, $_order_callee = null, $_order_caller = null, $_order_callid = null, $_order_cost = null, $_order_direction = null, $_order_duration = null, $_order_endpoint_id = null, $_order_endpoint_name = null, $_order_endpoint_type = null, $_order_id = null, $_order_price = null, $_order_start_time = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null, $_timezone = null)
    {
        return $this->getBillableCallCollectionAsyncWithHttpInfo($callee, $callee_end, $callee_exact, $callee_exists, $callee_partial, $callee_start, $caller, $caller_end, $caller_exact, $caller_exists, $caller_partial, $caller_start, $callid, $callid_end, $callid_exact, $callid_exists, $callid_partial, $callid_start, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $cost, $cost_between, $cost_exists, $cost_gt, $cost_gte, $cost_lt, $cost_lte, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi2, $ddi_exists, $destination, $destination2, $destination_exists, $direction, $direction_end, $direction_exact, $direction_exists, $direction_partial, $direction_start, $duration, $duration_between, $duration_gt, $duration_gte, $duration_lt, $duration_lte, $endpoint_id, $endpoint_id_between, $endpoint_id_exists, $endpoint_id_gt, $endpoint_id_gte, $endpoint_id_lt, $endpoint_id_lte, $endpoint_name, $endpoint_name_end, $endpoint_name_exact, $endpoint_name_exists, $endpoint_name_partial, $endpoint_name_start, $endpoint_type, $endpoint_type_end, $endpoint_type_exact, $endpoint_type_exists, $endpoint_type_partial, $endpoint_type_start, $id_exact, $invoice, $invoice2, $invoice_exists, $price, $price_between, $price_exists, $price_gt, $price_gte, $price_lt, $price_lte, $rating_plan_group, $rating_plan_group2, $rating_plan_group_exists, $start_time, $start_time_after, $start_time_before, $start_time_exists, $start_time_start, $start_time_strictly_after, $start_time_strictly_before, $_order_callee, $_order_caller, $_order_callid, $_order_cost, $_order_direction, $_order_duration, $_order_endpoint_id, $_order_endpoint_name, $_order_endpoint_type, $_order_id, $_order_price, $_order_start_time, $_items_per_page, $_page, $_properties, $_pagination, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBillableCallCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of BillableCall resources.
     *
     * @param  string $callee (optional)
     * @param  string $callee_end (optional)
     * @param  string $callee_exact (optional)
     * @param  bool $callee_exists (optional)
     * @param  string $callee_partial (optional)
     * @param  string $callee_start (optional)
     * @param  string $caller (optional)
     * @param  string $caller_end (optional)
     * @param  string $caller_exact (optional)
     * @param  bool $caller_exists (optional)
     * @param  string $caller_partial (optional)
     * @param  string $caller_start (optional)
     * @param  string $callid (optional)
     * @param  string $callid_end (optional)
     * @param  string $callid_exact (optional)
     * @param  bool $callid_exists (optional)
     * @param  string $callid_partial (optional)
     * @param  string $callid_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $cost (optional)
     * @param  string $cost_between (optional)
     * @param  bool $cost_exists (optional)
     * @param  string $cost_gt (optional)
     * @param  string $cost_gte (optional)
     * @param  string $cost_lt (optional)
     * @param  string $cost_lte (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi2 (optional)
     * @param  bool $ddi_exists (optional)
     * @param  string $destination (optional)
     * @param  string $destination2 (optional)
     * @param  bool $destination_exists (optional)
     * @param  string $direction (optional)
     * @param  string $direction_end (optional)
     * @param  string $direction_exact (optional)
     * @param  bool $direction_exists (optional)
     * @param  string $direction_partial (optional)
     * @param  string $direction_start (optional)
     * @param  float $duration (optional)
     * @param  string $duration_between (optional)
     * @param  string $duration_gt (optional)
     * @param  string $duration_gte (optional)
     * @param  string $duration_lt (optional)
     * @param  string $duration_lte (optional)
     * @param  int $endpoint_id (optional)
     * @param  string $endpoint_id_between (optional)
     * @param  bool $endpoint_id_exists (optional)
     * @param  string $endpoint_id_gt (optional)
     * @param  string $endpoint_id_gte (optional)
     * @param  string $endpoint_id_lt (optional)
     * @param  string $endpoint_id_lte (optional)
     * @param  string $endpoint_name (optional)
     * @param  string $endpoint_name_end (optional)
     * @param  string $endpoint_name_exact (optional)
     * @param  bool $endpoint_name_exists (optional)
     * @param  string $endpoint_name_partial (optional)
     * @param  string $endpoint_name_start (optional)
     * @param  string $endpoint_type (optional)
     * @param  string $endpoint_type_end (optional)
     * @param  string $endpoint_type_exact (optional)
     * @param  bool $endpoint_type_exists (optional)
     * @param  string $endpoint_type_partial (optional)
     * @param  string $endpoint_type_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice (optional)
     * @param  string $invoice2 (optional)
     * @param  bool $invoice_exists (optional)
     * @param  string $price (optional)
     * @param  string $price_between (optional)
     * @param  bool $price_exists (optional)
     * @param  string $price_gt (optional)
     * @param  string $price_gte (optional)
     * @param  string $price_lt (optional)
     * @param  string $price_lte (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  bool $rating_plan_group_exists (optional)
     * @param  string $start_time (optional)
     * @param  string $start_time_after (optional)
     * @param  string $start_time_before (optional)
     * @param  bool $start_time_exists (optional)
     * @param  string $start_time_start (optional)
     * @param  string $start_time_strictly_after (optional)
     * @param  string $start_time_strictly_before (optional)
     * @param  string $_order_callee (optional)
     * @param  string $_order_caller (optional)
     * @param  string $_order_callid (optional)
     * @param  string $_order_cost (optional)
     * @param  string $_order_direction (optional)
     * @param  string $_order_duration (optional)
     * @param  string $_order_endpoint_id (optional)
     * @param  string $_order_endpoint_name (optional)
     * @param  string $_order_endpoint_type (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_price (optional)
     * @param  string $_order_start_time (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillableCallCollectionAsyncWithHttpInfo($callee = null, $callee_end = null, $callee_exact = null, $callee_exists = null, $callee_partial = null, $callee_start = null, $caller = null, $caller_end = null, $caller_exact = null, $caller_exists = null, $caller_partial = null, $caller_start = null, $callid = null, $callid_end = null, $callid_exact = null, $callid_exists = null, $callid_partial = null, $callid_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $cost = null, $cost_between = null, $cost_exists = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $destination = null, $destination2 = null, $destination_exists = null, $direction = null, $direction_end = null, $direction_exact = null, $direction_exists = null, $direction_partial = null, $direction_start = null, $duration = null, $duration_between = null, $duration_gt = null, $duration_gte = null, $duration_lt = null, $duration_lte = null, $endpoint_id = null, $endpoint_id_between = null, $endpoint_id_exists = null, $endpoint_id_gt = null, $endpoint_id_gte = null, $endpoint_id_lt = null, $endpoint_id_lte = null, $endpoint_name = null, $endpoint_name_end = null, $endpoint_name_exact = null, $endpoint_name_exists = null, $endpoint_name_partial = null, $endpoint_name_start = null, $endpoint_type = null, $endpoint_type_end = null, $endpoint_type_exact = null, $endpoint_type_exists = null, $endpoint_type_partial = null, $endpoint_type_start = null, $id_exact = null, $invoice = null, $invoice2 = null, $invoice_exists = null, $price = null, $price_between = null, $price_exists = null, $price_gt = null, $price_gte = null, $price_lt = null, $price_lte = null, $rating_plan_group = null, $rating_plan_group2 = null, $rating_plan_group_exists = null, $start_time = null, $start_time_after = null, $start_time_before = null, $start_time_exists = null, $start_time_start = null, $start_time_strictly_after = null, $start_time_strictly_before = null, $_order_callee = null, $_order_caller = null, $_order_callid = null, $_order_cost = null, $_order_direction = null, $_order_duration = null, $_order_endpoint_id = null, $_order_endpoint_name = null, $_order_endpoint_type = null, $_order_id = null, $_order_price = null, $_order_start_time = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BillableCallCollection[]';
        $request = $this->getBillableCallCollectionRequest($callee, $callee_end, $callee_exact, $callee_exists, $callee_partial, $callee_start, $caller, $caller_end, $caller_exact, $caller_exists, $caller_partial, $caller_start, $callid, $callid_end, $callid_exact, $callid_exists, $callid_partial, $callid_start, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $cost, $cost_between, $cost_exists, $cost_gt, $cost_gte, $cost_lt, $cost_lte, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi2, $ddi_exists, $destination, $destination2, $destination_exists, $direction, $direction_end, $direction_exact, $direction_exists, $direction_partial, $direction_start, $duration, $duration_between, $duration_gt, $duration_gte, $duration_lt, $duration_lte, $endpoint_id, $endpoint_id_between, $endpoint_id_exists, $endpoint_id_gt, $endpoint_id_gte, $endpoint_id_lt, $endpoint_id_lte, $endpoint_name, $endpoint_name_end, $endpoint_name_exact, $endpoint_name_exists, $endpoint_name_partial, $endpoint_name_start, $endpoint_type, $endpoint_type_end, $endpoint_type_exact, $endpoint_type_exists, $endpoint_type_partial, $endpoint_type_start, $id_exact, $invoice, $invoice2, $invoice_exists, $price, $price_between, $price_exists, $price_gt, $price_gte, $price_lt, $price_lte, $rating_plan_group, $rating_plan_group2, $rating_plan_group_exists, $start_time, $start_time_after, $start_time_before, $start_time_exists, $start_time_start, $start_time_strictly_after, $start_time_strictly_before, $_order_callee, $_order_caller, $_order_callid, $_order_cost, $_order_direction, $_order_duration, $_order_endpoint_id, $_order_endpoint_name, $_order_endpoint_type, $_order_id, $_order_price, $_order_start_time, $_items_per_page, $_page, $_properties, $_pagination, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBillableCallCollection'
     *
     * @param  string $callee (optional)
     * @param  string $callee_end (optional)
     * @param  string $callee_exact (optional)
     * @param  bool $callee_exists (optional)
     * @param  string $callee_partial (optional)
     * @param  string $callee_start (optional)
     * @param  string $caller (optional)
     * @param  string $caller_end (optional)
     * @param  string $caller_exact (optional)
     * @param  bool $caller_exists (optional)
     * @param  string $caller_partial (optional)
     * @param  string $caller_start (optional)
     * @param  string $callid (optional)
     * @param  string $callid_end (optional)
     * @param  string $callid_exact (optional)
     * @param  bool $callid_exists (optional)
     * @param  string $callid_partial (optional)
     * @param  string $callid_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $cost (optional)
     * @param  string $cost_between (optional)
     * @param  bool $cost_exists (optional)
     * @param  string $cost_gt (optional)
     * @param  string $cost_gte (optional)
     * @param  string $cost_lt (optional)
     * @param  string $cost_lte (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi2 (optional)
     * @param  bool $ddi_exists (optional)
     * @param  string $destination (optional)
     * @param  string $destination2 (optional)
     * @param  bool $destination_exists (optional)
     * @param  string $direction (optional)
     * @param  string $direction_end (optional)
     * @param  string $direction_exact (optional)
     * @param  bool $direction_exists (optional)
     * @param  string $direction_partial (optional)
     * @param  string $direction_start (optional)
     * @param  float $duration (optional)
     * @param  string $duration_between (optional)
     * @param  string $duration_gt (optional)
     * @param  string $duration_gte (optional)
     * @param  string $duration_lt (optional)
     * @param  string $duration_lte (optional)
     * @param  int $endpoint_id (optional)
     * @param  string $endpoint_id_between (optional)
     * @param  bool $endpoint_id_exists (optional)
     * @param  string $endpoint_id_gt (optional)
     * @param  string $endpoint_id_gte (optional)
     * @param  string $endpoint_id_lt (optional)
     * @param  string $endpoint_id_lte (optional)
     * @param  string $endpoint_name (optional)
     * @param  string $endpoint_name_end (optional)
     * @param  string $endpoint_name_exact (optional)
     * @param  bool $endpoint_name_exists (optional)
     * @param  string $endpoint_name_partial (optional)
     * @param  string $endpoint_name_start (optional)
     * @param  string $endpoint_type (optional)
     * @param  string $endpoint_type_end (optional)
     * @param  string $endpoint_type_exact (optional)
     * @param  bool $endpoint_type_exists (optional)
     * @param  string $endpoint_type_partial (optional)
     * @param  string $endpoint_type_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice (optional)
     * @param  string $invoice2 (optional)
     * @param  bool $invoice_exists (optional)
     * @param  string $price (optional)
     * @param  string $price_between (optional)
     * @param  bool $price_exists (optional)
     * @param  string $price_gt (optional)
     * @param  string $price_gte (optional)
     * @param  string $price_lt (optional)
     * @param  string $price_lte (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  bool $rating_plan_group_exists (optional)
     * @param  string $start_time (optional)
     * @param  string $start_time_after (optional)
     * @param  string $start_time_before (optional)
     * @param  bool $start_time_exists (optional)
     * @param  string $start_time_start (optional)
     * @param  string $start_time_strictly_after (optional)
     * @param  string $start_time_strictly_before (optional)
     * @param  string $_order_callee (optional)
     * @param  string $_order_caller (optional)
     * @param  string $_order_callid (optional)
     * @param  string $_order_cost (optional)
     * @param  string $_order_direction (optional)
     * @param  string $_order_duration (optional)
     * @param  string $_order_endpoint_id (optional)
     * @param  string $_order_endpoint_name (optional)
     * @param  string $_order_endpoint_type (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_price (optional)
     * @param  string $_order_start_time (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBillableCallCollectionRequest($callee = null, $callee_end = null, $callee_exact = null, $callee_exists = null, $callee_partial = null, $callee_start = null, $caller = null, $caller_end = null, $caller_exact = null, $caller_exists = null, $caller_partial = null, $caller_start = null, $callid = null, $callid_end = null, $callid_exact = null, $callid_exists = null, $callid_partial = null, $callid_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $cost = null, $cost_between = null, $cost_exists = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $destination = null, $destination2 = null, $destination_exists = null, $direction = null, $direction_end = null, $direction_exact = null, $direction_exists = null, $direction_partial = null, $direction_start = null, $duration = null, $duration_between = null, $duration_gt = null, $duration_gte = null, $duration_lt = null, $duration_lte = null, $endpoint_id = null, $endpoint_id_between = null, $endpoint_id_exists = null, $endpoint_id_gt = null, $endpoint_id_gte = null, $endpoint_id_lt = null, $endpoint_id_lte = null, $endpoint_name = null, $endpoint_name_end = null, $endpoint_name_exact = null, $endpoint_name_exists = null, $endpoint_name_partial = null, $endpoint_name_start = null, $endpoint_type = null, $endpoint_type_end = null, $endpoint_type_exact = null, $endpoint_type_exists = null, $endpoint_type_partial = null, $endpoint_type_start = null, $id_exact = null, $invoice = null, $invoice2 = null, $invoice_exists = null, $price = null, $price_between = null, $price_exists = null, $price_gt = null, $price_gte = null, $price_lt = null, $price_lte = null, $rating_plan_group = null, $rating_plan_group2 = null, $rating_plan_group_exists = null, $start_time = null, $start_time_after = null, $start_time_before = null, $start_time_exists = null, $start_time_start = null, $start_time_strictly_after = null, $start_time_strictly_before = null, $_order_callee = null, $_order_caller = null, $_order_callid = null, $_order_cost = null, $_order_direction = null, $_order_duration = null, $_order_endpoint_id = null, $_order_endpoint_name = null, $_order_endpoint_type = null, $_order_id = null, $_order_price = null, $_order_start_time = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null, $_timezone = null)
    {

        $resourcePath = '/billable_calls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($callee !== null) {
            $queryParams['callee'] = ObjectSerializer::toQueryValue($callee);
        }
        // query params
        if ($callee_end !== null) {
            $queryParams['callee[end]'] = ObjectSerializer::toQueryValue($callee_end);
        }
        // query params
        if ($callee_exact !== null) {
            $queryParams['callee[exact]'] = ObjectSerializer::toQueryValue($callee_exact);
        }
        // query params
        if ($callee_exists !== null) {
            $queryParams['callee[exists]'] = ObjectSerializer::toQueryValue($callee_exists);
        }
        // query params
        if ($callee_partial !== null) {
            $queryParams['callee[partial]'] = ObjectSerializer::toQueryValue($callee_partial);
        }
        // query params
        if ($callee_start !== null) {
            $queryParams['callee[start]'] = ObjectSerializer::toQueryValue($callee_start);
        }
        // query params
        if ($caller !== null) {
            $queryParams['caller'] = ObjectSerializer::toQueryValue($caller);
        }
        // query params
        if ($caller_end !== null) {
            $queryParams['caller[end]'] = ObjectSerializer::toQueryValue($caller_end);
        }
        // query params
        if ($caller_exact !== null) {
            $queryParams['caller[exact]'] = ObjectSerializer::toQueryValue($caller_exact);
        }
        // query params
        if ($caller_exists !== null) {
            $queryParams['caller[exists]'] = ObjectSerializer::toQueryValue($caller_exists);
        }
        // query params
        if ($caller_partial !== null) {
            $queryParams['caller[partial]'] = ObjectSerializer::toQueryValue($caller_partial);
        }
        // query params
        if ($caller_start !== null) {
            $queryParams['caller[start]'] = ObjectSerializer::toQueryValue($caller_start);
        }
        // query params
        if ($callid !== null) {
            $queryParams['callid'] = ObjectSerializer::toQueryValue($callid);
        }
        // query params
        if ($callid_end !== null) {
            $queryParams['callid[end]'] = ObjectSerializer::toQueryValue($callid_end);
        }
        // query params
        if ($callid_exact !== null) {
            $queryParams['callid[exact]'] = ObjectSerializer::toQueryValue($callid_exact);
        }
        // query params
        if ($callid_exists !== null) {
            $queryParams['callid[exists]'] = ObjectSerializer::toQueryValue($callid_exists);
        }
        // query params
        if ($callid_partial !== null) {
            $queryParams['callid[partial]'] = ObjectSerializer::toQueryValue($callid_partial);
        }
        // query params
        if ($callid_start !== null) {
            $queryParams['callid[start]'] = ObjectSerializer::toQueryValue($callid_start);
        }
        // query params
        if ($carrier !== null) {
            $queryParams['carrier'] = ObjectSerializer::toQueryValue($carrier);
        }
        // query params
        if ($carrier2 !== null) {
            $queryParams['carrier[]'] = ObjectSerializer::toQueryValue($carrier2);
        }
        // query params
        if ($carrier_exists !== null) {
            $queryParams['carrier[exists]'] = ObjectSerializer::toQueryValue($carrier_exists);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($company_exists !== null) {
            $queryParams['company[exists]'] = ObjectSerializer::toQueryValue($company_exists);
        }
        // query params
        if ($cost !== null) {
            $queryParams['cost'] = ObjectSerializer::toQueryValue($cost);
        }
        // query params
        if ($cost_between !== null) {
            $queryParams['cost[between]'] = ObjectSerializer::toQueryValue($cost_between);
        }
        // query params
        if ($cost_exists !== null) {
            $queryParams['cost[exists]'] = ObjectSerializer::toQueryValue($cost_exists);
        }
        // query params
        if ($cost_gt !== null) {
            $queryParams['cost[gt]'] = ObjectSerializer::toQueryValue($cost_gt);
        }
        // query params
        if ($cost_gte !== null) {
            $queryParams['cost[gte]'] = ObjectSerializer::toQueryValue($cost_gte);
        }
        // query params
        if ($cost_lt !== null) {
            $queryParams['cost[lt]'] = ObjectSerializer::toQueryValue($cost_lt);
        }
        // query params
        if ($cost_lte !== null) {
            $queryParams['cost[lte]'] = ObjectSerializer::toQueryValue($cost_lte);
        }
        // query params
        if ($ddi !== null) {
            $queryParams['ddi'] = ObjectSerializer::toQueryValue($ddi);
        }
        // query params
        if ($ddi_provider !== null) {
            $queryParams['ddiProvider'] = ObjectSerializer::toQueryValue($ddi_provider);
        }
        // query params
        if ($ddi_provider2 !== null) {
            $queryParams['ddiProvider[]'] = ObjectSerializer::toQueryValue($ddi_provider2);
        }
        // query params
        if ($ddi_provider_exists !== null) {
            $queryParams['ddiProvider[exists]'] = ObjectSerializer::toQueryValue($ddi_provider_exists);
        }
        // query params
        if ($ddi2 !== null) {
            $queryParams['ddi[]'] = ObjectSerializer::toQueryValue($ddi2);
        }
        // query params
        if ($ddi_exists !== null) {
            $queryParams['ddi[exists]'] = ObjectSerializer::toQueryValue($ddi_exists);
        }
        // query params
        if ($destination !== null) {
            $queryParams['destination'] = ObjectSerializer::toQueryValue($destination);
        }
        // query params
        if ($destination2 !== null) {
            $queryParams['destination[]'] = ObjectSerializer::toQueryValue($destination2);
        }
        // query params
        if ($destination_exists !== null) {
            $queryParams['destination[exists]'] = ObjectSerializer::toQueryValue($destination_exists);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }
        // query params
        if ($direction_end !== null) {
            $queryParams['direction[end]'] = ObjectSerializer::toQueryValue($direction_end);
        }
        // query params
        if ($direction_exact !== null) {
            $queryParams['direction[exact]'] = ObjectSerializer::toQueryValue($direction_exact);
        }
        // query params
        if ($direction_exists !== null) {
            $queryParams['direction[exists]'] = ObjectSerializer::toQueryValue($direction_exists);
        }
        // query params
        if ($direction_partial !== null) {
            $queryParams['direction[partial]'] = ObjectSerializer::toQueryValue($direction_partial);
        }
        // query params
        if ($direction_start !== null) {
            $queryParams['direction[start]'] = ObjectSerializer::toQueryValue($direction_start);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($duration_between !== null) {
            $queryParams['duration[between]'] = ObjectSerializer::toQueryValue($duration_between);
        }
        // query params
        if ($duration_gt !== null) {
            $queryParams['duration[gt]'] = ObjectSerializer::toQueryValue($duration_gt);
        }
        // query params
        if ($duration_gte !== null) {
            $queryParams['duration[gte]'] = ObjectSerializer::toQueryValue($duration_gte);
        }
        // query params
        if ($duration_lt !== null) {
            $queryParams['duration[lt]'] = ObjectSerializer::toQueryValue($duration_lt);
        }
        // query params
        if ($duration_lte !== null) {
            $queryParams['duration[lte]'] = ObjectSerializer::toQueryValue($duration_lte);
        }
        // query params
        if ($endpoint_id !== null) {
            $queryParams['endpointId'] = ObjectSerializer::toQueryValue($endpoint_id);
        }
        // query params
        if ($endpoint_id_between !== null) {
            $queryParams['endpointId[between]'] = ObjectSerializer::toQueryValue($endpoint_id_between);
        }
        // query params
        if ($endpoint_id_exists !== null) {
            $queryParams['endpointId[exists]'] = ObjectSerializer::toQueryValue($endpoint_id_exists);
        }
        // query params
        if ($endpoint_id_gt !== null) {
            $queryParams['endpointId[gt]'] = ObjectSerializer::toQueryValue($endpoint_id_gt);
        }
        // query params
        if ($endpoint_id_gte !== null) {
            $queryParams['endpointId[gte]'] = ObjectSerializer::toQueryValue($endpoint_id_gte);
        }
        // query params
        if ($endpoint_id_lt !== null) {
            $queryParams['endpointId[lt]'] = ObjectSerializer::toQueryValue($endpoint_id_lt);
        }
        // query params
        if ($endpoint_id_lte !== null) {
            $queryParams['endpointId[lte]'] = ObjectSerializer::toQueryValue($endpoint_id_lte);
        }
        // query params
        if ($endpoint_name !== null) {
            $queryParams['endpointName'] = ObjectSerializer::toQueryValue($endpoint_name);
        }
        // query params
        if ($endpoint_name_end !== null) {
            $queryParams['endpointName[end]'] = ObjectSerializer::toQueryValue($endpoint_name_end);
        }
        // query params
        if ($endpoint_name_exact !== null) {
            $queryParams['endpointName[exact]'] = ObjectSerializer::toQueryValue($endpoint_name_exact);
        }
        // query params
        if ($endpoint_name_exists !== null) {
            $queryParams['endpointName[exists]'] = ObjectSerializer::toQueryValue($endpoint_name_exists);
        }
        // query params
        if ($endpoint_name_partial !== null) {
            $queryParams['endpointName[partial]'] = ObjectSerializer::toQueryValue($endpoint_name_partial);
        }
        // query params
        if ($endpoint_name_start !== null) {
            $queryParams['endpointName[start]'] = ObjectSerializer::toQueryValue($endpoint_name_start);
        }
        // query params
        if ($endpoint_type !== null) {
            $queryParams['endpointType'] = ObjectSerializer::toQueryValue($endpoint_type);
        }
        // query params
        if ($endpoint_type_end !== null) {
            $queryParams['endpointType[end]'] = ObjectSerializer::toQueryValue($endpoint_type_end);
        }
        // query params
        if ($endpoint_type_exact !== null) {
            $queryParams['endpointType[exact]'] = ObjectSerializer::toQueryValue($endpoint_type_exact);
        }
        // query params
        if ($endpoint_type_exists !== null) {
            $queryParams['endpointType[exists]'] = ObjectSerializer::toQueryValue($endpoint_type_exists);
        }
        // query params
        if ($endpoint_type_partial !== null) {
            $queryParams['endpointType[partial]'] = ObjectSerializer::toQueryValue($endpoint_type_partial);
        }
        // query params
        if ($endpoint_type_start !== null) {
            $queryParams['endpointType[start]'] = ObjectSerializer::toQueryValue($endpoint_type_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($invoice !== null) {
            $queryParams['invoice'] = ObjectSerializer::toQueryValue($invoice);
        }
        // query params
        if ($invoice2 !== null) {
            $queryParams['invoice[]'] = ObjectSerializer::toQueryValue($invoice2);
        }
        // query params
        if ($invoice_exists !== null) {
            $queryParams['invoice[exists]'] = ObjectSerializer::toQueryValue($invoice_exists);
        }
        // query params
        if ($price !== null) {
            $queryParams['price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($price_between !== null) {
            $queryParams['price[between]'] = ObjectSerializer::toQueryValue($price_between);
        }
        // query params
        if ($price_exists !== null) {
            $queryParams['price[exists]'] = ObjectSerializer::toQueryValue($price_exists);
        }
        // query params
        if ($price_gt !== null) {
            $queryParams['price[gt]'] = ObjectSerializer::toQueryValue($price_gt);
        }
        // query params
        if ($price_gte !== null) {
            $queryParams['price[gte]'] = ObjectSerializer::toQueryValue($price_gte);
        }
        // query params
        if ($price_lt !== null) {
            $queryParams['price[lt]'] = ObjectSerializer::toQueryValue($price_lt);
        }
        // query params
        if ($price_lte !== null) {
            $queryParams['price[lte]'] = ObjectSerializer::toQueryValue($price_lte);
        }
        // query params
        if ($rating_plan_group !== null) {
            $queryParams['ratingPlanGroup'] = ObjectSerializer::toQueryValue($rating_plan_group);
        }
        // query params
        if ($rating_plan_group2 !== null) {
            $queryParams['ratingPlanGroup[]'] = ObjectSerializer::toQueryValue($rating_plan_group2);
        }
        // query params
        if ($rating_plan_group_exists !== null) {
            $queryParams['ratingPlanGroup[exists]'] = ObjectSerializer::toQueryValue($rating_plan_group_exists);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = ObjectSerializer::toQueryValue($start_time);
        }
        // query params
        if ($start_time_after !== null) {
            $queryParams['startTime[after]'] = ObjectSerializer::toQueryValue($start_time_after);
        }
        // query params
        if ($start_time_before !== null) {
            $queryParams['startTime[before]'] = ObjectSerializer::toQueryValue($start_time_before);
        }
        // query params
        if ($start_time_exists !== null) {
            $queryParams['startTime[exists]'] = ObjectSerializer::toQueryValue($start_time_exists);
        }
        // query params
        if ($start_time_start !== null) {
            $queryParams['startTime[start]'] = ObjectSerializer::toQueryValue($start_time_start);
        }
        // query params
        if ($start_time_strictly_after !== null) {
            $queryParams['startTime[strictly_after]'] = ObjectSerializer::toQueryValue($start_time_strictly_after);
        }
        // query params
        if ($start_time_strictly_before !== null) {
            $queryParams['startTime[strictly_before]'] = ObjectSerializer::toQueryValue($start_time_strictly_before);
        }
        // query params
        if ($_order_callee !== null) {
            $queryParams['_order[callee]'] = ObjectSerializer::toQueryValue($_order_callee);
        }
        // query params
        if ($_order_caller !== null) {
            $queryParams['_order[caller]'] = ObjectSerializer::toQueryValue($_order_caller);
        }
        // query params
        if ($_order_callid !== null) {
            $queryParams['_order[callid]'] = ObjectSerializer::toQueryValue($_order_callid);
        }
        // query params
        if ($_order_cost !== null) {
            $queryParams['_order[cost]'] = ObjectSerializer::toQueryValue($_order_cost);
        }
        // query params
        if ($_order_direction !== null) {
            $queryParams['_order[direction]'] = ObjectSerializer::toQueryValue($_order_direction);
        }
        // query params
        if ($_order_duration !== null) {
            $queryParams['_order[duration]'] = ObjectSerializer::toQueryValue($_order_duration);
        }
        // query params
        if ($_order_endpoint_id !== null) {
            $queryParams['_order[endpointId]'] = ObjectSerializer::toQueryValue($_order_endpoint_id);
        }
        // query params
        if ($_order_endpoint_name !== null) {
            $queryParams['_order[endpointName]'] = ObjectSerializer::toQueryValue($_order_endpoint_name);
        }
        // query params
        if ($_order_endpoint_type !== null) {
            $queryParams['_order[endpointType]'] = ObjectSerializer::toQueryValue($_order_endpoint_type);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_price !== null) {
            $queryParams['_order[price]'] = ObjectSerializer::toQueryValue($_order_price);
        }
        // query params
        if ($_order_start_time !== null) {
            $queryParams['_order[startTime]'] = ObjectSerializer::toQueryValue($_order_start_time);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }
        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json', 'text/csv']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json', 'text/csv'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBillableCallItem
     *
     * Retrieves a BillableCall resource.
     *
     * @param  string $id id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BillableCallDetailed
     */
    public function getBillableCallItem($id, $_timezone = null)
    {
        list($response) = $this->getBillableCallItemWithHttpInfo($id, $_timezone);
        return $response;
    }

    /**
     * Operation getBillableCallItemWithHttpInfo
     *
     * Retrieves a BillableCall resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BillableCallDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillableCallItemWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BillableCallDetailed';
        $request = $this->getBillableCallItemRequest($id, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BillableCallDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBillableCallItemAsync
     *
     * Retrieves a BillableCall resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillableCallItemAsync($id, $_timezone = null)
    {
        return $this->getBillableCallItemAsyncWithHttpInfo($id, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBillableCallItemAsyncWithHttpInfo
     *
     * Retrieves a BillableCall resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillableCallItemAsyncWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BillableCallDetailed';
        $request = $this->getBillableCallItemRequest($id, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBillableCallItem'
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBillableCallItemRequest($id, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBillableCallItem'
            );
        }

        $resourcePath = '/billable_calls/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBrandCollection
     *
     * Retrieves the collection of Brand resources.
     *
     * @param  string $call_csv_notification_template call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists call_csv_notification_template_exists (optional)
     * @param  string $currency currency (optional)
     * @param  string $currency2 currency2 (optional)
     * @param  bool $currency_exists currency_exists (optional)
     * @param  string $default_timezone default_timezone (optional)
     * @param  string $default_timezone2 default_timezone2 (optional)
     * @param  string $fax_notification_template fax_notification_template (optional)
     * @param  string $fax_notification_template2 fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists fax_notification_template_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $invoice_country invoice_country (optional)
     * @param  string $invoice_country_end invoice_country_end (optional)
     * @param  string $invoice_country_exact invoice_country_exact (optional)
     * @param  string $invoice_country_partial invoice_country_partial (optional)
     * @param  string $invoice_country_start invoice_country_start (optional)
     * @param  string $invoice_nif invoice_nif (optional)
     * @param  string $invoice_nif_end invoice_nif_end (optional)
     * @param  string $invoice_nif_exact invoice_nif_exact (optional)
     * @param  string $invoice_nif_partial invoice_nif_partial (optional)
     * @param  string $invoice_nif_start invoice_nif_start (optional)
     * @param  string $invoice_postal_address invoice_postal_address (optional)
     * @param  string $invoice_postal_address_end invoice_postal_address_end (optional)
     * @param  string $invoice_postal_address_exact invoice_postal_address_exact (optional)
     * @param  string $invoice_postal_address_partial invoice_postal_address_partial (optional)
     * @param  string $invoice_postal_address_start invoice_postal_address_start (optional)
     * @param  string $invoice_postal_code invoice_postal_code (optional)
     * @param  string $invoice_postal_code_end invoice_postal_code_end (optional)
     * @param  string $invoice_postal_code_exact invoice_postal_code_exact (optional)
     * @param  string $invoice_postal_code_partial invoice_postal_code_partial (optional)
     * @param  string $invoice_postal_code_start invoice_postal_code_start (optional)
     * @param  string $invoice_province invoice_province (optional)
     * @param  string $invoice_province_end invoice_province_end (optional)
     * @param  string $invoice_province_exact invoice_province_exact (optional)
     * @param  string $invoice_province_partial invoice_province_partial (optional)
     * @param  string $invoice_province_start invoice_province_start (optional)
     * @param  string $invoice_registry_data invoice_registry_data (optional)
     * @param  string $invoice_registry_data_end invoice_registry_data_end (optional)
     * @param  string $invoice_registry_data_exact invoice_registry_data_exact (optional)
     * @param  bool $invoice_registry_data_exists invoice_registry_data_exists (optional)
     * @param  string $invoice_registry_data_partial invoice_registry_data_partial (optional)
     * @param  string $invoice_registry_data_start invoice_registry_data_start (optional)
     * @param  string $invoice_town invoice_town (optional)
     * @param  string $invoice_town_end invoice_town_end (optional)
     * @param  string $invoice_town_exact invoice_town_exact (optional)
     * @param  string $invoice_town_partial invoice_town_partial (optional)
     * @param  string $invoice_town_start invoice_town_start (optional)
     * @param  string $invoice_notification_template invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists invoice_notification_template_exists (optional)
     * @param  string $language language (optional)
     * @param  string $language2 language2 (optional)
     * @param  bool $language_exists language_exists (optional)
     * @param  string $logo_base_name logo_base_name (optional)
     * @param  string $logo_base_name_end logo_base_name_end (optional)
     * @param  string $logo_base_name_exact logo_base_name_exact (optional)
     * @param  bool $logo_base_name_exists logo_base_name_exists (optional)
     * @param  string $logo_base_name_partial logo_base_name_partial (optional)
     * @param  string $logo_base_name_start logo_base_name_start (optional)
     * @param  int $logo_file_size logo_file_size (optional)
     * @param  string $logo_file_size_between logo_file_size_between (optional)
     * @param  bool $logo_file_size_exists logo_file_size_exists (optional)
     * @param  string $logo_file_size_gt logo_file_size_gt (optional)
     * @param  string $logo_file_size_gte logo_file_size_gte (optional)
     * @param  string $logo_file_size_lt logo_file_size_lt (optional)
     * @param  string $logo_file_size_lte logo_file_size_lte (optional)
     * @param  string $logo_mime_type logo_mime_type (optional)
     * @param  string $logo_mime_type_end logo_mime_type_end (optional)
     * @param  string $logo_mime_type_exact logo_mime_type_exact (optional)
     * @param  bool $logo_mime_type_exists logo_mime_type_exists (optional)
     * @param  string $logo_mime_type_partial logo_mime_type_partial (optional)
     * @param  string $logo_mime_type_start logo_mime_type_start (optional)
     * @param  string $max_daily_usage_notification_template max_daily_usage_notification_template (optional)
     * @param  string $max_daily_usage_notification_template2 max_daily_usage_notification_template2 (optional)
     * @param  bool $max_daily_usage_notification_template_exists max_daily_usage_notification_template_exists (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $voicemail_notification_template voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists voicemail_notification_template_exists (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_invoice_country _order_invoice_country (optional)
     * @param  string $_order_invoice_nif _order_invoice_nif (optional)
     * @param  string $_order_invoice_postal_address _order_invoice_postal_address (optional)
     * @param  string $_order_invoice_postal_code _order_invoice_postal_code (optional)
     * @param  string $_order_invoice_province _order_invoice_province (optional)
     * @param  string $_order_invoice_registry_data _order_invoice_registry_data (optional)
     * @param  string $_order_invoice_town _order_invoice_town (optional)
     * @param  string $_order_logo_base_name _order_logo_base_name (optional)
     * @param  string $_order_logo_file_size _order_logo_file_size (optional)
     * @param  string $_order_logo_mime_type _order_logo_mime_type (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BrandCollection[]
     */
    public function getBrandCollection($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_country = null, $invoice_country_end = null, $invoice_country_exact = null, $invoice_country_partial = null, $invoice_country_start = null, $invoice_nif = null, $invoice_nif_end = null, $invoice_nif_exact = null, $invoice_nif_partial = null, $invoice_nif_start = null, $invoice_postal_address = null, $invoice_postal_address_end = null, $invoice_postal_address_exact = null, $invoice_postal_address_partial = null, $invoice_postal_address_start = null, $invoice_postal_code = null, $invoice_postal_code_end = null, $invoice_postal_code_exact = null, $invoice_postal_code_partial = null, $invoice_postal_code_start = null, $invoice_province = null, $invoice_province_end = null, $invoice_province_exact = null, $invoice_province_partial = null, $invoice_province_start = null, $invoice_registry_data = null, $invoice_registry_data_end = null, $invoice_registry_data_exact = null, $invoice_registry_data_exists = null, $invoice_registry_data_partial = null, $invoice_registry_data_start = null, $invoice_town = null, $invoice_town_end = null, $invoice_town_exact = null, $invoice_town_partial = null, $invoice_town_start = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $logo_base_name = null, $logo_base_name_end = null, $logo_base_name_exact = null, $logo_base_name_exists = null, $logo_base_name_partial = null, $logo_base_name_start = null, $logo_file_size = null, $logo_file_size_between = null, $logo_file_size_exists = null, $logo_file_size_gt = null, $logo_file_size_gte = null, $logo_file_size_lt = null, $logo_file_size_lte = null, $logo_mime_type = null, $logo_mime_type_end = null, $logo_mime_type_exact = null, $logo_mime_type_exists = null, $logo_mime_type_partial = null, $logo_mime_type_start = null, $max_daily_usage_notification_template = null, $max_daily_usage_notification_template2 = null, $max_daily_usage_notification_template_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_invoice_country = null, $_order_invoice_nif = null, $_order_invoice_postal_address = null, $_order_invoice_postal_code = null, $_order_invoice_province = null, $_order_invoice_registry_data = null, $_order_invoice_town = null, $_order_logo_base_name = null, $_order_logo_file_size = null, $_order_logo_mime_type = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getBrandCollectionWithHttpInfo($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $currency, $currency2, $currency_exists, $default_timezone, $default_timezone2, $fax_notification_template, $fax_notification_template2, $fax_notification_template_exists, $id_exact, $invoice_country, $invoice_country_end, $invoice_country_exact, $invoice_country_partial, $invoice_country_start, $invoice_nif, $invoice_nif_end, $invoice_nif_exact, $invoice_nif_partial, $invoice_nif_start, $invoice_postal_address, $invoice_postal_address_end, $invoice_postal_address_exact, $invoice_postal_address_partial, $invoice_postal_address_start, $invoice_postal_code, $invoice_postal_code_end, $invoice_postal_code_exact, $invoice_postal_code_partial, $invoice_postal_code_start, $invoice_province, $invoice_province_end, $invoice_province_exact, $invoice_province_partial, $invoice_province_start, $invoice_registry_data, $invoice_registry_data_end, $invoice_registry_data_exact, $invoice_registry_data_exists, $invoice_registry_data_partial, $invoice_registry_data_start, $invoice_town, $invoice_town_end, $invoice_town_exact, $invoice_town_partial, $invoice_town_start, $invoice_notification_template, $invoice_notification_template2, $invoice_notification_template_exists, $language, $language2, $language_exists, $logo_base_name, $logo_base_name_end, $logo_base_name_exact, $logo_base_name_exists, $logo_base_name_partial, $logo_base_name_start, $logo_file_size, $logo_file_size_between, $logo_file_size_exists, $logo_file_size_gt, $logo_file_size_gte, $logo_file_size_lt, $logo_file_size_lte, $logo_mime_type, $logo_mime_type_end, $logo_mime_type_exact, $logo_mime_type_exists, $logo_mime_type_partial, $logo_mime_type_start, $max_daily_usage_notification_template, $max_daily_usage_notification_template2, $max_daily_usage_notification_template_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $voicemail_notification_template, $voicemail_notification_template2, $voicemail_notification_template_exists, $_order_id, $_order_invoice_country, $_order_invoice_nif, $_order_invoice_postal_address, $_order_invoice_postal_code, $_order_invoice_province, $_order_invoice_registry_data, $_order_invoice_town, $_order_logo_base_name, $_order_logo_file_size, $_order_logo_mime_type, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getBrandCollectionWithHttpInfo
     *
     * Retrieves the collection of Brand resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $default_timezone (optional)
     * @param  string $default_timezone2 (optional)
     * @param  string $fax_notification_template (optional)
     * @param  string $fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_country (optional)
     * @param  string $invoice_country_end (optional)
     * @param  string $invoice_country_exact (optional)
     * @param  string $invoice_country_partial (optional)
     * @param  string $invoice_country_start (optional)
     * @param  string $invoice_nif (optional)
     * @param  string $invoice_nif_end (optional)
     * @param  string $invoice_nif_exact (optional)
     * @param  string $invoice_nif_partial (optional)
     * @param  string $invoice_nif_start (optional)
     * @param  string $invoice_postal_address (optional)
     * @param  string $invoice_postal_address_end (optional)
     * @param  string $invoice_postal_address_exact (optional)
     * @param  string $invoice_postal_address_partial (optional)
     * @param  string $invoice_postal_address_start (optional)
     * @param  string $invoice_postal_code (optional)
     * @param  string $invoice_postal_code_end (optional)
     * @param  string $invoice_postal_code_exact (optional)
     * @param  string $invoice_postal_code_partial (optional)
     * @param  string $invoice_postal_code_start (optional)
     * @param  string $invoice_province (optional)
     * @param  string $invoice_province_end (optional)
     * @param  string $invoice_province_exact (optional)
     * @param  string $invoice_province_partial (optional)
     * @param  string $invoice_province_start (optional)
     * @param  string $invoice_registry_data (optional)
     * @param  string $invoice_registry_data_end (optional)
     * @param  string $invoice_registry_data_exact (optional)
     * @param  bool $invoice_registry_data_exists (optional)
     * @param  string $invoice_registry_data_partial (optional)
     * @param  string $invoice_registry_data_start (optional)
     * @param  string $invoice_town (optional)
     * @param  string $invoice_town_end (optional)
     * @param  string $invoice_town_exact (optional)
     * @param  string $invoice_town_partial (optional)
     * @param  string $invoice_town_start (optional)
     * @param  string $invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $logo_base_name (optional)
     * @param  string $logo_base_name_end (optional)
     * @param  string $logo_base_name_exact (optional)
     * @param  bool $logo_base_name_exists (optional)
     * @param  string $logo_base_name_partial (optional)
     * @param  string $logo_base_name_start (optional)
     * @param  int $logo_file_size (optional)
     * @param  string $logo_file_size_between (optional)
     * @param  bool $logo_file_size_exists (optional)
     * @param  string $logo_file_size_gt (optional)
     * @param  string $logo_file_size_gte (optional)
     * @param  string $logo_file_size_lt (optional)
     * @param  string $logo_file_size_lte (optional)
     * @param  string $logo_mime_type (optional)
     * @param  string $logo_mime_type_end (optional)
     * @param  string $logo_mime_type_exact (optional)
     * @param  bool $logo_mime_type_exists (optional)
     * @param  string $logo_mime_type_partial (optional)
     * @param  string $logo_mime_type_start (optional)
     * @param  string $max_daily_usage_notification_template (optional)
     * @param  string $max_daily_usage_notification_template2 (optional)
     * @param  bool $max_daily_usage_notification_template_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_invoice_country (optional)
     * @param  string $_order_invoice_nif (optional)
     * @param  string $_order_invoice_postal_address (optional)
     * @param  string $_order_invoice_postal_code (optional)
     * @param  string $_order_invoice_province (optional)
     * @param  string $_order_invoice_registry_data (optional)
     * @param  string $_order_invoice_town (optional)
     * @param  string $_order_logo_base_name (optional)
     * @param  string $_order_logo_file_size (optional)
     * @param  string $_order_logo_mime_type (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BrandCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandCollectionWithHttpInfo($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_country = null, $invoice_country_end = null, $invoice_country_exact = null, $invoice_country_partial = null, $invoice_country_start = null, $invoice_nif = null, $invoice_nif_end = null, $invoice_nif_exact = null, $invoice_nif_partial = null, $invoice_nif_start = null, $invoice_postal_address = null, $invoice_postal_address_end = null, $invoice_postal_address_exact = null, $invoice_postal_address_partial = null, $invoice_postal_address_start = null, $invoice_postal_code = null, $invoice_postal_code_end = null, $invoice_postal_code_exact = null, $invoice_postal_code_partial = null, $invoice_postal_code_start = null, $invoice_province = null, $invoice_province_end = null, $invoice_province_exact = null, $invoice_province_partial = null, $invoice_province_start = null, $invoice_registry_data = null, $invoice_registry_data_end = null, $invoice_registry_data_exact = null, $invoice_registry_data_exists = null, $invoice_registry_data_partial = null, $invoice_registry_data_start = null, $invoice_town = null, $invoice_town_end = null, $invoice_town_exact = null, $invoice_town_partial = null, $invoice_town_start = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $logo_base_name = null, $logo_base_name_end = null, $logo_base_name_exact = null, $logo_base_name_exists = null, $logo_base_name_partial = null, $logo_base_name_start = null, $logo_file_size = null, $logo_file_size_between = null, $logo_file_size_exists = null, $logo_file_size_gt = null, $logo_file_size_gte = null, $logo_file_size_lt = null, $logo_file_size_lte = null, $logo_mime_type = null, $logo_mime_type_end = null, $logo_mime_type_exact = null, $logo_mime_type_exists = null, $logo_mime_type_partial = null, $logo_mime_type_start = null, $max_daily_usage_notification_template = null, $max_daily_usage_notification_template2 = null, $max_daily_usage_notification_template_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_invoice_country = null, $_order_invoice_nif = null, $_order_invoice_postal_address = null, $_order_invoice_postal_code = null, $_order_invoice_province = null, $_order_invoice_registry_data = null, $_order_invoice_town = null, $_order_logo_base_name = null, $_order_logo_file_size = null, $_order_logo_mime_type = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\BrandCollection[]';
        $request = $this->getBrandCollectionRequest($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $currency, $currency2, $currency_exists, $default_timezone, $default_timezone2, $fax_notification_template, $fax_notification_template2, $fax_notification_template_exists, $id_exact, $invoice_country, $invoice_country_end, $invoice_country_exact, $invoice_country_partial, $invoice_country_start, $invoice_nif, $invoice_nif_end, $invoice_nif_exact, $invoice_nif_partial, $invoice_nif_start, $invoice_postal_address, $invoice_postal_address_end, $invoice_postal_address_exact, $invoice_postal_address_partial, $invoice_postal_address_start, $invoice_postal_code, $invoice_postal_code_end, $invoice_postal_code_exact, $invoice_postal_code_partial, $invoice_postal_code_start, $invoice_province, $invoice_province_end, $invoice_province_exact, $invoice_province_partial, $invoice_province_start, $invoice_registry_data, $invoice_registry_data_end, $invoice_registry_data_exact, $invoice_registry_data_exists, $invoice_registry_data_partial, $invoice_registry_data_start, $invoice_town, $invoice_town_end, $invoice_town_exact, $invoice_town_partial, $invoice_town_start, $invoice_notification_template, $invoice_notification_template2, $invoice_notification_template_exists, $language, $language2, $language_exists, $logo_base_name, $logo_base_name_end, $logo_base_name_exact, $logo_base_name_exists, $logo_base_name_partial, $logo_base_name_start, $logo_file_size, $logo_file_size_between, $logo_file_size_exists, $logo_file_size_gt, $logo_file_size_gte, $logo_file_size_lt, $logo_file_size_lte, $logo_mime_type, $logo_mime_type_end, $logo_mime_type_exact, $logo_mime_type_exists, $logo_mime_type_partial, $logo_mime_type_start, $max_daily_usage_notification_template, $max_daily_usage_notification_template2, $max_daily_usage_notification_template_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $voicemail_notification_template, $voicemail_notification_template2, $voicemail_notification_template_exists, $_order_id, $_order_invoice_country, $_order_invoice_nif, $_order_invoice_postal_address, $_order_invoice_postal_code, $_order_invoice_province, $_order_invoice_registry_data, $_order_invoice_town, $_order_logo_base_name, $_order_logo_file_size, $_order_logo_mime_type, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BrandCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBrandCollectionAsync
     *
     * Retrieves the collection of Brand resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $default_timezone (optional)
     * @param  string $default_timezone2 (optional)
     * @param  string $fax_notification_template (optional)
     * @param  string $fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_country (optional)
     * @param  string $invoice_country_end (optional)
     * @param  string $invoice_country_exact (optional)
     * @param  string $invoice_country_partial (optional)
     * @param  string $invoice_country_start (optional)
     * @param  string $invoice_nif (optional)
     * @param  string $invoice_nif_end (optional)
     * @param  string $invoice_nif_exact (optional)
     * @param  string $invoice_nif_partial (optional)
     * @param  string $invoice_nif_start (optional)
     * @param  string $invoice_postal_address (optional)
     * @param  string $invoice_postal_address_end (optional)
     * @param  string $invoice_postal_address_exact (optional)
     * @param  string $invoice_postal_address_partial (optional)
     * @param  string $invoice_postal_address_start (optional)
     * @param  string $invoice_postal_code (optional)
     * @param  string $invoice_postal_code_end (optional)
     * @param  string $invoice_postal_code_exact (optional)
     * @param  string $invoice_postal_code_partial (optional)
     * @param  string $invoice_postal_code_start (optional)
     * @param  string $invoice_province (optional)
     * @param  string $invoice_province_end (optional)
     * @param  string $invoice_province_exact (optional)
     * @param  string $invoice_province_partial (optional)
     * @param  string $invoice_province_start (optional)
     * @param  string $invoice_registry_data (optional)
     * @param  string $invoice_registry_data_end (optional)
     * @param  string $invoice_registry_data_exact (optional)
     * @param  bool $invoice_registry_data_exists (optional)
     * @param  string $invoice_registry_data_partial (optional)
     * @param  string $invoice_registry_data_start (optional)
     * @param  string $invoice_town (optional)
     * @param  string $invoice_town_end (optional)
     * @param  string $invoice_town_exact (optional)
     * @param  string $invoice_town_partial (optional)
     * @param  string $invoice_town_start (optional)
     * @param  string $invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $logo_base_name (optional)
     * @param  string $logo_base_name_end (optional)
     * @param  string $logo_base_name_exact (optional)
     * @param  bool $logo_base_name_exists (optional)
     * @param  string $logo_base_name_partial (optional)
     * @param  string $logo_base_name_start (optional)
     * @param  int $logo_file_size (optional)
     * @param  string $logo_file_size_between (optional)
     * @param  bool $logo_file_size_exists (optional)
     * @param  string $logo_file_size_gt (optional)
     * @param  string $logo_file_size_gte (optional)
     * @param  string $logo_file_size_lt (optional)
     * @param  string $logo_file_size_lte (optional)
     * @param  string $logo_mime_type (optional)
     * @param  string $logo_mime_type_end (optional)
     * @param  string $logo_mime_type_exact (optional)
     * @param  bool $logo_mime_type_exists (optional)
     * @param  string $logo_mime_type_partial (optional)
     * @param  string $logo_mime_type_start (optional)
     * @param  string $max_daily_usage_notification_template (optional)
     * @param  string $max_daily_usage_notification_template2 (optional)
     * @param  bool $max_daily_usage_notification_template_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_invoice_country (optional)
     * @param  string $_order_invoice_nif (optional)
     * @param  string $_order_invoice_postal_address (optional)
     * @param  string $_order_invoice_postal_code (optional)
     * @param  string $_order_invoice_province (optional)
     * @param  string $_order_invoice_registry_data (optional)
     * @param  string $_order_invoice_town (optional)
     * @param  string $_order_logo_base_name (optional)
     * @param  string $_order_logo_file_size (optional)
     * @param  string $_order_logo_mime_type (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandCollectionAsync($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_country = null, $invoice_country_end = null, $invoice_country_exact = null, $invoice_country_partial = null, $invoice_country_start = null, $invoice_nif = null, $invoice_nif_end = null, $invoice_nif_exact = null, $invoice_nif_partial = null, $invoice_nif_start = null, $invoice_postal_address = null, $invoice_postal_address_end = null, $invoice_postal_address_exact = null, $invoice_postal_address_partial = null, $invoice_postal_address_start = null, $invoice_postal_code = null, $invoice_postal_code_end = null, $invoice_postal_code_exact = null, $invoice_postal_code_partial = null, $invoice_postal_code_start = null, $invoice_province = null, $invoice_province_end = null, $invoice_province_exact = null, $invoice_province_partial = null, $invoice_province_start = null, $invoice_registry_data = null, $invoice_registry_data_end = null, $invoice_registry_data_exact = null, $invoice_registry_data_exists = null, $invoice_registry_data_partial = null, $invoice_registry_data_start = null, $invoice_town = null, $invoice_town_end = null, $invoice_town_exact = null, $invoice_town_partial = null, $invoice_town_start = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $logo_base_name = null, $logo_base_name_end = null, $logo_base_name_exact = null, $logo_base_name_exists = null, $logo_base_name_partial = null, $logo_base_name_start = null, $logo_file_size = null, $logo_file_size_between = null, $logo_file_size_exists = null, $logo_file_size_gt = null, $logo_file_size_gte = null, $logo_file_size_lt = null, $logo_file_size_lte = null, $logo_mime_type = null, $logo_mime_type_end = null, $logo_mime_type_exact = null, $logo_mime_type_exists = null, $logo_mime_type_partial = null, $logo_mime_type_start = null, $max_daily_usage_notification_template = null, $max_daily_usage_notification_template2 = null, $max_daily_usage_notification_template_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_invoice_country = null, $_order_invoice_nif = null, $_order_invoice_postal_address = null, $_order_invoice_postal_code = null, $_order_invoice_province = null, $_order_invoice_registry_data = null, $_order_invoice_town = null, $_order_logo_base_name = null, $_order_logo_file_size = null, $_order_logo_mime_type = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getBrandCollectionAsyncWithHttpInfo($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $currency, $currency2, $currency_exists, $default_timezone, $default_timezone2, $fax_notification_template, $fax_notification_template2, $fax_notification_template_exists, $id_exact, $invoice_country, $invoice_country_end, $invoice_country_exact, $invoice_country_partial, $invoice_country_start, $invoice_nif, $invoice_nif_end, $invoice_nif_exact, $invoice_nif_partial, $invoice_nif_start, $invoice_postal_address, $invoice_postal_address_end, $invoice_postal_address_exact, $invoice_postal_address_partial, $invoice_postal_address_start, $invoice_postal_code, $invoice_postal_code_end, $invoice_postal_code_exact, $invoice_postal_code_partial, $invoice_postal_code_start, $invoice_province, $invoice_province_end, $invoice_province_exact, $invoice_province_partial, $invoice_province_start, $invoice_registry_data, $invoice_registry_data_end, $invoice_registry_data_exact, $invoice_registry_data_exists, $invoice_registry_data_partial, $invoice_registry_data_start, $invoice_town, $invoice_town_end, $invoice_town_exact, $invoice_town_partial, $invoice_town_start, $invoice_notification_template, $invoice_notification_template2, $invoice_notification_template_exists, $language, $language2, $language_exists, $logo_base_name, $logo_base_name_end, $logo_base_name_exact, $logo_base_name_exists, $logo_base_name_partial, $logo_base_name_start, $logo_file_size, $logo_file_size_between, $logo_file_size_exists, $logo_file_size_gt, $logo_file_size_gte, $logo_file_size_lt, $logo_file_size_lte, $logo_mime_type, $logo_mime_type_end, $logo_mime_type_exact, $logo_mime_type_exists, $logo_mime_type_partial, $logo_mime_type_start, $max_daily_usage_notification_template, $max_daily_usage_notification_template2, $max_daily_usage_notification_template_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $voicemail_notification_template, $voicemail_notification_template2, $voicemail_notification_template_exists, $_order_id, $_order_invoice_country, $_order_invoice_nif, $_order_invoice_postal_address, $_order_invoice_postal_code, $_order_invoice_province, $_order_invoice_registry_data, $_order_invoice_town, $_order_logo_base_name, $_order_logo_file_size, $_order_logo_mime_type, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Brand resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $default_timezone (optional)
     * @param  string $default_timezone2 (optional)
     * @param  string $fax_notification_template (optional)
     * @param  string $fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_country (optional)
     * @param  string $invoice_country_end (optional)
     * @param  string $invoice_country_exact (optional)
     * @param  string $invoice_country_partial (optional)
     * @param  string $invoice_country_start (optional)
     * @param  string $invoice_nif (optional)
     * @param  string $invoice_nif_end (optional)
     * @param  string $invoice_nif_exact (optional)
     * @param  string $invoice_nif_partial (optional)
     * @param  string $invoice_nif_start (optional)
     * @param  string $invoice_postal_address (optional)
     * @param  string $invoice_postal_address_end (optional)
     * @param  string $invoice_postal_address_exact (optional)
     * @param  string $invoice_postal_address_partial (optional)
     * @param  string $invoice_postal_address_start (optional)
     * @param  string $invoice_postal_code (optional)
     * @param  string $invoice_postal_code_end (optional)
     * @param  string $invoice_postal_code_exact (optional)
     * @param  string $invoice_postal_code_partial (optional)
     * @param  string $invoice_postal_code_start (optional)
     * @param  string $invoice_province (optional)
     * @param  string $invoice_province_end (optional)
     * @param  string $invoice_province_exact (optional)
     * @param  string $invoice_province_partial (optional)
     * @param  string $invoice_province_start (optional)
     * @param  string $invoice_registry_data (optional)
     * @param  string $invoice_registry_data_end (optional)
     * @param  string $invoice_registry_data_exact (optional)
     * @param  bool $invoice_registry_data_exists (optional)
     * @param  string $invoice_registry_data_partial (optional)
     * @param  string $invoice_registry_data_start (optional)
     * @param  string $invoice_town (optional)
     * @param  string $invoice_town_end (optional)
     * @param  string $invoice_town_exact (optional)
     * @param  string $invoice_town_partial (optional)
     * @param  string $invoice_town_start (optional)
     * @param  string $invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $logo_base_name (optional)
     * @param  string $logo_base_name_end (optional)
     * @param  string $logo_base_name_exact (optional)
     * @param  bool $logo_base_name_exists (optional)
     * @param  string $logo_base_name_partial (optional)
     * @param  string $logo_base_name_start (optional)
     * @param  int $logo_file_size (optional)
     * @param  string $logo_file_size_between (optional)
     * @param  bool $logo_file_size_exists (optional)
     * @param  string $logo_file_size_gt (optional)
     * @param  string $logo_file_size_gte (optional)
     * @param  string $logo_file_size_lt (optional)
     * @param  string $logo_file_size_lte (optional)
     * @param  string $logo_mime_type (optional)
     * @param  string $logo_mime_type_end (optional)
     * @param  string $logo_mime_type_exact (optional)
     * @param  bool $logo_mime_type_exists (optional)
     * @param  string $logo_mime_type_partial (optional)
     * @param  string $logo_mime_type_start (optional)
     * @param  string $max_daily_usage_notification_template (optional)
     * @param  string $max_daily_usage_notification_template2 (optional)
     * @param  bool $max_daily_usage_notification_template_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_invoice_country (optional)
     * @param  string $_order_invoice_nif (optional)
     * @param  string $_order_invoice_postal_address (optional)
     * @param  string $_order_invoice_postal_code (optional)
     * @param  string $_order_invoice_province (optional)
     * @param  string $_order_invoice_registry_data (optional)
     * @param  string $_order_invoice_town (optional)
     * @param  string $_order_logo_base_name (optional)
     * @param  string $_order_logo_file_size (optional)
     * @param  string $_order_logo_mime_type (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandCollectionAsyncWithHttpInfo($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_country = null, $invoice_country_end = null, $invoice_country_exact = null, $invoice_country_partial = null, $invoice_country_start = null, $invoice_nif = null, $invoice_nif_end = null, $invoice_nif_exact = null, $invoice_nif_partial = null, $invoice_nif_start = null, $invoice_postal_address = null, $invoice_postal_address_end = null, $invoice_postal_address_exact = null, $invoice_postal_address_partial = null, $invoice_postal_address_start = null, $invoice_postal_code = null, $invoice_postal_code_end = null, $invoice_postal_code_exact = null, $invoice_postal_code_partial = null, $invoice_postal_code_start = null, $invoice_province = null, $invoice_province_end = null, $invoice_province_exact = null, $invoice_province_partial = null, $invoice_province_start = null, $invoice_registry_data = null, $invoice_registry_data_end = null, $invoice_registry_data_exact = null, $invoice_registry_data_exists = null, $invoice_registry_data_partial = null, $invoice_registry_data_start = null, $invoice_town = null, $invoice_town_end = null, $invoice_town_exact = null, $invoice_town_partial = null, $invoice_town_start = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $logo_base_name = null, $logo_base_name_end = null, $logo_base_name_exact = null, $logo_base_name_exists = null, $logo_base_name_partial = null, $logo_base_name_start = null, $logo_file_size = null, $logo_file_size_between = null, $logo_file_size_exists = null, $logo_file_size_gt = null, $logo_file_size_gte = null, $logo_file_size_lt = null, $logo_file_size_lte = null, $logo_mime_type = null, $logo_mime_type_end = null, $logo_mime_type_exact = null, $logo_mime_type_exists = null, $logo_mime_type_partial = null, $logo_mime_type_start = null, $max_daily_usage_notification_template = null, $max_daily_usage_notification_template2 = null, $max_daily_usage_notification_template_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_invoice_country = null, $_order_invoice_nif = null, $_order_invoice_postal_address = null, $_order_invoice_postal_code = null, $_order_invoice_province = null, $_order_invoice_registry_data = null, $_order_invoice_town = null, $_order_logo_base_name = null, $_order_logo_file_size = null, $_order_logo_mime_type = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\BrandCollection[]';
        $request = $this->getBrandCollectionRequest($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $currency, $currency2, $currency_exists, $default_timezone, $default_timezone2, $fax_notification_template, $fax_notification_template2, $fax_notification_template_exists, $id_exact, $invoice_country, $invoice_country_end, $invoice_country_exact, $invoice_country_partial, $invoice_country_start, $invoice_nif, $invoice_nif_end, $invoice_nif_exact, $invoice_nif_partial, $invoice_nif_start, $invoice_postal_address, $invoice_postal_address_end, $invoice_postal_address_exact, $invoice_postal_address_partial, $invoice_postal_address_start, $invoice_postal_code, $invoice_postal_code_end, $invoice_postal_code_exact, $invoice_postal_code_partial, $invoice_postal_code_start, $invoice_province, $invoice_province_end, $invoice_province_exact, $invoice_province_partial, $invoice_province_start, $invoice_registry_data, $invoice_registry_data_end, $invoice_registry_data_exact, $invoice_registry_data_exists, $invoice_registry_data_partial, $invoice_registry_data_start, $invoice_town, $invoice_town_end, $invoice_town_exact, $invoice_town_partial, $invoice_town_start, $invoice_notification_template, $invoice_notification_template2, $invoice_notification_template_exists, $language, $language2, $language_exists, $logo_base_name, $logo_base_name_end, $logo_base_name_exact, $logo_base_name_exists, $logo_base_name_partial, $logo_base_name_start, $logo_file_size, $logo_file_size_between, $logo_file_size_exists, $logo_file_size_gt, $logo_file_size_gte, $logo_file_size_lt, $logo_file_size_lte, $logo_mime_type, $logo_mime_type_end, $logo_mime_type_exact, $logo_mime_type_exists, $logo_mime_type_partial, $logo_mime_type_start, $max_daily_usage_notification_template, $max_daily_usage_notification_template2, $max_daily_usage_notification_template_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $voicemail_notification_template, $voicemail_notification_template2, $voicemail_notification_template_exists, $_order_id, $_order_invoice_country, $_order_invoice_nif, $_order_invoice_postal_address, $_order_invoice_postal_code, $_order_invoice_province, $_order_invoice_registry_data, $_order_invoice_town, $_order_logo_base_name, $_order_logo_file_size, $_order_logo_mime_type, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandCollection'
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $default_timezone (optional)
     * @param  string $default_timezone2 (optional)
     * @param  string $fax_notification_template (optional)
     * @param  string $fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_country (optional)
     * @param  string $invoice_country_end (optional)
     * @param  string $invoice_country_exact (optional)
     * @param  string $invoice_country_partial (optional)
     * @param  string $invoice_country_start (optional)
     * @param  string $invoice_nif (optional)
     * @param  string $invoice_nif_end (optional)
     * @param  string $invoice_nif_exact (optional)
     * @param  string $invoice_nif_partial (optional)
     * @param  string $invoice_nif_start (optional)
     * @param  string $invoice_postal_address (optional)
     * @param  string $invoice_postal_address_end (optional)
     * @param  string $invoice_postal_address_exact (optional)
     * @param  string $invoice_postal_address_partial (optional)
     * @param  string $invoice_postal_address_start (optional)
     * @param  string $invoice_postal_code (optional)
     * @param  string $invoice_postal_code_end (optional)
     * @param  string $invoice_postal_code_exact (optional)
     * @param  string $invoice_postal_code_partial (optional)
     * @param  string $invoice_postal_code_start (optional)
     * @param  string $invoice_province (optional)
     * @param  string $invoice_province_end (optional)
     * @param  string $invoice_province_exact (optional)
     * @param  string $invoice_province_partial (optional)
     * @param  string $invoice_province_start (optional)
     * @param  string $invoice_registry_data (optional)
     * @param  string $invoice_registry_data_end (optional)
     * @param  string $invoice_registry_data_exact (optional)
     * @param  bool $invoice_registry_data_exists (optional)
     * @param  string $invoice_registry_data_partial (optional)
     * @param  string $invoice_registry_data_start (optional)
     * @param  string $invoice_town (optional)
     * @param  string $invoice_town_end (optional)
     * @param  string $invoice_town_exact (optional)
     * @param  string $invoice_town_partial (optional)
     * @param  string $invoice_town_start (optional)
     * @param  string $invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $logo_base_name (optional)
     * @param  string $logo_base_name_end (optional)
     * @param  string $logo_base_name_exact (optional)
     * @param  bool $logo_base_name_exists (optional)
     * @param  string $logo_base_name_partial (optional)
     * @param  string $logo_base_name_start (optional)
     * @param  int $logo_file_size (optional)
     * @param  string $logo_file_size_between (optional)
     * @param  bool $logo_file_size_exists (optional)
     * @param  string $logo_file_size_gt (optional)
     * @param  string $logo_file_size_gte (optional)
     * @param  string $logo_file_size_lt (optional)
     * @param  string $logo_file_size_lte (optional)
     * @param  string $logo_mime_type (optional)
     * @param  string $logo_mime_type_end (optional)
     * @param  string $logo_mime_type_exact (optional)
     * @param  bool $logo_mime_type_exists (optional)
     * @param  string $logo_mime_type_partial (optional)
     * @param  string $logo_mime_type_start (optional)
     * @param  string $max_daily_usage_notification_template (optional)
     * @param  string $max_daily_usage_notification_template2 (optional)
     * @param  bool $max_daily_usage_notification_template_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_invoice_country (optional)
     * @param  string $_order_invoice_nif (optional)
     * @param  string $_order_invoice_postal_address (optional)
     * @param  string $_order_invoice_postal_code (optional)
     * @param  string $_order_invoice_province (optional)
     * @param  string $_order_invoice_registry_data (optional)
     * @param  string $_order_invoice_town (optional)
     * @param  string $_order_logo_base_name (optional)
     * @param  string $_order_logo_file_size (optional)
     * @param  string $_order_logo_mime_type (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBrandCollectionRequest($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_country = null, $invoice_country_end = null, $invoice_country_exact = null, $invoice_country_partial = null, $invoice_country_start = null, $invoice_nif = null, $invoice_nif_end = null, $invoice_nif_exact = null, $invoice_nif_partial = null, $invoice_nif_start = null, $invoice_postal_address = null, $invoice_postal_address_end = null, $invoice_postal_address_exact = null, $invoice_postal_address_partial = null, $invoice_postal_address_start = null, $invoice_postal_code = null, $invoice_postal_code_end = null, $invoice_postal_code_exact = null, $invoice_postal_code_partial = null, $invoice_postal_code_start = null, $invoice_province = null, $invoice_province_end = null, $invoice_province_exact = null, $invoice_province_partial = null, $invoice_province_start = null, $invoice_registry_data = null, $invoice_registry_data_end = null, $invoice_registry_data_exact = null, $invoice_registry_data_exists = null, $invoice_registry_data_partial = null, $invoice_registry_data_start = null, $invoice_town = null, $invoice_town_end = null, $invoice_town_exact = null, $invoice_town_partial = null, $invoice_town_start = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $logo_base_name = null, $logo_base_name_end = null, $logo_base_name_exact = null, $logo_base_name_exists = null, $logo_base_name_partial = null, $logo_base_name_start = null, $logo_file_size = null, $logo_file_size_between = null, $logo_file_size_exists = null, $logo_file_size_gt = null, $logo_file_size_gte = null, $logo_file_size_lt = null, $logo_file_size_lte = null, $logo_mime_type = null, $logo_mime_type_end = null, $logo_mime_type_exact = null, $logo_mime_type_exists = null, $logo_mime_type_partial = null, $logo_mime_type_start = null, $max_daily_usage_notification_template = null, $max_daily_usage_notification_template2 = null, $max_daily_usage_notification_template_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_invoice_country = null, $_order_invoice_nif = null, $_order_invoice_postal_address = null, $_order_invoice_postal_code = null, $_order_invoice_province = null, $_order_invoice_registry_data = null, $_order_invoice_town = null, $_order_logo_base_name = null, $_order_logo_file_size = null, $_order_logo_mime_type = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($call_csv_notification_template !== null) {
            $queryParams['callCsvNotificationTemplate'] = ObjectSerializer::toQueryValue($call_csv_notification_template);
        }
        // query params
        if ($call_csv_notification_template2 !== null) {
            $queryParams['callCsvNotificationTemplate[]'] = ObjectSerializer::toQueryValue($call_csv_notification_template2);
        }
        // query params
        if ($call_csv_notification_template_exists !== null) {
            $queryParams['callCsvNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($call_csv_notification_template_exists);
        }
        // query params
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency);
        }
        // query params
        if ($currency2 !== null) {
            $queryParams['currency[]'] = ObjectSerializer::toQueryValue($currency2);
        }
        // query params
        if ($currency_exists !== null) {
            $queryParams['currency[exists]'] = ObjectSerializer::toQueryValue($currency_exists);
        }
        // query params
        if ($default_timezone !== null) {
            $queryParams['defaultTimezone'] = ObjectSerializer::toQueryValue($default_timezone);
        }
        // query params
        if ($default_timezone2 !== null) {
            $queryParams['defaultTimezone[]'] = ObjectSerializer::toQueryValue($default_timezone2);
        }
        // query params
        if ($fax_notification_template !== null) {
            $queryParams['faxNotificationTemplate'] = ObjectSerializer::toQueryValue($fax_notification_template);
        }
        // query params
        if ($fax_notification_template2 !== null) {
            $queryParams['faxNotificationTemplate[]'] = ObjectSerializer::toQueryValue($fax_notification_template2);
        }
        // query params
        if ($fax_notification_template_exists !== null) {
            $queryParams['faxNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($fax_notification_template_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($invoice_country !== null) {
            $queryParams['invoice.country'] = ObjectSerializer::toQueryValue($invoice_country);
        }
        // query params
        if ($invoice_country_end !== null) {
            $queryParams['invoice.country[end]'] = ObjectSerializer::toQueryValue($invoice_country_end);
        }
        // query params
        if ($invoice_country_exact !== null) {
            $queryParams['invoice.country[exact]'] = ObjectSerializer::toQueryValue($invoice_country_exact);
        }
        // query params
        if ($invoice_country_partial !== null) {
            $queryParams['invoice.country[partial]'] = ObjectSerializer::toQueryValue($invoice_country_partial);
        }
        // query params
        if ($invoice_country_start !== null) {
            $queryParams['invoice.country[start]'] = ObjectSerializer::toQueryValue($invoice_country_start);
        }
        // query params
        if ($invoice_nif !== null) {
            $queryParams['invoice.nif'] = ObjectSerializer::toQueryValue($invoice_nif);
        }
        // query params
        if ($invoice_nif_end !== null) {
            $queryParams['invoice.nif[end]'] = ObjectSerializer::toQueryValue($invoice_nif_end);
        }
        // query params
        if ($invoice_nif_exact !== null) {
            $queryParams['invoice.nif[exact]'] = ObjectSerializer::toQueryValue($invoice_nif_exact);
        }
        // query params
        if ($invoice_nif_partial !== null) {
            $queryParams['invoice.nif[partial]'] = ObjectSerializer::toQueryValue($invoice_nif_partial);
        }
        // query params
        if ($invoice_nif_start !== null) {
            $queryParams['invoice.nif[start]'] = ObjectSerializer::toQueryValue($invoice_nif_start);
        }
        // query params
        if ($invoice_postal_address !== null) {
            $queryParams['invoice.postalAddress'] = ObjectSerializer::toQueryValue($invoice_postal_address);
        }
        // query params
        if ($invoice_postal_address_end !== null) {
            $queryParams['invoice.postalAddress[end]'] = ObjectSerializer::toQueryValue($invoice_postal_address_end);
        }
        // query params
        if ($invoice_postal_address_exact !== null) {
            $queryParams['invoice.postalAddress[exact]'] = ObjectSerializer::toQueryValue($invoice_postal_address_exact);
        }
        // query params
        if ($invoice_postal_address_partial !== null) {
            $queryParams['invoice.postalAddress[partial]'] = ObjectSerializer::toQueryValue($invoice_postal_address_partial);
        }
        // query params
        if ($invoice_postal_address_start !== null) {
            $queryParams['invoice.postalAddress[start]'] = ObjectSerializer::toQueryValue($invoice_postal_address_start);
        }
        // query params
        if ($invoice_postal_code !== null) {
            $queryParams['invoice.postalCode'] = ObjectSerializer::toQueryValue($invoice_postal_code);
        }
        // query params
        if ($invoice_postal_code_end !== null) {
            $queryParams['invoice.postalCode[end]'] = ObjectSerializer::toQueryValue($invoice_postal_code_end);
        }
        // query params
        if ($invoice_postal_code_exact !== null) {
            $queryParams['invoice.postalCode[exact]'] = ObjectSerializer::toQueryValue($invoice_postal_code_exact);
        }
        // query params
        if ($invoice_postal_code_partial !== null) {
            $queryParams['invoice.postalCode[partial]'] = ObjectSerializer::toQueryValue($invoice_postal_code_partial);
        }
        // query params
        if ($invoice_postal_code_start !== null) {
            $queryParams['invoice.postalCode[start]'] = ObjectSerializer::toQueryValue($invoice_postal_code_start);
        }
        // query params
        if ($invoice_province !== null) {
            $queryParams['invoice.province'] = ObjectSerializer::toQueryValue($invoice_province);
        }
        // query params
        if ($invoice_province_end !== null) {
            $queryParams['invoice.province[end]'] = ObjectSerializer::toQueryValue($invoice_province_end);
        }
        // query params
        if ($invoice_province_exact !== null) {
            $queryParams['invoice.province[exact]'] = ObjectSerializer::toQueryValue($invoice_province_exact);
        }
        // query params
        if ($invoice_province_partial !== null) {
            $queryParams['invoice.province[partial]'] = ObjectSerializer::toQueryValue($invoice_province_partial);
        }
        // query params
        if ($invoice_province_start !== null) {
            $queryParams['invoice.province[start]'] = ObjectSerializer::toQueryValue($invoice_province_start);
        }
        // query params
        if ($invoice_registry_data !== null) {
            $queryParams['invoice.registryData'] = ObjectSerializer::toQueryValue($invoice_registry_data);
        }
        // query params
        if ($invoice_registry_data_end !== null) {
            $queryParams['invoice.registryData[end]'] = ObjectSerializer::toQueryValue($invoice_registry_data_end);
        }
        // query params
        if ($invoice_registry_data_exact !== null) {
            $queryParams['invoice.registryData[exact]'] = ObjectSerializer::toQueryValue($invoice_registry_data_exact);
        }
        // query params
        if ($invoice_registry_data_exists !== null) {
            $queryParams['invoice.registryData[exists]'] = ObjectSerializer::toQueryValue($invoice_registry_data_exists);
        }
        // query params
        if ($invoice_registry_data_partial !== null) {
            $queryParams['invoice.registryData[partial]'] = ObjectSerializer::toQueryValue($invoice_registry_data_partial);
        }
        // query params
        if ($invoice_registry_data_start !== null) {
            $queryParams['invoice.registryData[start]'] = ObjectSerializer::toQueryValue($invoice_registry_data_start);
        }
        // query params
        if ($invoice_town !== null) {
            $queryParams['invoice.town'] = ObjectSerializer::toQueryValue($invoice_town);
        }
        // query params
        if ($invoice_town_end !== null) {
            $queryParams['invoice.town[end]'] = ObjectSerializer::toQueryValue($invoice_town_end);
        }
        // query params
        if ($invoice_town_exact !== null) {
            $queryParams['invoice.town[exact]'] = ObjectSerializer::toQueryValue($invoice_town_exact);
        }
        // query params
        if ($invoice_town_partial !== null) {
            $queryParams['invoice.town[partial]'] = ObjectSerializer::toQueryValue($invoice_town_partial);
        }
        // query params
        if ($invoice_town_start !== null) {
            $queryParams['invoice.town[start]'] = ObjectSerializer::toQueryValue($invoice_town_start);
        }
        // query params
        if ($invoice_notification_template !== null) {
            $queryParams['invoiceNotificationTemplate'] = ObjectSerializer::toQueryValue($invoice_notification_template);
        }
        // query params
        if ($invoice_notification_template2 !== null) {
            $queryParams['invoiceNotificationTemplate[]'] = ObjectSerializer::toQueryValue($invoice_notification_template2);
        }
        // query params
        if ($invoice_notification_template_exists !== null) {
            $queryParams['invoiceNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($invoice_notification_template_exists);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($language2 !== null) {
            $queryParams['language[]'] = ObjectSerializer::toQueryValue($language2);
        }
        // query params
        if ($language_exists !== null) {
            $queryParams['language[exists]'] = ObjectSerializer::toQueryValue($language_exists);
        }
        // query params
        if ($logo_base_name !== null) {
            $queryParams['logo.baseName'] = ObjectSerializer::toQueryValue($logo_base_name);
        }
        // query params
        if ($logo_base_name_end !== null) {
            $queryParams['logo.baseName[end]'] = ObjectSerializer::toQueryValue($logo_base_name_end);
        }
        // query params
        if ($logo_base_name_exact !== null) {
            $queryParams['logo.baseName[exact]'] = ObjectSerializer::toQueryValue($logo_base_name_exact);
        }
        // query params
        if ($logo_base_name_exists !== null) {
            $queryParams['logo.baseName[exists]'] = ObjectSerializer::toQueryValue($logo_base_name_exists);
        }
        // query params
        if ($logo_base_name_partial !== null) {
            $queryParams['logo.baseName[partial]'] = ObjectSerializer::toQueryValue($logo_base_name_partial);
        }
        // query params
        if ($logo_base_name_start !== null) {
            $queryParams['logo.baseName[start]'] = ObjectSerializer::toQueryValue($logo_base_name_start);
        }
        // query params
        if ($logo_file_size !== null) {
            $queryParams['logo.fileSize'] = ObjectSerializer::toQueryValue($logo_file_size);
        }
        // query params
        if ($logo_file_size_between !== null) {
            $queryParams['logo.fileSize[between]'] = ObjectSerializer::toQueryValue($logo_file_size_between);
        }
        // query params
        if ($logo_file_size_exists !== null) {
            $queryParams['logo.fileSize[exists]'] = ObjectSerializer::toQueryValue($logo_file_size_exists);
        }
        // query params
        if ($logo_file_size_gt !== null) {
            $queryParams['logo.fileSize[gt]'] = ObjectSerializer::toQueryValue($logo_file_size_gt);
        }
        // query params
        if ($logo_file_size_gte !== null) {
            $queryParams['logo.fileSize[gte]'] = ObjectSerializer::toQueryValue($logo_file_size_gte);
        }
        // query params
        if ($logo_file_size_lt !== null) {
            $queryParams['logo.fileSize[lt]'] = ObjectSerializer::toQueryValue($logo_file_size_lt);
        }
        // query params
        if ($logo_file_size_lte !== null) {
            $queryParams['logo.fileSize[lte]'] = ObjectSerializer::toQueryValue($logo_file_size_lte);
        }
        // query params
        if ($logo_mime_type !== null) {
            $queryParams['logo.mimeType'] = ObjectSerializer::toQueryValue($logo_mime_type);
        }
        // query params
        if ($logo_mime_type_end !== null) {
            $queryParams['logo.mimeType[end]'] = ObjectSerializer::toQueryValue($logo_mime_type_end);
        }
        // query params
        if ($logo_mime_type_exact !== null) {
            $queryParams['logo.mimeType[exact]'] = ObjectSerializer::toQueryValue($logo_mime_type_exact);
        }
        // query params
        if ($logo_mime_type_exists !== null) {
            $queryParams['logo.mimeType[exists]'] = ObjectSerializer::toQueryValue($logo_mime_type_exists);
        }
        // query params
        if ($logo_mime_type_partial !== null) {
            $queryParams['logo.mimeType[partial]'] = ObjectSerializer::toQueryValue($logo_mime_type_partial);
        }
        // query params
        if ($logo_mime_type_start !== null) {
            $queryParams['logo.mimeType[start]'] = ObjectSerializer::toQueryValue($logo_mime_type_start);
        }
        // query params
        if ($max_daily_usage_notification_template !== null) {
            $queryParams['maxDailyUsageNotificationTemplate'] = ObjectSerializer::toQueryValue($max_daily_usage_notification_template);
        }
        // query params
        if ($max_daily_usage_notification_template2 !== null) {
            $queryParams['maxDailyUsageNotificationTemplate[]'] = ObjectSerializer::toQueryValue($max_daily_usage_notification_template2);
        }
        // query params
        if ($max_daily_usage_notification_template_exists !== null) {
            $queryParams['maxDailyUsageNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($max_daily_usage_notification_template_exists);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($voicemail_notification_template !== null) {
            $queryParams['voicemailNotificationTemplate'] = ObjectSerializer::toQueryValue($voicemail_notification_template);
        }
        // query params
        if ($voicemail_notification_template2 !== null) {
            $queryParams['voicemailNotificationTemplate[]'] = ObjectSerializer::toQueryValue($voicemail_notification_template2);
        }
        // query params
        if ($voicemail_notification_template_exists !== null) {
            $queryParams['voicemailNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($voicemail_notification_template_exists);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_invoice_country !== null) {
            $queryParams['_order[invoice.country]'] = ObjectSerializer::toQueryValue($_order_invoice_country);
        }
        // query params
        if ($_order_invoice_nif !== null) {
            $queryParams['_order[invoice.nif]'] = ObjectSerializer::toQueryValue($_order_invoice_nif);
        }
        // query params
        if ($_order_invoice_postal_address !== null) {
            $queryParams['_order[invoice.postalAddress]'] = ObjectSerializer::toQueryValue($_order_invoice_postal_address);
        }
        // query params
        if ($_order_invoice_postal_code !== null) {
            $queryParams['_order[invoice.postalCode]'] = ObjectSerializer::toQueryValue($_order_invoice_postal_code);
        }
        // query params
        if ($_order_invoice_province !== null) {
            $queryParams['_order[invoice.province]'] = ObjectSerializer::toQueryValue($_order_invoice_province);
        }
        // query params
        if ($_order_invoice_registry_data !== null) {
            $queryParams['_order[invoice.registryData]'] = ObjectSerializer::toQueryValue($_order_invoice_registry_data);
        }
        // query params
        if ($_order_invoice_town !== null) {
            $queryParams['_order[invoice.town]'] = ObjectSerializer::toQueryValue($_order_invoice_town);
        }
        // query params
        if ($_order_logo_base_name !== null) {
            $queryParams['_order[logo.baseName]'] = ObjectSerializer::toQueryValue($_order_logo_base_name);
        }
        // query params
        if ($_order_logo_file_size !== null) {
            $queryParams['_order[logo.fileSize]'] = ObjectSerializer::toQueryValue($_order_logo_file_size);
        }
        // query params
        if ($_order_logo_mime_type !== null) {
            $queryParams['_order[logo.mimeType]'] = ObjectSerializer::toQueryValue($_order_logo_mime_type);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBrandItem
     *
     * Retrieves a Brand resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BrandDetailed
     */
    public function getBrandItem($id)
    {
        list($response) = $this->getBrandItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getBrandItemWithHttpInfo
     *
     * Retrieves a Brand resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BrandDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\BrandDetailed';
        $request = $this->getBrandItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BrandDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBrandItemAsync
     *
     * Retrieves a Brand resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandItemAsync($id)
    {
        return $this->getBrandItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandItemAsyncWithHttpInfo
     *
     * Retrieves a Brand resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\BrandDetailed';
        $request = $this->getBrandItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBrandItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBrandItem'
            );
        }

        $resourcePath = '/brands/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBrandServiceCollection
     *
     * Retrieves the collection of BrandService resources.
     *
     * @param  string $code code (optional)
     * @param  string $code_end code_end (optional)
     * @param  string $code_exact code_exact (optional)
     * @param  string $code_partial code_partial (optional)
     * @param  string $code_start code_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $service service (optional)
     * @param  string $service2 service2 (optional)
     * @param  string $_order_code _order_code (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BrandServiceCollection[]
     */
    public function getBrandServiceCollection($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $id_exact = null, $service = null, $service2 = null, $_order_code = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getBrandServiceCollectionWithHttpInfo($code, $code_end, $code_exact, $code_partial, $code_start, $id_exact, $service, $service2, $_order_code, $_order_id, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getBrandServiceCollectionWithHttpInfo
     *
     * Retrieves the collection of BrandService resources.
     *
     * @param  string $code (optional)
     * @param  string $code_end (optional)
     * @param  string $code_exact (optional)
     * @param  string $code_partial (optional)
     * @param  string $code_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $service (optional)
     * @param  string $service2 (optional)
     * @param  string $_order_code (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BrandServiceCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandServiceCollectionWithHttpInfo($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $id_exact = null, $service = null, $service2 = null, $_order_code = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\BrandServiceCollection[]';
        $request = $this->getBrandServiceCollectionRequest($code, $code_end, $code_exact, $code_partial, $code_start, $id_exact, $service, $service2, $_order_code, $_order_id, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BrandServiceCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBrandServiceCollectionAsync
     *
     * Retrieves the collection of BrandService resources.
     *
     * @param  string $code (optional)
     * @param  string $code_end (optional)
     * @param  string $code_exact (optional)
     * @param  string $code_partial (optional)
     * @param  string $code_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $service (optional)
     * @param  string $service2 (optional)
     * @param  string $_order_code (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandServiceCollectionAsync($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $id_exact = null, $service = null, $service2 = null, $_order_code = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getBrandServiceCollectionAsyncWithHttpInfo($code, $code_end, $code_exact, $code_partial, $code_start, $id_exact, $service, $service2, $_order_code, $_order_id, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandServiceCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of BrandService resources.
     *
     * @param  string $code (optional)
     * @param  string $code_end (optional)
     * @param  string $code_exact (optional)
     * @param  string $code_partial (optional)
     * @param  string $code_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $service (optional)
     * @param  string $service2 (optional)
     * @param  string $_order_code (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandServiceCollectionAsyncWithHttpInfo($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $id_exact = null, $service = null, $service2 = null, $_order_code = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\BrandServiceCollection[]';
        $request = $this->getBrandServiceCollectionRequest($code, $code_end, $code_exact, $code_partial, $code_start, $id_exact, $service, $service2, $_order_code, $_order_id, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandServiceCollection'
     *
     * @param  string $code (optional)
     * @param  string $code_end (optional)
     * @param  string $code_exact (optional)
     * @param  string $code_partial (optional)
     * @param  string $code_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $service (optional)
     * @param  string $service2 (optional)
     * @param  string $_order_code (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBrandServiceCollectionRequest($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $id_exact = null, $service = null, $service2 = null, $_order_code = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/brand_services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code);
        }
        // query params
        if ($code_end !== null) {
            $queryParams['code[end]'] = ObjectSerializer::toQueryValue($code_end);
        }
        // query params
        if ($code_exact !== null) {
            $queryParams['code[exact]'] = ObjectSerializer::toQueryValue($code_exact);
        }
        // query params
        if ($code_partial !== null) {
            $queryParams['code[partial]'] = ObjectSerializer::toQueryValue($code_partial);
        }
        // query params
        if ($code_start !== null) {
            $queryParams['code[start]'] = ObjectSerializer::toQueryValue($code_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($service !== null) {
            $queryParams['service'] = ObjectSerializer::toQueryValue($service);
        }
        // query params
        if ($service2 !== null) {
            $queryParams['service[]'] = ObjectSerializer::toQueryValue($service2);
        }
        // query params
        if ($_order_code !== null) {
            $queryParams['_order[code]'] = ObjectSerializer::toQueryValue($_order_code);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBrandServiceItem
     *
     * Retrieves a BrandService resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BrandServiceDetailed
     */
    public function getBrandServiceItem($id)
    {
        list($response) = $this->getBrandServiceItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getBrandServiceItemWithHttpInfo
     *
     * Retrieves a BrandService resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BrandServiceDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandServiceItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\BrandServiceDetailed';
        $request = $this->getBrandServiceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BrandServiceDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBrandServiceItemAsync
     *
     * Retrieves a BrandService resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandServiceItemAsync($id)
    {
        return $this->getBrandServiceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandServiceItemAsyncWithHttpInfo
     *
     * Retrieves a BrandService resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandServiceItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\BrandServiceDetailed';
        $request = $this->getBrandServiceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandServiceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBrandServiceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBrandServiceItem'
            );
        }

        $resourcePath = '/brand_services/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCallCsvReportCollection
     *
     * Retrieves the collection of CallCsvReport resources.
     *
     * @param  string $brand brand (optional)
     * @param  string $brand2 brand2 (optional)
     * @param  bool $brand_exists brand_exists (optional)
     * @param  string $call_csv_scheduler call_csv_scheduler (optional)
     * @param  string $call_csv_scheduler2 call_csv_scheduler2 (optional)
     * @param  bool $call_csv_scheduler_exists call_csv_scheduler_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $in_date in_date (optional)
     * @param  string $in_date_after in_date_after (optional)
     * @param  string $in_date_before in_date_before (optional)
     * @param  string $in_date_start in_date_start (optional)
     * @param  string $in_date_strictly_after in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before in_date_strictly_before (optional)
     * @param  string $out_date out_date (optional)
     * @param  string $out_date_after out_date_after (optional)
     * @param  string $out_date_before out_date_before (optional)
     * @param  string $out_date_start out_date_start (optional)
     * @param  string $out_date_strictly_after out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before out_date_strictly_before (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_in_date _order_in_date (optional)
     * @param  string $_order_out_date _order_out_date (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CallCsvReportCollection[]
     */
    public function getCallCsvReportCollection($brand = null, $brand2 = null, $brand_exists = null, $call_csv_scheduler = null, $call_csv_scheduler2 = null, $call_csv_scheduler_exists = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $_order_id = null, $_order_in_date = null, $_order_out_date = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        list($response) = $this->getCallCsvReportCollectionWithHttpInfo($brand, $brand2, $brand_exists, $call_csv_scheduler, $call_csv_scheduler2, $call_csv_scheduler_exists, $id_exact, $in_date, $in_date_after, $in_date_before, $in_date_start, $in_date_strictly_after, $in_date_strictly_before, $out_date, $out_date_after, $out_date_before, $out_date_start, $out_date_strictly_after, $out_date_strictly_before, $_order_id, $_order_in_date, $_order_out_date, $_items_per_page, $_page, $_properties, $_timezone);
        return $response;
    }

    /**
     * Operation getCallCsvReportCollectionWithHttpInfo
     *
     * Retrieves the collection of CallCsvReport resources.
     *
     * @param  string $brand (optional)
     * @param  string $brand2 (optional)
     * @param  bool $brand_exists (optional)
     * @param  string $call_csv_scheduler (optional)
     * @param  string $call_csv_scheduler2 (optional)
     * @param  bool $call_csv_scheduler_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $in_date (optional)
     * @param  string $in_date_after (optional)
     * @param  string $in_date_before (optional)
     * @param  string $in_date_start (optional)
     * @param  string $in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before (optional)
     * @param  string $out_date (optional)
     * @param  string $out_date_after (optional)
     * @param  string $out_date_before (optional)
     * @param  string $out_date_start (optional)
     * @param  string $out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_in_date (optional)
     * @param  string $_order_out_date (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CallCsvReportCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCallCsvReportCollectionWithHttpInfo($brand = null, $brand2 = null, $brand_exists = null, $call_csv_scheduler = null, $call_csv_scheduler2 = null, $call_csv_scheduler_exists = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $_order_id = null, $_order_in_date = null, $_order_out_date = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvReportCollection[]';
        $request = $this->getCallCsvReportCollectionRequest($brand, $brand2, $brand_exists, $call_csv_scheduler, $call_csv_scheduler2, $call_csv_scheduler_exists, $id_exact, $in_date, $in_date_after, $in_date_before, $in_date_start, $in_date_strictly_after, $in_date_strictly_before, $out_date, $out_date_after, $out_date_before, $out_date_start, $out_date_strictly_after, $out_date_strictly_before, $_order_id, $_order_in_date, $_order_out_date, $_items_per_page, $_page, $_properties, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CallCsvReportCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCallCsvReportCollectionAsync
     *
     * Retrieves the collection of CallCsvReport resources.
     *
     * @param  string $brand (optional)
     * @param  string $brand2 (optional)
     * @param  bool $brand_exists (optional)
     * @param  string $call_csv_scheduler (optional)
     * @param  string $call_csv_scheduler2 (optional)
     * @param  bool $call_csv_scheduler_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $in_date (optional)
     * @param  string $in_date_after (optional)
     * @param  string $in_date_before (optional)
     * @param  string $in_date_start (optional)
     * @param  string $in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before (optional)
     * @param  string $out_date (optional)
     * @param  string $out_date_after (optional)
     * @param  string $out_date_before (optional)
     * @param  string $out_date_start (optional)
     * @param  string $out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_in_date (optional)
     * @param  string $_order_out_date (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallCsvReportCollectionAsync($brand = null, $brand2 = null, $brand_exists = null, $call_csv_scheduler = null, $call_csv_scheduler2 = null, $call_csv_scheduler_exists = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $_order_id = null, $_order_in_date = null, $_order_out_date = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        return $this->getCallCsvReportCollectionAsyncWithHttpInfo($brand, $brand2, $brand_exists, $call_csv_scheduler, $call_csv_scheduler2, $call_csv_scheduler_exists, $id_exact, $in_date, $in_date_after, $in_date_before, $in_date_start, $in_date_strictly_after, $in_date_strictly_before, $out_date, $out_date_after, $out_date_before, $out_date_start, $out_date_strictly_after, $out_date_strictly_before, $_order_id, $_order_in_date, $_order_out_date, $_items_per_page, $_page, $_properties, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCallCsvReportCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of CallCsvReport resources.
     *
     * @param  string $brand (optional)
     * @param  string $brand2 (optional)
     * @param  bool $brand_exists (optional)
     * @param  string $call_csv_scheduler (optional)
     * @param  string $call_csv_scheduler2 (optional)
     * @param  bool $call_csv_scheduler_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $in_date (optional)
     * @param  string $in_date_after (optional)
     * @param  string $in_date_before (optional)
     * @param  string $in_date_start (optional)
     * @param  string $in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before (optional)
     * @param  string $out_date (optional)
     * @param  string $out_date_after (optional)
     * @param  string $out_date_before (optional)
     * @param  string $out_date_start (optional)
     * @param  string $out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_in_date (optional)
     * @param  string $_order_out_date (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallCsvReportCollectionAsyncWithHttpInfo($brand = null, $brand2 = null, $brand_exists = null, $call_csv_scheduler = null, $call_csv_scheduler2 = null, $call_csv_scheduler_exists = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $_order_id = null, $_order_in_date = null, $_order_out_date = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvReportCollection[]';
        $request = $this->getCallCsvReportCollectionRequest($brand, $brand2, $brand_exists, $call_csv_scheduler, $call_csv_scheduler2, $call_csv_scheduler_exists, $id_exact, $in_date, $in_date_after, $in_date_before, $in_date_start, $in_date_strictly_after, $in_date_strictly_before, $out_date, $out_date_after, $out_date_before, $out_date_start, $out_date_strictly_after, $out_date_strictly_before, $_order_id, $_order_in_date, $_order_out_date, $_items_per_page, $_page, $_properties, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCallCsvReportCollection'
     *
     * @param  string $brand (optional)
     * @param  string $brand2 (optional)
     * @param  bool $brand_exists (optional)
     * @param  string $call_csv_scheduler (optional)
     * @param  string $call_csv_scheduler2 (optional)
     * @param  bool $call_csv_scheduler_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $in_date (optional)
     * @param  string $in_date_after (optional)
     * @param  string $in_date_before (optional)
     * @param  string $in_date_start (optional)
     * @param  string $in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before (optional)
     * @param  string $out_date (optional)
     * @param  string $out_date_after (optional)
     * @param  string $out_date_before (optional)
     * @param  string $out_date_start (optional)
     * @param  string $out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_in_date (optional)
     * @param  string $_order_out_date (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCallCsvReportCollectionRequest($brand = null, $brand2 = null, $brand_exists = null, $call_csv_scheduler = null, $call_csv_scheduler2 = null, $call_csv_scheduler_exists = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $_order_id = null, $_order_in_date = null, $_order_out_date = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {

        $resourcePath = '/call_csv_reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($brand !== null) {
            $queryParams['brand'] = ObjectSerializer::toQueryValue($brand);
        }
        // query params
        if ($brand2 !== null) {
            $queryParams['brand[]'] = ObjectSerializer::toQueryValue($brand2);
        }
        // query params
        if ($brand_exists !== null) {
            $queryParams['brand[exists]'] = ObjectSerializer::toQueryValue($brand_exists);
        }
        // query params
        if ($call_csv_scheduler !== null) {
            $queryParams['callCsvScheduler'] = ObjectSerializer::toQueryValue($call_csv_scheduler);
        }
        // query params
        if ($call_csv_scheduler2 !== null) {
            $queryParams['callCsvScheduler[]'] = ObjectSerializer::toQueryValue($call_csv_scheduler2);
        }
        // query params
        if ($call_csv_scheduler_exists !== null) {
            $queryParams['callCsvScheduler[exists]'] = ObjectSerializer::toQueryValue($call_csv_scheduler_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($in_date !== null) {
            $queryParams['inDate'] = ObjectSerializer::toQueryValue($in_date);
        }
        // query params
        if ($in_date_after !== null) {
            $queryParams['inDate[after]'] = ObjectSerializer::toQueryValue($in_date_after);
        }
        // query params
        if ($in_date_before !== null) {
            $queryParams['inDate[before]'] = ObjectSerializer::toQueryValue($in_date_before);
        }
        // query params
        if ($in_date_start !== null) {
            $queryParams['inDate[start]'] = ObjectSerializer::toQueryValue($in_date_start);
        }
        // query params
        if ($in_date_strictly_after !== null) {
            $queryParams['inDate[strictly_after]'] = ObjectSerializer::toQueryValue($in_date_strictly_after);
        }
        // query params
        if ($in_date_strictly_before !== null) {
            $queryParams['inDate[strictly_before]'] = ObjectSerializer::toQueryValue($in_date_strictly_before);
        }
        // query params
        if ($out_date !== null) {
            $queryParams['outDate'] = ObjectSerializer::toQueryValue($out_date);
        }
        // query params
        if ($out_date_after !== null) {
            $queryParams['outDate[after]'] = ObjectSerializer::toQueryValue($out_date_after);
        }
        // query params
        if ($out_date_before !== null) {
            $queryParams['outDate[before]'] = ObjectSerializer::toQueryValue($out_date_before);
        }
        // query params
        if ($out_date_start !== null) {
            $queryParams['outDate[start]'] = ObjectSerializer::toQueryValue($out_date_start);
        }
        // query params
        if ($out_date_strictly_after !== null) {
            $queryParams['outDate[strictly_after]'] = ObjectSerializer::toQueryValue($out_date_strictly_after);
        }
        // query params
        if ($out_date_strictly_before !== null) {
            $queryParams['outDate[strictly_before]'] = ObjectSerializer::toQueryValue($out_date_strictly_before);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_in_date !== null) {
            $queryParams['_order[inDate]'] = ObjectSerializer::toQueryValue($_order_in_date);
        }
        // query params
        if ($_order_out_date !== null) {
            $queryParams['_order[outDate]'] = ObjectSerializer::toQueryValue($_order_out_date);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCallCsvReportItem
     *
     * Retrieves a CallCsvReport resource.
     *
     * @param  string $id id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CallCsvReportDetailed
     */
    public function getCallCsvReportItem($id, $_timezone = null)
    {
        list($response) = $this->getCallCsvReportItemWithHttpInfo($id, $_timezone);
        return $response;
    }

    /**
     * Operation getCallCsvReportItemWithHttpInfo
     *
     * Retrieves a CallCsvReport resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CallCsvReportDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCallCsvReportItemWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvReportDetailed';
        $request = $this->getCallCsvReportItemRequest($id, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CallCsvReportDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCallCsvReportItemAsync
     *
     * Retrieves a CallCsvReport resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallCsvReportItemAsync($id, $_timezone = null)
    {
        return $this->getCallCsvReportItemAsyncWithHttpInfo($id, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCallCsvReportItemAsyncWithHttpInfo
     *
     * Retrieves a CallCsvReport resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallCsvReportItemAsyncWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvReportDetailed';
        $request = $this->getCallCsvReportItemRequest($id, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCallCsvReportItem'
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCallCsvReportItemRequest($id, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCallCsvReportItem'
            );
        }

        $resourcePath = '/call_csv_reports/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCallCsvSchedulerCollection
     *
     * Retrieves the collection of CallCsvScheduler resources.
     *
     * @param  string $call_csv_notification_template call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists call_csv_notification_template_exists (optional)
     * @param  string $call_direction call_direction (optional)
     * @param  string $call_direction_end call_direction_end (optional)
     * @param  string $call_direction_exact call_direction_exact (optional)
     * @param  bool $call_direction_exists call_direction_exists (optional)
     * @param  string $call_direction_partial call_direction_partial (optional)
     * @param  string $call_direction_start call_direction_start (optional)
     * @param  string $carrier carrier (optional)
     * @param  string $carrier2 carrier2 (optional)
     * @param  bool $carrier_exists carrier_exists (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  bool $company_exists company_exists (optional)
     * @param  string $ddi ddi (optional)
     * @param  string $ddi_provider ddi_provider (optional)
     * @param  string $ddi_provider2 ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists ddi_provider_exists (optional)
     * @param  string $ddi2 ddi2 (optional)
     * @param  bool $ddi_exists ddi_exists (optional)
     * @param  string $email email (optional)
     * @param  string $email_end email_end (optional)
     * @param  string $email_exact email_exact (optional)
     * @param  string $email_partial email_partial (optional)
     * @param  string $email_start email_start (optional)
     * @param  string $fax fax (optional)
     * @param  string $fax2 fax2 (optional)
     * @param  bool $fax_exists fax_exists (optional)
     * @param  int $frequency frequency (optional)
     * @param  string $frequency_between frequency_between (optional)
     * @param  string $frequency_gt frequency_gt (optional)
     * @param  string $frequency_gte frequency_gte (optional)
     * @param  string $frequency_lt frequency_lt (optional)
     * @param  string $frequency_lte frequency_lte (optional)
     * @param  string $friend friend (optional)
     * @param  string $friend2 friend2 (optional)
     * @param  bool $friend_exists friend_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $last_execution last_execution (optional)
     * @param  string $last_execution_error last_execution_error (optional)
     * @param  string $last_execution_error_end last_execution_error_end (optional)
     * @param  string $last_execution_error_exact last_execution_error_exact (optional)
     * @param  bool $last_execution_error_exists last_execution_error_exists (optional)
     * @param  string $last_execution_error_partial last_execution_error_partial (optional)
     * @param  string $last_execution_error_start last_execution_error_start (optional)
     * @param  string $last_execution_after last_execution_after (optional)
     * @param  string $last_execution_before last_execution_before (optional)
     * @param  bool $last_execution_exists last_execution_exists (optional)
     * @param  string $last_execution_start last_execution_start (optional)
     * @param  string $last_execution_strictly_after last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before last_execution_strictly_before (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $next_execution next_execution (optional)
     * @param  string $next_execution_after next_execution_after (optional)
     * @param  string $next_execution_before next_execution_before (optional)
     * @param  bool $next_execution_exists next_execution_exists (optional)
     * @param  string $next_execution_start next_execution_start (optional)
     * @param  string $next_execution_strictly_after next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before next_execution_strictly_before (optional)
     * @param  string $residential_device residential_device (optional)
     * @param  string $residential_device2 residential_device2 (optional)
     * @param  bool $residential_device_exists residential_device_exists (optional)
     * @param  string $retail_account retail_account (optional)
     * @param  string $retail_account2 retail_account2 (optional)
     * @param  bool $retail_account_exists retail_account_exists (optional)
     * @param  string $unit unit (optional)
     * @param  string $unit_end unit_end (optional)
     * @param  string $unit_exact unit_exact (optional)
     * @param  string $unit_partial unit_partial (optional)
     * @param  string $unit_start unit_start (optional)
     * @param  string $user user (optional)
     * @param  string $user2 user2 (optional)
     * @param  bool $user_exists user_exists (optional)
     * @param  string $_order_call_direction _order_call_direction (optional)
     * @param  string $_order_email _order_email (optional)
     * @param  string $_order_frequency _order_frequency (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_last_execution_error _order_last_execution_error (optional)
     * @param  string $_order_last_execution _order_last_execution (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_next_execution _order_next_execution (optional)
     * @param  string $_order_unit _order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CallCsvSchedulerCollection[]
     */
    public function getCallCsvSchedulerCollection($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $call_direction = null, $call_direction_end = null, $call_direction_exact = null, $call_direction_exists = null, $call_direction_partial = null, $call_direction_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $fax = null, $fax2 = null, $fax_exists = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $friend = null, $friend2 = null, $friend_exists = null, $id_exact = null, $last_execution = null, $last_execution_error = null, $last_execution_error_end = null, $last_execution_error_exact = null, $last_execution_error_exists = null, $last_execution_error_partial = null, $last_execution_error_start = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $residential_device = null, $residential_device2 = null, $residential_device_exists = null, $retail_account = null, $retail_account2 = null, $retail_account_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $user = null, $user2 = null, $user_exists = null, $_order_call_direction = null, $_order_email = null, $_order_frequency = null, $_order_id = null, $_order_last_execution_error = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        list($response) = $this->getCallCsvSchedulerCollectionWithHttpInfo($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $call_direction, $call_direction_end, $call_direction_exact, $call_direction_exists, $call_direction_partial, $call_direction_start, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi2, $ddi_exists, $email, $email_end, $email_exact, $email_partial, $email_start, $fax, $fax2, $fax_exists, $frequency, $frequency_between, $frequency_gt, $frequency_gte, $frequency_lt, $frequency_lte, $friend, $friend2, $friend_exists, $id_exact, $last_execution, $last_execution_error, $last_execution_error_end, $last_execution_error_exact, $last_execution_error_exists, $last_execution_error_partial, $last_execution_error_start, $last_execution_after, $last_execution_before, $last_execution_exists, $last_execution_start, $last_execution_strictly_after, $last_execution_strictly_before, $name, $name_end, $name_exact, $name_partial, $name_start, $next_execution, $next_execution_after, $next_execution_before, $next_execution_exists, $next_execution_start, $next_execution_strictly_after, $next_execution_strictly_before, $residential_device, $residential_device2, $residential_device_exists, $retail_account, $retail_account2, $retail_account_exists, $unit, $unit_end, $unit_exact, $unit_partial, $unit_start, $user, $user2, $user_exists, $_order_call_direction, $_order_email, $_order_frequency, $_order_id, $_order_last_execution_error, $_order_last_execution, $_order_name, $_order_next_execution, $_order_unit, $_items_per_page, $_page, $_properties, $_timezone);
        return $response;
    }

    /**
     * Operation getCallCsvSchedulerCollectionWithHttpInfo
     *
     * Retrieves the collection of CallCsvScheduler resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $call_direction (optional)
     * @param  string $call_direction_end (optional)
     * @param  string $call_direction_exact (optional)
     * @param  bool $call_direction_exists (optional)
     * @param  string $call_direction_partial (optional)
     * @param  string $call_direction_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi2 (optional)
     * @param  bool $ddi_exists (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  string $fax (optional)
     * @param  string $fax2 (optional)
     * @param  bool $fax_exists (optional)
     * @param  int $frequency (optional)
     * @param  string $frequency_between (optional)
     * @param  string $frequency_gt (optional)
     * @param  string $frequency_gte (optional)
     * @param  string $frequency_lt (optional)
     * @param  string $frequency_lte (optional)
     * @param  string $friend (optional)
     * @param  string $friend2 (optional)
     * @param  bool $friend_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $last_execution (optional)
     * @param  string $last_execution_error (optional)
     * @param  string $last_execution_error_end (optional)
     * @param  string $last_execution_error_exact (optional)
     * @param  bool $last_execution_error_exists (optional)
     * @param  string $last_execution_error_partial (optional)
     * @param  string $last_execution_error_start (optional)
     * @param  string $last_execution_after (optional)
     * @param  string $last_execution_before (optional)
     * @param  bool $last_execution_exists (optional)
     * @param  string $last_execution_start (optional)
     * @param  string $last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $next_execution (optional)
     * @param  string $next_execution_after (optional)
     * @param  string $next_execution_before (optional)
     * @param  bool $next_execution_exists (optional)
     * @param  string $next_execution_start (optional)
     * @param  string $next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before (optional)
     * @param  string $residential_device (optional)
     * @param  string $residential_device2 (optional)
     * @param  bool $residential_device_exists (optional)
     * @param  string $retail_account (optional)
     * @param  string $retail_account2 (optional)
     * @param  bool $retail_account_exists (optional)
     * @param  string $unit (optional)
     * @param  string $unit_end (optional)
     * @param  string $unit_exact (optional)
     * @param  string $unit_partial (optional)
     * @param  string $unit_start (optional)
     * @param  string $user (optional)
     * @param  string $user2 (optional)
     * @param  bool $user_exists (optional)
     * @param  string $_order_call_direction (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_frequency (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_last_execution_error (optional)
     * @param  string $_order_last_execution (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_next_execution (optional)
     * @param  string $_order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CallCsvSchedulerCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCallCsvSchedulerCollectionWithHttpInfo($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $call_direction = null, $call_direction_end = null, $call_direction_exact = null, $call_direction_exists = null, $call_direction_partial = null, $call_direction_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $fax = null, $fax2 = null, $fax_exists = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $friend = null, $friend2 = null, $friend_exists = null, $id_exact = null, $last_execution = null, $last_execution_error = null, $last_execution_error_end = null, $last_execution_error_exact = null, $last_execution_error_exists = null, $last_execution_error_partial = null, $last_execution_error_start = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $residential_device = null, $residential_device2 = null, $residential_device_exists = null, $retail_account = null, $retail_account2 = null, $retail_account_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $user = null, $user2 = null, $user_exists = null, $_order_call_direction = null, $_order_email = null, $_order_frequency = null, $_order_id = null, $_order_last_execution_error = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvSchedulerCollection[]';
        $request = $this->getCallCsvSchedulerCollectionRequest($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $call_direction, $call_direction_end, $call_direction_exact, $call_direction_exists, $call_direction_partial, $call_direction_start, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi2, $ddi_exists, $email, $email_end, $email_exact, $email_partial, $email_start, $fax, $fax2, $fax_exists, $frequency, $frequency_between, $frequency_gt, $frequency_gte, $frequency_lt, $frequency_lte, $friend, $friend2, $friend_exists, $id_exact, $last_execution, $last_execution_error, $last_execution_error_end, $last_execution_error_exact, $last_execution_error_exists, $last_execution_error_partial, $last_execution_error_start, $last_execution_after, $last_execution_before, $last_execution_exists, $last_execution_start, $last_execution_strictly_after, $last_execution_strictly_before, $name, $name_end, $name_exact, $name_partial, $name_start, $next_execution, $next_execution_after, $next_execution_before, $next_execution_exists, $next_execution_start, $next_execution_strictly_after, $next_execution_strictly_before, $residential_device, $residential_device2, $residential_device_exists, $retail_account, $retail_account2, $retail_account_exists, $unit, $unit_end, $unit_exact, $unit_partial, $unit_start, $user, $user2, $user_exists, $_order_call_direction, $_order_email, $_order_frequency, $_order_id, $_order_last_execution_error, $_order_last_execution, $_order_name, $_order_next_execution, $_order_unit, $_items_per_page, $_page, $_properties, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CallCsvSchedulerCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCallCsvSchedulerCollectionAsync
     *
     * Retrieves the collection of CallCsvScheduler resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $call_direction (optional)
     * @param  string $call_direction_end (optional)
     * @param  string $call_direction_exact (optional)
     * @param  bool $call_direction_exists (optional)
     * @param  string $call_direction_partial (optional)
     * @param  string $call_direction_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi2 (optional)
     * @param  bool $ddi_exists (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  string $fax (optional)
     * @param  string $fax2 (optional)
     * @param  bool $fax_exists (optional)
     * @param  int $frequency (optional)
     * @param  string $frequency_between (optional)
     * @param  string $frequency_gt (optional)
     * @param  string $frequency_gte (optional)
     * @param  string $frequency_lt (optional)
     * @param  string $frequency_lte (optional)
     * @param  string $friend (optional)
     * @param  string $friend2 (optional)
     * @param  bool $friend_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $last_execution (optional)
     * @param  string $last_execution_error (optional)
     * @param  string $last_execution_error_end (optional)
     * @param  string $last_execution_error_exact (optional)
     * @param  bool $last_execution_error_exists (optional)
     * @param  string $last_execution_error_partial (optional)
     * @param  string $last_execution_error_start (optional)
     * @param  string $last_execution_after (optional)
     * @param  string $last_execution_before (optional)
     * @param  bool $last_execution_exists (optional)
     * @param  string $last_execution_start (optional)
     * @param  string $last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $next_execution (optional)
     * @param  string $next_execution_after (optional)
     * @param  string $next_execution_before (optional)
     * @param  bool $next_execution_exists (optional)
     * @param  string $next_execution_start (optional)
     * @param  string $next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before (optional)
     * @param  string $residential_device (optional)
     * @param  string $residential_device2 (optional)
     * @param  bool $residential_device_exists (optional)
     * @param  string $retail_account (optional)
     * @param  string $retail_account2 (optional)
     * @param  bool $retail_account_exists (optional)
     * @param  string $unit (optional)
     * @param  string $unit_end (optional)
     * @param  string $unit_exact (optional)
     * @param  string $unit_partial (optional)
     * @param  string $unit_start (optional)
     * @param  string $user (optional)
     * @param  string $user2 (optional)
     * @param  bool $user_exists (optional)
     * @param  string $_order_call_direction (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_frequency (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_last_execution_error (optional)
     * @param  string $_order_last_execution (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_next_execution (optional)
     * @param  string $_order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallCsvSchedulerCollectionAsync($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $call_direction = null, $call_direction_end = null, $call_direction_exact = null, $call_direction_exists = null, $call_direction_partial = null, $call_direction_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $fax = null, $fax2 = null, $fax_exists = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $friend = null, $friend2 = null, $friend_exists = null, $id_exact = null, $last_execution = null, $last_execution_error = null, $last_execution_error_end = null, $last_execution_error_exact = null, $last_execution_error_exists = null, $last_execution_error_partial = null, $last_execution_error_start = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $residential_device = null, $residential_device2 = null, $residential_device_exists = null, $retail_account = null, $retail_account2 = null, $retail_account_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $user = null, $user2 = null, $user_exists = null, $_order_call_direction = null, $_order_email = null, $_order_frequency = null, $_order_id = null, $_order_last_execution_error = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        return $this->getCallCsvSchedulerCollectionAsyncWithHttpInfo($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $call_direction, $call_direction_end, $call_direction_exact, $call_direction_exists, $call_direction_partial, $call_direction_start, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi2, $ddi_exists, $email, $email_end, $email_exact, $email_partial, $email_start, $fax, $fax2, $fax_exists, $frequency, $frequency_between, $frequency_gt, $frequency_gte, $frequency_lt, $frequency_lte, $friend, $friend2, $friend_exists, $id_exact, $last_execution, $last_execution_error, $last_execution_error_end, $last_execution_error_exact, $last_execution_error_exists, $last_execution_error_partial, $last_execution_error_start, $last_execution_after, $last_execution_before, $last_execution_exists, $last_execution_start, $last_execution_strictly_after, $last_execution_strictly_before, $name, $name_end, $name_exact, $name_partial, $name_start, $next_execution, $next_execution_after, $next_execution_before, $next_execution_exists, $next_execution_start, $next_execution_strictly_after, $next_execution_strictly_before, $residential_device, $residential_device2, $residential_device_exists, $retail_account, $retail_account2, $retail_account_exists, $unit, $unit_end, $unit_exact, $unit_partial, $unit_start, $user, $user2, $user_exists, $_order_call_direction, $_order_email, $_order_frequency, $_order_id, $_order_last_execution_error, $_order_last_execution, $_order_name, $_order_next_execution, $_order_unit, $_items_per_page, $_page, $_properties, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCallCsvSchedulerCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of CallCsvScheduler resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $call_direction (optional)
     * @param  string $call_direction_end (optional)
     * @param  string $call_direction_exact (optional)
     * @param  bool $call_direction_exists (optional)
     * @param  string $call_direction_partial (optional)
     * @param  string $call_direction_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi2 (optional)
     * @param  bool $ddi_exists (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  string $fax (optional)
     * @param  string $fax2 (optional)
     * @param  bool $fax_exists (optional)
     * @param  int $frequency (optional)
     * @param  string $frequency_between (optional)
     * @param  string $frequency_gt (optional)
     * @param  string $frequency_gte (optional)
     * @param  string $frequency_lt (optional)
     * @param  string $frequency_lte (optional)
     * @param  string $friend (optional)
     * @param  string $friend2 (optional)
     * @param  bool $friend_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $last_execution (optional)
     * @param  string $last_execution_error (optional)
     * @param  string $last_execution_error_end (optional)
     * @param  string $last_execution_error_exact (optional)
     * @param  bool $last_execution_error_exists (optional)
     * @param  string $last_execution_error_partial (optional)
     * @param  string $last_execution_error_start (optional)
     * @param  string $last_execution_after (optional)
     * @param  string $last_execution_before (optional)
     * @param  bool $last_execution_exists (optional)
     * @param  string $last_execution_start (optional)
     * @param  string $last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $next_execution (optional)
     * @param  string $next_execution_after (optional)
     * @param  string $next_execution_before (optional)
     * @param  bool $next_execution_exists (optional)
     * @param  string $next_execution_start (optional)
     * @param  string $next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before (optional)
     * @param  string $residential_device (optional)
     * @param  string $residential_device2 (optional)
     * @param  bool $residential_device_exists (optional)
     * @param  string $retail_account (optional)
     * @param  string $retail_account2 (optional)
     * @param  bool $retail_account_exists (optional)
     * @param  string $unit (optional)
     * @param  string $unit_end (optional)
     * @param  string $unit_exact (optional)
     * @param  string $unit_partial (optional)
     * @param  string $unit_start (optional)
     * @param  string $user (optional)
     * @param  string $user2 (optional)
     * @param  bool $user_exists (optional)
     * @param  string $_order_call_direction (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_frequency (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_last_execution_error (optional)
     * @param  string $_order_last_execution (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_next_execution (optional)
     * @param  string $_order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallCsvSchedulerCollectionAsyncWithHttpInfo($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $call_direction = null, $call_direction_end = null, $call_direction_exact = null, $call_direction_exists = null, $call_direction_partial = null, $call_direction_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $fax = null, $fax2 = null, $fax_exists = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $friend = null, $friend2 = null, $friend_exists = null, $id_exact = null, $last_execution = null, $last_execution_error = null, $last_execution_error_end = null, $last_execution_error_exact = null, $last_execution_error_exists = null, $last_execution_error_partial = null, $last_execution_error_start = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $residential_device = null, $residential_device2 = null, $residential_device_exists = null, $retail_account = null, $retail_account2 = null, $retail_account_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $user = null, $user2 = null, $user_exists = null, $_order_call_direction = null, $_order_email = null, $_order_frequency = null, $_order_id = null, $_order_last_execution_error = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvSchedulerCollection[]';
        $request = $this->getCallCsvSchedulerCollectionRequest($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $call_direction, $call_direction_end, $call_direction_exact, $call_direction_exists, $call_direction_partial, $call_direction_start, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi2, $ddi_exists, $email, $email_end, $email_exact, $email_partial, $email_start, $fax, $fax2, $fax_exists, $frequency, $frequency_between, $frequency_gt, $frequency_gte, $frequency_lt, $frequency_lte, $friend, $friend2, $friend_exists, $id_exact, $last_execution, $last_execution_error, $last_execution_error_end, $last_execution_error_exact, $last_execution_error_exists, $last_execution_error_partial, $last_execution_error_start, $last_execution_after, $last_execution_before, $last_execution_exists, $last_execution_start, $last_execution_strictly_after, $last_execution_strictly_before, $name, $name_end, $name_exact, $name_partial, $name_start, $next_execution, $next_execution_after, $next_execution_before, $next_execution_exists, $next_execution_start, $next_execution_strictly_after, $next_execution_strictly_before, $residential_device, $residential_device2, $residential_device_exists, $retail_account, $retail_account2, $retail_account_exists, $unit, $unit_end, $unit_exact, $unit_partial, $unit_start, $user, $user2, $user_exists, $_order_call_direction, $_order_email, $_order_frequency, $_order_id, $_order_last_execution_error, $_order_last_execution, $_order_name, $_order_next_execution, $_order_unit, $_items_per_page, $_page, $_properties, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCallCsvSchedulerCollection'
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $call_direction (optional)
     * @param  string $call_direction_end (optional)
     * @param  string $call_direction_exact (optional)
     * @param  bool $call_direction_exists (optional)
     * @param  string $call_direction_partial (optional)
     * @param  string $call_direction_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi2 (optional)
     * @param  bool $ddi_exists (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  string $fax (optional)
     * @param  string $fax2 (optional)
     * @param  bool $fax_exists (optional)
     * @param  int $frequency (optional)
     * @param  string $frequency_between (optional)
     * @param  string $frequency_gt (optional)
     * @param  string $frequency_gte (optional)
     * @param  string $frequency_lt (optional)
     * @param  string $frequency_lte (optional)
     * @param  string $friend (optional)
     * @param  string $friend2 (optional)
     * @param  bool $friend_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $last_execution (optional)
     * @param  string $last_execution_error (optional)
     * @param  string $last_execution_error_end (optional)
     * @param  string $last_execution_error_exact (optional)
     * @param  bool $last_execution_error_exists (optional)
     * @param  string $last_execution_error_partial (optional)
     * @param  string $last_execution_error_start (optional)
     * @param  string $last_execution_after (optional)
     * @param  string $last_execution_before (optional)
     * @param  bool $last_execution_exists (optional)
     * @param  string $last_execution_start (optional)
     * @param  string $last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $next_execution (optional)
     * @param  string $next_execution_after (optional)
     * @param  string $next_execution_before (optional)
     * @param  bool $next_execution_exists (optional)
     * @param  string $next_execution_start (optional)
     * @param  string $next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before (optional)
     * @param  string $residential_device (optional)
     * @param  string $residential_device2 (optional)
     * @param  bool $residential_device_exists (optional)
     * @param  string $retail_account (optional)
     * @param  string $retail_account2 (optional)
     * @param  bool $retail_account_exists (optional)
     * @param  string $unit (optional)
     * @param  string $unit_end (optional)
     * @param  string $unit_exact (optional)
     * @param  string $unit_partial (optional)
     * @param  string $unit_start (optional)
     * @param  string $user (optional)
     * @param  string $user2 (optional)
     * @param  bool $user_exists (optional)
     * @param  string $_order_call_direction (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_frequency (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_last_execution_error (optional)
     * @param  string $_order_last_execution (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_next_execution (optional)
     * @param  string $_order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCallCsvSchedulerCollectionRequest($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $call_direction = null, $call_direction_end = null, $call_direction_exact = null, $call_direction_exists = null, $call_direction_partial = null, $call_direction_start = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi2 = null, $ddi_exists = null, $email = null, $email_end = null, $email_exact = null, $email_partial = null, $email_start = null, $fax = null, $fax2 = null, $fax_exists = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $friend = null, $friend2 = null, $friend_exists = null, $id_exact = null, $last_execution = null, $last_execution_error = null, $last_execution_error_end = null, $last_execution_error_exact = null, $last_execution_error_exists = null, $last_execution_error_partial = null, $last_execution_error_start = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $residential_device = null, $residential_device2 = null, $residential_device_exists = null, $retail_account = null, $retail_account2 = null, $retail_account_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $user = null, $user2 = null, $user_exists = null, $_order_call_direction = null, $_order_email = null, $_order_frequency = null, $_order_id = null, $_order_last_execution_error = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {

        $resourcePath = '/call_csv_schedulers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($call_csv_notification_template !== null) {
            $queryParams['callCsvNotificationTemplate'] = ObjectSerializer::toQueryValue($call_csv_notification_template);
        }
        // query params
        if ($call_csv_notification_template2 !== null) {
            $queryParams['callCsvNotificationTemplate[]'] = ObjectSerializer::toQueryValue($call_csv_notification_template2);
        }
        // query params
        if ($call_csv_notification_template_exists !== null) {
            $queryParams['callCsvNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($call_csv_notification_template_exists);
        }
        // query params
        if ($call_direction !== null) {
            $queryParams['callDirection'] = ObjectSerializer::toQueryValue($call_direction);
        }
        // query params
        if ($call_direction_end !== null) {
            $queryParams['callDirection[end]'] = ObjectSerializer::toQueryValue($call_direction_end);
        }
        // query params
        if ($call_direction_exact !== null) {
            $queryParams['callDirection[exact]'] = ObjectSerializer::toQueryValue($call_direction_exact);
        }
        // query params
        if ($call_direction_exists !== null) {
            $queryParams['callDirection[exists]'] = ObjectSerializer::toQueryValue($call_direction_exists);
        }
        // query params
        if ($call_direction_partial !== null) {
            $queryParams['callDirection[partial]'] = ObjectSerializer::toQueryValue($call_direction_partial);
        }
        // query params
        if ($call_direction_start !== null) {
            $queryParams['callDirection[start]'] = ObjectSerializer::toQueryValue($call_direction_start);
        }
        // query params
        if ($carrier !== null) {
            $queryParams['carrier'] = ObjectSerializer::toQueryValue($carrier);
        }
        // query params
        if ($carrier2 !== null) {
            $queryParams['carrier[]'] = ObjectSerializer::toQueryValue($carrier2);
        }
        // query params
        if ($carrier_exists !== null) {
            $queryParams['carrier[exists]'] = ObjectSerializer::toQueryValue($carrier_exists);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($company_exists !== null) {
            $queryParams['company[exists]'] = ObjectSerializer::toQueryValue($company_exists);
        }
        // query params
        if ($ddi !== null) {
            $queryParams['ddi'] = ObjectSerializer::toQueryValue($ddi);
        }
        // query params
        if ($ddi_provider !== null) {
            $queryParams['ddiProvider'] = ObjectSerializer::toQueryValue($ddi_provider);
        }
        // query params
        if ($ddi_provider2 !== null) {
            $queryParams['ddiProvider[]'] = ObjectSerializer::toQueryValue($ddi_provider2);
        }
        // query params
        if ($ddi_provider_exists !== null) {
            $queryParams['ddiProvider[exists]'] = ObjectSerializer::toQueryValue($ddi_provider_exists);
        }
        // query params
        if ($ddi2 !== null) {
            $queryParams['ddi[]'] = ObjectSerializer::toQueryValue($ddi2);
        }
        // query params
        if ($ddi_exists !== null) {
            $queryParams['ddi[exists]'] = ObjectSerializer::toQueryValue($ddi_exists);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($email_end !== null) {
            $queryParams['email[end]'] = ObjectSerializer::toQueryValue($email_end);
        }
        // query params
        if ($email_exact !== null) {
            $queryParams['email[exact]'] = ObjectSerializer::toQueryValue($email_exact);
        }
        // query params
        if ($email_partial !== null) {
            $queryParams['email[partial]'] = ObjectSerializer::toQueryValue($email_partial);
        }
        // query params
        if ($email_start !== null) {
            $queryParams['email[start]'] = ObjectSerializer::toQueryValue($email_start);
        }
        // query params
        if ($fax !== null) {
            $queryParams['fax'] = ObjectSerializer::toQueryValue($fax);
        }
        // query params
        if ($fax2 !== null) {
            $queryParams['fax[]'] = ObjectSerializer::toQueryValue($fax2);
        }
        // query params
        if ($fax_exists !== null) {
            $queryParams['fax[exists]'] = ObjectSerializer::toQueryValue($fax_exists);
        }
        // query params
        if ($frequency !== null) {
            $queryParams['frequency'] = ObjectSerializer::toQueryValue($frequency);
        }
        // query params
        if ($frequency_between !== null) {
            $queryParams['frequency[between]'] = ObjectSerializer::toQueryValue($frequency_between);
        }
        // query params
        if ($frequency_gt !== null) {
            $queryParams['frequency[gt]'] = ObjectSerializer::toQueryValue($frequency_gt);
        }
        // query params
        if ($frequency_gte !== null) {
            $queryParams['frequency[gte]'] = ObjectSerializer::toQueryValue($frequency_gte);
        }
        // query params
        if ($frequency_lt !== null) {
            $queryParams['frequency[lt]'] = ObjectSerializer::toQueryValue($frequency_lt);
        }
        // query params
        if ($frequency_lte !== null) {
            $queryParams['frequency[lte]'] = ObjectSerializer::toQueryValue($frequency_lte);
        }
        // query params
        if ($friend !== null) {
            $queryParams['friend'] = ObjectSerializer::toQueryValue($friend);
        }
        // query params
        if ($friend2 !== null) {
            $queryParams['friend[]'] = ObjectSerializer::toQueryValue($friend2);
        }
        // query params
        if ($friend_exists !== null) {
            $queryParams['friend[exists]'] = ObjectSerializer::toQueryValue($friend_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($last_execution !== null) {
            $queryParams['lastExecution'] = ObjectSerializer::toQueryValue($last_execution);
        }
        // query params
        if ($last_execution_error !== null) {
            $queryParams['lastExecutionError'] = ObjectSerializer::toQueryValue($last_execution_error);
        }
        // query params
        if ($last_execution_error_end !== null) {
            $queryParams['lastExecutionError[end]'] = ObjectSerializer::toQueryValue($last_execution_error_end);
        }
        // query params
        if ($last_execution_error_exact !== null) {
            $queryParams['lastExecutionError[exact]'] = ObjectSerializer::toQueryValue($last_execution_error_exact);
        }
        // query params
        if ($last_execution_error_exists !== null) {
            $queryParams['lastExecutionError[exists]'] = ObjectSerializer::toQueryValue($last_execution_error_exists);
        }
        // query params
        if ($last_execution_error_partial !== null) {
            $queryParams['lastExecutionError[partial]'] = ObjectSerializer::toQueryValue($last_execution_error_partial);
        }
        // query params
        if ($last_execution_error_start !== null) {
            $queryParams['lastExecutionError[start]'] = ObjectSerializer::toQueryValue($last_execution_error_start);
        }
        // query params
        if ($last_execution_after !== null) {
            $queryParams['lastExecution[after]'] = ObjectSerializer::toQueryValue($last_execution_after);
        }
        // query params
        if ($last_execution_before !== null) {
            $queryParams['lastExecution[before]'] = ObjectSerializer::toQueryValue($last_execution_before);
        }
        // query params
        if ($last_execution_exists !== null) {
            $queryParams['lastExecution[exists]'] = ObjectSerializer::toQueryValue($last_execution_exists);
        }
        // query params
        if ($last_execution_start !== null) {
            $queryParams['lastExecution[start]'] = ObjectSerializer::toQueryValue($last_execution_start);
        }
        // query params
        if ($last_execution_strictly_after !== null) {
            $queryParams['lastExecution[strictly_after]'] = ObjectSerializer::toQueryValue($last_execution_strictly_after);
        }
        // query params
        if ($last_execution_strictly_before !== null) {
            $queryParams['lastExecution[strictly_before]'] = ObjectSerializer::toQueryValue($last_execution_strictly_before);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($next_execution !== null) {
            $queryParams['nextExecution'] = ObjectSerializer::toQueryValue($next_execution);
        }
        // query params
        if ($next_execution_after !== null) {
            $queryParams['nextExecution[after]'] = ObjectSerializer::toQueryValue($next_execution_after);
        }
        // query params
        if ($next_execution_before !== null) {
            $queryParams['nextExecution[before]'] = ObjectSerializer::toQueryValue($next_execution_before);
        }
        // query params
        if ($next_execution_exists !== null) {
            $queryParams['nextExecution[exists]'] = ObjectSerializer::toQueryValue($next_execution_exists);
        }
        // query params
        if ($next_execution_start !== null) {
            $queryParams['nextExecution[start]'] = ObjectSerializer::toQueryValue($next_execution_start);
        }
        // query params
        if ($next_execution_strictly_after !== null) {
            $queryParams['nextExecution[strictly_after]'] = ObjectSerializer::toQueryValue($next_execution_strictly_after);
        }
        // query params
        if ($next_execution_strictly_before !== null) {
            $queryParams['nextExecution[strictly_before]'] = ObjectSerializer::toQueryValue($next_execution_strictly_before);
        }
        // query params
        if ($residential_device !== null) {
            $queryParams['residentialDevice'] = ObjectSerializer::toQueryValue($residential_device);
        }
        // query params
        if ($residential_device2 !== null) {
            $queryParams['residentialDevice[]'] = ObjectSerializer::toQueryValue($residential_device2);
        }
        // query params
        if ($residential_device_exists !== null) {
            $queryParams['residentialDevice[exists]'] = ObjectSerializer::toQueryValue($residential_device_exists);
        }
        // query params
        if ($retail_account !== null) {
            $queryParams['retailAccount'] = ObjectSerializer::toQueryValue($retail_account);
        }
        // query params
        if ($retail_account2 !== null) {
            $queryParams['retailAccount[]'] = ObjectSerializer::toQueryValue($retail_account2);
        }
        // query params
        if ($retail_account_exists !== null) {
            $queryParams['retailAccount[exists]'] = ObjectSerializer::toQueryValue($retail_account_exists);
        }
        // query params
        if ($unit !== null) {
            $queryParams['unit'] = ObjectSerializer::toQueryValue($unit);
        }
        // query params
        if ($unit_end !== null) {
            $queryParams['unit[end]'] = ObjectSerializer::toQueryValue($unit_end);
        }
        // query params
        if ($unit_exact !== null) {
            $queryParams['unit[exact]'] = ObjectSerializer::toQueryValue($unit_exact);
        }
        // query params
        if ($unit_partial !== null) {
            $queryParams['unit[partial]'] = ObjectSerializer::toQueryValue($unit_partial);
        }
        // query params
        if ($unit_start !== null) {
            $queryParams['unit[start]'] = ObjectSerializer::toQueryValue($unit_start);
        }
        // query params
        if ($user !== null) {
            $queryParams['user'] = ObjectSerializer::toQueryValue($user);
        }
        // query params
        if ($user2 !== null) {
            $queryParams['user[]'] = ObjectSerializer::toQueryValue($user2);
        }
        // query params
        if ($user_exists !== null) {
            $queryParams['user[exists]'] = ObjectSerializer::toQueryValue($user_exists);
        }
        // query params
        if ($_order_call_direction !== null) {
            $queryParams['_order[callDirection]'] = ObjectSerializer::toQueryValue($_order_call_direction);
        }
        // query params
        if ($_order_email !== null) {
            $queryParams['_order[email]'] = ObjectSerializer::toQueryValue($_order_email);
        }
        // query params
        if ($_order_frequency !== null) {
            $queryParams['_order[frequency]'] = ObjectSerializer::toQueryValue($_order_frequency);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_last_execution_error !== null) {
            $queryParams['_order[lastExecutionError]'] = ObjectSerializer::toQueryValue($_order_last_execution_error);
        }
        // query params
        if ($_order_last_execution !== null) {
            $queryParams['_order[lastExecution]'] = ObjectSerializer::toQueryValue($_order_last_execution);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_next_execution !== null) {
            $queryParams['_order[nextExecution]'] = ObjectSerializer::toQueryValue($_order_next_execution);
        }
        // query params
        if ($_order_unit !== null) {
            $queryParams['_order[unit]'] = ObjectSerializer::toQueryValue($_order_unit);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCallCsvSchedulerItem
     *
     * Retrieves a CallCsvScheduler resource.
     *
     * @param  string $id id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CallCsvSchedulerDetailed
     */
    public function getCallCsvSchedulerItem($id, $_timezone = null)
    {
        list($response) = $this->getCallCsvSchedulerItemWithHttpInfo($id, $_timezone);
        return $response;
    }

    /**
     * Operation getCallCsvSchedulerItemWithHttpInfo
     *
     * Retrieves a CallCsvScheduler resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CallCsvSchedulerDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCallCsvSchedulerItemWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvSchedulerDetailed';
        $request = $this->getCallCsvSchedulerItemRequest($id, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CallCsvSchedulerDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCallCsvSchedulerItemAsync
     *
     * Retrieves a CallCsvScheduler resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallCsvSchedulerItemAsync($id, $_timezone = null)
    {
        return $this->getCallCsvSchedulerItemAsyncWithHttpInfo($id, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCallCsvSchedulerItemAsyncWithHttpInfo
     *
     * Retrieves a CallCsvScheduler resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallCsvSchedulerItemAsyncWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvSchedulerDetailed';
        $request = $this->getCallCsvSchedulerItemRequest($id, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCallCsvSchedulerItem'
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCallCsvSchedulerItemRequest($id, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCallCsvSchedulerItem'
            );
        }

        $resourcePath = '/call_csv_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarrierCollection
     *
     * Retrieves the collection of Carrier resources.
     *
     * @param  string $currency currency (optional)
     * @param  string $currency2 currency2 (optional)
     * @param  bool $currency_exists currency_exists (optional)
     * @param  string $description description (optional)
     * @param  string $description_end description_end (optional)
     * @param  string $description_exact description_exact (optional)
     * @param  string $description_partial description_partial (optional)
     * @param  string $description_start description_start (optional)
     * @param  bool $externally_rated externally_rated (optional)
     * @param  bool $externally_rated_exists externally_rated_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $proxy_trunk proxy_trunk (optional)
     * @param  string $proxy_trunk2 proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $_order_description _order_description (optional)
     * @param  string $_order_externally_rated _order_externally_rated (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CarrierCollection[]
     */
    public function getCarrierCollection($currency = null, $currency2 = null, $currency_exists = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $externally_rated = null, $externally_rated_exists = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_externally_rated = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getCarrierCollectionWithHttpInfo($currency, $currency2, $currency_exists, $description, $description_end, $description_exact, $description_partial, $description_start, $externally_rated, $externally_rated_exists, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $proxy_trunk, $proxy_trunk2, $proxy_trunk_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_externally_rated, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getCarrierCollectionWithHttpInfo
     *
     * Retrieves the collection of Carrier resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  bool $externally_rated (optional)
     * @param  bool $externally_rated_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $proxy_trunk (optional)
     * @param  string $proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_externally_rated (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CarrierCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCarrierCollectionWithHttpInfo($currency = null, $currency2 = null, $currency_exists = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $externally_rated = null, $externally_rated_exists = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_externally_rated = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\CarrierCollection[]';
        $request = $this->getCarrierCollectionRequest($currency, $currency2, $currency_exists, $description, $description_end, $description_exact, $description_partial, $description_start, $externally_rated, $externally_rated_exists, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $proxy_trunk, $proxy_trunk2, $proxy_trunk_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_externally_rated, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CarrierCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCarrierCollectionAsync
     *
     * Retrieves the collection of Carrier resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  bool $externally_rated (optional)
     * @param  bool $externally_rated_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $proxy_trunk (optional)
     * @param  string $proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_externally_rated (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierCollectionAsync($currency = null, $currency2 = null, $currency_exists = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $externally_rated = null, $externally_rated_exists = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_externally_rated = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getCarrierCollectionAsyncWithHttpInfo($currency, $currency2, $currency_exists, $description, $description_end, $description_exact, $description_partial, $description_start, $externally_rated, $externally_rated_exists, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $proxy_trunk, $proxy_trunk2, $proxy_trunk_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_externally_rated, $_order_id, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarrierCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Carrier resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  bool $externally_rated (optional)
     * @param  bool $externally_rated_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $proxy_trunk (optional)
     * @param  string $proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_externally_rated (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierCollectionAsyncWithHttpInfo($currency = null, $currency2 = null, $currency_exists = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $externally_rated = null, $externally_rated_exists = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_externally_rated = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\CarrierCollection[]';
        $request = $this->getCarrierCollectionRequest($currency, $currency2, $currency_exists, $description, $description_end, $description_exact, $description_partial, $description_start, $externally_rated, $externally_rated_exists, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $proxy_trunk, $proxy_trunk2, $proxy_trunk_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_externally_rated, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarrierCollection'
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  bool $externally_rated (optional)
     * @param  bool $externally_rated_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $proxy_trunk (optional)
     * @param  string $proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_externally_rated (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarrierCollectionRequest($currency = null, $currency2 = null, $currency_exists = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $externally_rated = null, $externally_rated_exists = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_externally_rated = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/carriers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency);
        }
        // query params
        if ($currency2 !== null) {
            $queryParams['currency[]'] = ObjectSerializer::toQueryValue($currency2);
        }
        // query params
        if ($currency_exists !== null) {
            $queryParams['currency[exists]'] = ObjectSerializer::toQueryValue($currency_exists);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($description_end !== null) {
            $queryParams['description[end]'] = ObjectSerializer::toQueryValue($description_end);
        }
        // query params
        if ($description_exact !== null) {
            $queryParams['description[exact]'] = ObjectSerializer::toQueryValue($description_exact);
        }
        // query params
        if ($description_partial !== null) {
            $queryParams['description[partial]'] = ObjectSerializer::toQueryValue($description_partial);
        }
        // query params
        if ($description_start !== null) {
            $queryParams['description[start]'] = ObjectSerializer::toQueryValue($description_start);
        }
        // query params
        if ($externally_rated !== null) {
            $queryParams['externallyRated'] = ObjectSerializer::toQueryValue($externally_rated);
        }
        // query params
        if ($externally_rated_exists !== null) {
            $queryParams['externallyRated[exists]'] = ObjectSerializer::toQueryValue($externally_rated_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($proxy_trunk !== null) {
            $queryParams['proxyTrunk'] = ObjectSerializer::toQueryValue($proxy_trunk);
        }
        // query params
        if ($proxy_trunk2 !== null) {
            $queryParams['proxyTrunk[]'] = ObjectSerializer::toQueryValue($proxy_trunk2);
        }
        // query params
        if ($proxy_trunk_exists !== null) {
            $queryParams['proxyTrunk[exists]'] = ObjectSerializer::toQueryValue($proxy_trunk_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($_order_description !== null) {
            $queryParams['_order[description]'] = ObjectSerializer::toQueryValue($_order_description);
        }
        // query params
        if ($_order_externally_rated !== null) {
            $queryParams['_order[externallyRated]'] = ObjectSerializer::toQueryValue($_order_externally_rated);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarrierItem
     *
     * Retrieves a Carrier resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CarrierDetailed
     */
    public function getCarrierItem($id)
    {
        list($response) = $this->getCarrierItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getCarrierItemWithHttpInfo
     *
     * Retrieves a Carrier resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CarrierDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCarrierItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CarrierDetailed';
        $request = $this->getCarrierItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CarrierDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCarrierItemAsync
     *
     * Retrieves a Carrier resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierItemAsync($id)
    {
        return $this->getCarrierItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarrierItemAsyncWithHttpInfo
     *
     * Retrieves a Carrier resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CarrierDetailed';
        $request = $this->getCarrierItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarrierItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarrierItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCarrierItem'
            );
        }

        $resourcePath = '/carriers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarrierServerCollection
     *
     * Retrieves the collection of CarrierServer resources.
     *
     * @param  string $auth_needed auth_needed (optional)
     * @param  string $auth_needed_end auth_needed_end (optional)
     * @param  string $auth_needed_exact auth_needed_exact (optional)
     * @param  string $auth_needed_partial auth_needed_partial (optional)
     * @param  string $auth_needed_start auth_needed_start (optional)
     * @param  string $carrier carrier (optional)
     * @param  string $carrier2 carrier2 (optional)
     * @param  string $hostname hostname (optional)
     * @param  string $hostname_end hostname_end (optional)
     * @param  string $hostname_exact hostname_exact (optional)
     * @param  bool $hostname_exists hostname_exists (optional)
     * @param  string $hostname_partial hostname_partial (optional)
     * @param  string $hostname_start hostname_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $ip ip (optional)
     * @param  string $ip_end ip_end (optional)
     * @param  string $ip_exact ip_exact (optional)
     * @param  bool $ip_exists ip_exists (optional)
     * @param  string $ip_partial ip_partial (optional)
     * @param  string $ip_start ip_start (optional)
     * @param  string $sip_proxy sip_proxy (optional)
     * @param  string $sip_proxy_end sip_proxy_end (optional)
     * @param  string $sip_proxy_exact sip_proxy_exact (optional)
     * @param  bool $sip_proxy_exists sip_proxy_exists (optional)
     * @param  string $sip_proxy_partial sip_proxy_partial (optional)
     * @param  string $sip_proxy_start sip_proxy_start (optional)
     * @param  string $_order_auth_needed _order_auth_needed (optional)
     * @param  string $_order_hostname _order_hostname (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_ip _order_ip (optional)
     * @param  string $_order_sip_proxy _order_sip_proxy (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CarrierServerCollection[]
     */
    public function getCarrierServerCollection($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $carrier = null, $carrier2 = null, $hostname = null, $hostname_end = null, $hostname_exact = null, $hostname_exists = null, $hostname_partial = null, $hostname_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $sip_proxy = null, $sip_proxy_end = null, $sip_proxy_exact = null, $sip_proxy_exists = null, $sip_proxy_partial = null, $sip_proxy_start = null, $_order_auth_needed = null, $_order_hostname = null, $_order_id = null, $_order_ip = null, $_order_sip_proxy = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getCarrierServerCollectionWithHttpInfo($auth_needed, $auth_needed_end, $auth_needed_exact, $auth_needed_partial, $auth_needed_start, $carrier, $carrier2, $hostname, $hostname_end, $hostname_exact, $hostname_exists, $hostname_partial, $hostname_start, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $sip_proxy, $sip_proxy_end, $sip_proxy_exact, $sip_proxy_exists, $sip_proxy_partial, $sip_proxy_start, $_order_auth_needed, $_order_hostname, $_order_id, $_order_ip, $_order_sip_proxy, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getCarrierServerCollectionWithHttpInfo
     *
     * Retrieves the collection of CarrierServer resources.
     *
     * @param  string $auth_needed (optional)
     * @param  string $auth_needed_end (optional)
     * @param  string $auth_needed_exact (optional)
     * @param  string $auth_needed_partial (optional)
     * @param  string $auth_needed_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  string $hostname (optional)
     * @param  string $hostname_end (optional)
     * @param  string $hostname_exact (optional)
     * @param  bool $hostname_exists (optional)
     * @param  string $hostname_partial (optional)
     * @param  string $hostname_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $sip_proxy (optional)
     * @param  string $sip_proxy_end (optional)
     * @param  string $sip_proxy_exact (optional)
     * @param  bool $sip_proxy_exists (optional)
     * @param  string $sip_proxy_partial (optional)
     * @param  string $sip_proxy_start (optional)
     * @param  string $_order_auth_needed (optional)
     * @param  string $_order_hostname (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_sip_proxy (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CarrierServerCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCarrierServerCollectionWithHttpInfo($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $carrier = null, $carrier2 = null, $hostname = null, $hostname_end = null, $hostname_exact = null, $hostname_exists = null, $hostname_partial = null, $hostname_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $sip_proxy = null, $sip_proxy_end = null, $sip_proxy_exact = null, $sip_proxy_exists = null, $sip_proxy_partial = null, $sip_proxy_start = null, $_order_auth_needed = null, $_order_hostname = null, $_order_id = null, $_order_ip = null, $_order_sip_proxy = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\CarrierServerCollection[]';
        $request = $this->getCarrierServerCollectionRequest($auth_needed, $auth_needed_end, $auth_needed_exact, $auth_needed_partial, $auth_needed_start, $carrier, $carrier2, $hostname, $hostname_end, $hostname_exact, $hostname_exists, $hostname_partial, $hostname_start, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $sip_proxy, $sip_proxy_end, $sip_proxy_exact, $sip_proxy_exists, $sip_proxy_partial, $sip_proxy_start, $_order_auth_needed, $_order_hostname, $_order_id, $_order_ip, $_order_sip_proxy, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CarrierServerCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCarrierServerCollectionAsync
     *
     * Retrieves the collection of CarrierServer resources.
     *
     * @param  string $auth_needed (optional)
     * @param  string $auth_needed_end (optional)
     * @param  string $auth_needed_exact (optional)
     * @param  string $auth_needed_partial (optional)
     * @param  string $auth_needed_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  string $hostname (optional)
     * @param  string $hostname_end (optional)
     * @param  string $hostname_exact (optional)
     * @param  bool $hostname_exists (optional)
     * @param  string $hostname_partial (optional)
     * @param  string $hostname_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $sip_proxy (optional)
     * @param  string $sip_proxy_end (optional)
     * @param  string $sip_proxy_exact (optional)
     * @param  bool $sip_proxy_exists (optional)
     * @param  string $sip_proxy_partial (optional)
     * @param  string $sip_proxy_start (optional)
     * @param  string $_order_auth_needed (optional)
     * @param  string $_order_hostname (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_sip_proxy (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierServerCollectionAsync($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $carrier = null, $carrier2 = null, $hostname = null, $hostname_end = null, $hostname_exact = null, $hostname_exists = null, $hostname_partial = null, $hostname_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $sip_proxy = null, $sip_proxy_end = null, $sip_proxy_exact = null, $sip_proxy_exists = null, $sip_proxy_partial = null, $sip_proxy_start = null, $_order_auth_needed = null, $_order_hostname = null, $_order_id = null, $_order_ip = null, $_order_sip_proxy = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getCarrierServerCollectionAsyncWithHttpInfo($auth_needed, $auth_needed_end, $auth_needed_exact, $auth_needed_partial, $auth_needed_start, $carrier, $carrier2, $hostname, $hostname_end, $hostname_exact, $hostname_exists, $hostname_partial, $hostname_start, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $sip_proxy, $sip_proxy_end, $sip_proxy_exact, $sip_proxy_exists, $sip_proxy_partial, $sip_proxy_start, $_order_auth_needed, $_order_hostname, $_order_id, $_order_ip, $_order_sip_proxy, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarrierServerCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of CarrierServer resources.
     *
     * @param  string $auth_needed (optional)
     * @param  string $auth_needed_end (optional)
     * @param  string $auth_needed_exact (optional)
     * @param  string $auth_needed_partial (optional)
     * @param  string $auth_needed_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  string $hostname (optional)
     * @param  string $hostname_end (optional)
     * @param  string $hostname_exact (optional)
     * @param  bool $hostname_exists (optional)
     * @param  string $hostname_partial (optional)
     * @param  string $hostname_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $sip_proxy (optional)
     * @param  string $sip_proxy_end (optional)
     * @param  string $sip_proxy_exact (optional)
     * @param  bool $sip_proxy_exists (optional)
     * @param  string $sip_proxy_partial (optional)
     * @param  string $sip_proxy_start (optional)
     * @param  string $_order_auth_needed (optional)
     * @param  string $_order_hostname (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_sip_proxy (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierServerCollectionAsyncWithHttpInfo($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $carrier = null, $carrier2 = null, $hostname = null, $hostname_end = null, $hostname_exact = null, $hostname_exists = null, $hostname_partial = null, $hostname_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $sip_proxy = null, $sip_proxy_end = null, $sip_proxy_exact = null, $sip_proxy_exists = null, $sip_proxy_partial = null, $sip_proxy_start = null, $_order_auth_needed = null, $_order_hostname = null, $_order_id = null, $_order_ip = null, $_order_sip_proxy = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\CarrierServerCollection[]';
        $request = $this->getCarrierServerCollectionRequest($auth_needed, $auth_needed_end, $auth_needed_exact, $auth_needed_partial, $auth_needed_start, $carrier, $carrier2, $hostname, $hostname_end, $hostname_exact, $hostname_exists, $hostname_partial, $hostname_start, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $sip_proxy, $sip_proxy_end, $sip_proxy_exact, $sip_proxy_exists, $sip_proxy_partial, $sip_proxy_start, $_order_auth_needed, $_order_hostname, $_order_id, $_order_ip, $_order_sip_proxy, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarrierServerCollection'
     *
     * @param  string $auth_needed (optional)
     * @param  string $auth_needed_end (optional)
     * @param  string $auth_needed_exact (optional)
     * @param  string $auth_needed_partial (optional)
     * @param  string $auth_needed_start (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  string $hostname (optional)
     * @param  string $hostname_end (optional)
     * @param  string $hostname_exact (optional)
     * @param  bool $hostname_exists (optional)
     * @param  string $hostname_partial (optional)
     * @param  string $hostname_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $sip_proxy (optional)
     * @param  string $sip_proxy_end (optional)
     * @param  string $sip_proxy_exact (optional)
     * @param  bool $sip_proxy_exists (optional)
     * @param  string $sip_proxy_partial (optional)
     * @param  string $sip_proxy_start (optional)
     * @param  string $_order_auth_needed (optional)
     * @param  string $_order_hostname (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_sip_proxy (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarrierServerCollectionRequest($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $carrier = null, $carrier2 = null, $hostname = null, $hostname_end = null, $hostname_exact = null, $hostname_exists = null, $hostname_partial = null, $hostname_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $sip_proxy = null, $sip_proxy_end = null, $sip_proxy_exact = null, $sip_proxy_exists = null, $sip_proxy_partial = null, $sip_proxy_start = null, $_order_auth_needed = null, $_order_hostname = null, $_order_id = null, $_order_ip = null, $_order_sip_proxy = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/carrier_servers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($auth_needed !== null) {
            $queryParams['authNeeded'] = ObjectSerializer::toQueryValue($auth_needed);
        }
        // query params
        if ($auth_needed_end !== null) {
            $queryParams['authNeeded[end]'] = ObjectSerializer::toQueryValue($auth_needed_end);
        }
        // query params
        if ($auth_needed_exact !== null) {
            $queryParams['authNeeded[exact]'] = ObjectSerializer::toQueryValue($auth_needed_exact);
        }
        // query params
        if ($auth_needed_partial !== null) {
            $queryParams['authNeeded[partial]'] = ObjectSerializer::toQueryValue($auth_needed_partial);
        }
        // query params
        if ($auth_needed_start !== null) {
            $queryParams['authNeeded[start]'] = ObjectSerializer::toQueryValue($auth_needed_start);
        }
        // query params
        if ($carrier !== null) {
            $queryParams['carrier'] = ObjectSerializer::toQueryValue($carrier);
        }
        // query params
        if ($carrier2 !== null) {
            $queryParams['carrier[]'] = ObjectSerializer::toQueryValue($carrier2);
        }
        // query params
        if ($hostname !== null) {
            $queryParams['hostname'] = ObjectSerializer::toQueryValue($hostname);
        }
        // query params
        if ($hostname_end !== null) {
            $queryParams['hostname[end]'] = ObjectSerializer::toQueryValue($hostname_end);
        }
        // query params
        if ($hostname_exact !== null) {
            $queryParams['hostname[exact]'] = ObjectSerializer::toQueryValue($hostname_exact);
        }
        // query params
        if ($hostname_exists !== null) {
            $queryParams['hostname[exists]'] = ObjectSerializer::toQueryValue($hostname_exists);
        }
        // query params
        if ($hostname_partial !== null) {
            $queryParams['hostname[partial]'] = ObjectSerializer::toQueryValue($hostname_partial);
        }
        // query params
        if ($hostname_start !== null) {
            $queryParams['hostname[start]'] = ObjectSerializer::toQueryValue($hostname_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }
        // query params
        if ($ip_end !== null) {
            $queryParams['ip[end]'] = ObjectSerializer::toQueryValue($ip_end);
        }
        // query params
        if ($ip_exact !== null) {
            $queryParams['ip[exact]'] = ObjectSerializer::toQueryValue($ip_exact);
        }
        // query params
        if ($ip_exists !== null) {
            $queryParams['ip[exists]'] = ObjectSerializer::toQueryValue($ip_exists);
        }
        // query params
        if ($ip_partial !== null) {
            $queryParams['ip[partial]'] = ObjectSerializer::toQueryValue($ip_partial);
        }
        // query params
        if ($ip_start !== null) {
            $queryParams['ip[start]'] = ObjectSerializer::toQueryValue($ip_start);
        }
        // query params
        if ($sip_proxy !== null) {
            $queryParams['sipProxy'] = ObjectSerializer::toQueryValue($sip_proxy);
        }
        // query params
        if ($sip_proxy_end !== null) {
            $queryParams['sipProxy[end]'] = ObjectSerializer::toQueryValue($sip_proxy_end);
        }
        // query params
        if ($sip_proxy_exact !== null) {
            $queryParams['sipProxy[exact]'] = ObjectSerializer::toQueryValue($sip_proxy_exact);
        }
        // query params
        if ($sip_proxy_exists !== null) {
            $queryParams['sipProxy[exists]'] = ObjectSerializer::toQueryValue($sip_proxy_exists);
        }
        // query params
        if ($sip_proxy_partial !== null) {
            $queryParams['sipProxy[partial]'] = ObjectSerializer::toQueryValue($sip_proxy_partial);
        }
        // query params
        if ($sip_proxy_start !== null) {
            $queryParams['sipProxy[start]'] = ObjectSerializer::toQueryValue($sip_proxy_start);
        }
        // query params
        if ($_order_auth_needed !== null) {
            $queryParams['_order[authNeeded]'] = ObjectSerializer::toQueryValue($_order_auth_needed);
        }
        // query params
        if ($_order_hostname !== null) {
            $queryParams['_order[hostname]'] = ObjectSerializer::toQueryValue($_order_hostname);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_ip !== null) {
            $queryParams['_order[ip]'] = ObjectSerializer::toQueryValue($_order_ip);
        }
        // query params
        if ($_order_sip_proxy !== null) {
            $queryParams['_order[sipProxy]'] = ObjectSerializer::toQueryValue($_order_sip_proxy);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarrierServerItem
     *
     * Retrieves a CarrierServer resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CarrierServerDetailed
     */
    public function getCarrierServerItem($id)
    {
        list($response) = $this->getCarrierServerItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getCarrierServerItemWithHttpInfo
     *
     * Retrieves a CarrierServer resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CarrierServerDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCarrierServerItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CarrierServerDetailed';
        $request = $this->getCarrierServerItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CarrierServerDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCarrierServerItemAsync
     *
     * Retrieves a CarrierServer resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierServerItemAsync($id)
    {
        return $this->getCarrierServerItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarrierServerItemAsyncWithHttpInfo
     *
     * Retrieves a CarrierServer resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierServerItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CarrierServerDetailed';
        $request = $this->getCarrierServerItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarrierServerItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarrierServerItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCarrierServerItem'
            );
        }

        $resourcePath = '/carrier_servers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCompanyCollection
     *
     * Retrieves the collection of Company resources.
     *
     * @param  string $call_csv_notification_template call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists call_csv_notification_template_exists (optional)
     * @param  string $country country (optional)
     * @param  string $country2 country2 (optional)
     * @param  string $currency currency (optional)
     * @param  string $currency2 currency2 (optional)
     * @param  bool $currency_exists currency_exists (optional)
     * @param  string $default_timezone default_timezone (optional)
     * @param  string $default_timezone2 default_timezone2 (optional)
     * @param  bool $default_timezone_exists default_timezone_exists (optional)
     * @param  string $fax_notification_template fax_notification_template (optional)
     * @param  string $fax_notification_template2 fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists fax_notification_template_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $invoice_notification_template invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists invoice_notification_template_exists (optional)
     * @param  string $language language (optional)
     * @param  string $language2 language2 (optional)
     * @param  bool $language_exists language_exists (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $nif nif (optional)
     * @param  string $nif_end nif_end (optional)
     * @param  string $nif_exact nif_exact (optional)
     * @param  string $nif_partial nif_partial (optional)
     * @param  string $nif_start nif_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $type type (optional)
     * @param  string $type_end type_end (optional)
     * @param  string $type_exact type_exact (optional)
     * @param  string $type_partial type_partial (optional)
     * @param  string $type_start type_start (optional)
     * @param  string $voicemail_notification_template voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists voicemail_notification_template_exists (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_nif _order_nif (optional)
     * @param  string $_order_type _order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CompanyCollection[]
     */
    public function getCompanyCollection($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $country = null, $country2 = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $default_timezone_exists = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $nif = null, $nif_end = null, $nif_exact = null, $nif_partial = null, $nif_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_name = null, $_order_nif = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getCompanyCollectionWithHttpInfo($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $country, $country2, $currency, $currency2, $currency_exists, $default_timezone, $default_timezone2, $default_timezone_exists, $fax_notification_template, $fax_notification_template2, $fax_notification_template_exists, $id_exact, $invoice_notification_template, $invoice_notification_template2, $invoice_notification_template_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $nif, $nif_end, $nif_exact, $nif_partial, $nif_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $type, $type_end, $type_exact, $type_partial, $type_start, $voicemail_notification_template, $voicemail_notification_template2, $voicemail_notification_template_exists, $_order_id, $_order_name, $_order_nif, $_order_type, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getCompanyCollectionWithHttpInfo
     *
     * Retrieves the collection of Company resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $default_timezone (optional)
     * @param  string $default_timezone2 (optional)
     * @param  bool $default_timezone_exists (optional)
     * @param  string $fax_notification_template (optional)
     * @param  string $fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $nif (optional)
     * @param  string $nif_end (optional)
     * @param  string $nif_exact (optional)
     * @param  string $nif_partial (optional)
     * @param  string $nif_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_nif (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CompanyCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCompanyCollectionWithHttpInfo($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $country = null, $country2 = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $default_timezone_exists = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $nif = null, $nif_end = null, $nif_exact = null, $nif_partial = null, $nif_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_name = null, $_order_nif = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\CompanyCollection[]';
        $request = $this->getCompanyCollectionRequest($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $country, $country2, $currency, $currency2, $currency_exists, $default_timezone, $default_timezone2, $default_timezone_exists, $fax_notification_template, $fax_notification_template2, $fax_notification_template_exists, $id_exact, $invoice_notification_template, $invoice_notification_template2, $invoice_notification_template_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $nif, $nif_end, $nif_exact, $nif_partial, $nif_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $type, $type_end, $type_exact, $type_partial, $type_start, $voicemail_notification_template, $voicemail_notification_template2, $voicemail_notification_template_exists, $_order_id, $_order_name, $_order_nif, $_order_type, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CompanyCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCompanyCollectionAsync
     *
     * Retrieves the collection of Company resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $default_timezone (optional)
     * @param  string $default_timezone2 (optional)
     * @param  bool $default_timezone_exists (optional)
     * @param  string $fax_notification_template (optional)
     * @param  string $fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $nif (optional)
     * @param  string $nif_end (optional)
     * @param  string $nif_exact (optional)
     * @param  string $nif_partial (optional)
     * @param  string $nif_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_nif (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyCollectionAsync($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $country = null, $country2 = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $default_timezone_exists = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $nif = null, $nif_end = null, $nif_exact = null, $nif_partial = null, $nif_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_name = null, $_order_nif = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getCompanyCollectionAsyncWithHttpInfo($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $country, $country2, $currency, $currency2, $currency_exists, $default_timezone, $default_timezone2, $default_timezone_exists, $fax_notification_template, $fax_notification_template2, $fax_notification_template_exists, $id_exact, $invoice_notification_template, $invoice_notification_template2, $invoice_notification_template_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $nif, $nif_end, $nif_exact, $nif_partial, $nif_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $type, $type_end, $type_exact, $type_partial, $type_start, $voicemail_notification_template, $voicemail_notification_template2, $voicemail_notification_template_exists, $_order_id, $_order_name, $_order_nif, $_order_type, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCompanyCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Company resources.
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $default_timezone (optional)
     * @param  string $default_timezone2 (optional)
     * @param  bool $default_timezone_exists (optional)
     * @param  string $fax_notification_template (optional)
     * @param  string $fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $nif (optional)
     * @param  string $nif_end (optional)
     * @param  string $nif_exact (optional)
     * @param  string $nif_partial (optional)
     * @param  string $nif_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_nif (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyCollectionAsyncWithHttpInfo($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $country = null, $country2 = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $default_timezone_exists = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $nif = null, $nif_end = null, $nif_exact = null, $nif_partial = null, $nif_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_name = null, $_order_nif = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\CompanyCollection[]';
        $request = $this->getCompanyCollectionRequest($call_csv_notification_template, $call_csv_notification_template2, $call_csv_notification_template_exists, $country, $country2, $currency, $currency2, $currency_exists, $default_timezone, $default_timezone2, $default_timezone_exists, $fax_notification_template, $fax_notification_template2, $fax_notification_template_exists, $id_exact, $invoice_notification_template, $invoice_notification_template2, $invoice_notification_template_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $nif, $nif_end, $nif_exact, $nif_partial, $nif_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $type, $type_end, $type_exact, $type_partial, $type_start, $voicemail_notification_template, $voicemail_notification_template2, $voicemail_notification_template_exists, $_order_id, $_order_name, $_order_nif, $_order_type, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCompanyCollection'
     *
     * @param  string $call_csv_notification_template (optional)
     * @param  string $call_csv_notification_template2 (optional)
     * @param  bool $call_csv_notification_template_exists (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $default_timezone (optional)
     * @param  string $default_timezone2 (optional)
     * @param  bool $default_timezone_exists (optional)
     * @param  string $fax_notification_template (optional)
     * @param  string $fax_notification_template2 (optional)
     * @param  bool $fax_notification_template_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_notification_template (optional)
     * @param  string $invoice_notification_template2 (optional)
     * @param  bool $invoice_notification_template_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $nif (optional)
     * @param  string $nif_end (optional)
     * @param  string $nif_exact (optional)
     * @param  string $nif_partial (optional)
     * @param  string $nif_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $voicemail_notification_template (optional)
     * @param  string $voicemail_notification_template2 (optional)
     * @param  bool $voicemail_notification_template_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_nif (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCompanyCollectionRequest($call_csv_notification_template = null, $call_csv_notification_template2 = null, $call_csv_notification_template_exists = null, $country = null, $country2 = null, $currency = null, $currency2 = null, $currency_exists = null, $default_timezone = null, $default_timezone2 = null, $default_timezone_exists = null, $fax_notification_template = null, $fax_notification_template2 = null, $fax_notification_template_exists = null, $id_exact = null, $invoice_notification_template = null, $invoice_notification_template2 = null, $invoice_notification_template_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $nif = null, $nif_end = null, $nif_exact = null, $nif_partial = null, $nif_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $voicemail_notification_template = null, $voicemail_notification_template2 = null, $voicemail_notification_template_exists = null, $_order_id = null, $_order_name = null, $_order_nif = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/companies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($call_csv_notification_template !== null) {
            $queryParams['callCsvNotificationTemplate'] = ObjectSerializer::toQueryValue($call_csv_notification_template);
        }
        // query params
        if ($call_csv_notification_template2 !== null) {
            $queryParams['callCsvNotificationTemplate[]'] = ObjectSerializer::toQueryValue($call_csv_notification_template2);
        }
        // query params
        if ($call_csv_notification_template_exists !== null) {
            $queryParams['callCsvNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($call_csv_notification_template_exists);
        }
        // query params
        if ($country !== null) {
            $queryParams['country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($country2 !== null) {
            $queryParams['country[]'] = ObjectSerializer::toQueryValue($country2);
        }
        // query params
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency);
        }
        // query params
        if ($currency2 !== null) {
            $queryParams['currency[]'] = ObjectSerializer::toQueryValue($currency2);
        }
        // query params
        if ($currency_exists !== null) {
            $queryParams['currency[exists]'] = ObjectSerializer::toQueryValue($currency_exists);
        }
        // query params
        if ($default_timezone !== null) {
            $queryParams['defaultTimezone'] = ObjectSerializer::toQueryValue($default_timezone);
        }
        // query params
        if ($default_timezone2 !== null) {
            $queryParams['defaultTimezone[]'] = ObjectSerializer::toQueryValue($default_timezone2);
        }
        // query params
        if ($default_timezone_exists !== null) {
            $queryParams['defaultTimezone[exists]'] = ObjectSerializer::toQueryValue($default_timezone_exists);
        }
        // query params
        if ($fax_notification_template !== null) {
            $queryParams['faxNotificationTemplate'] = ObjectSerializer::toQueryValue($fax_notification_template);
        }
        // query params
        if ($fax_notification_template2 !== null) {
            $queryParams['faxNotificationTemplate[]'] = ObjectSerializer::toQueryValue($fax_notification_template2);
        }
        // query params
        if ($fax_notification_template_exists !== null) {
            $queryParams['faxNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($fax_notification_template_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($invoice_notification_template !== null) {
            $queryParams['invoiceNotificationTemplate'] = ObjectSerializer::toQueryValue($invoice_notification_template);
        }
        // query params
        if ($invoice_notification_template2 !== null) {
            $queryParams['invoiceNotificationTemplate[]'] = ObjectSerializer::toQueryValue($invoice_notification_template2);
        }
        // query params
        if ($invoice_notification_template_exists !== null) {
            $queryParams['invoiceNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($invoice_notification_template_exists);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($language2 !== null) {
            $queryParams['language[]'] = ObjectSerializer::toQueryValue($language2);
        }
        // query params
        if ($language_exists !== null) {
            $queryParams['language[exists]'] = ObjectSerializer::toQueryValue($language_exists);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($nif !== null) {
            $queryParams['nif'] = ObjectSerializer::toQueryValue($nif);
        }
        // query params
        if ($nif_end !== null) {
            $queryParams['nif[end]'] = ObjectSerializer::toQueryValue($nif_end);
        }
        // query params
        if ($nif_exact !== null) {
            $queryParams['nif[exact]'] = ObjectSerializer::toQueryValue($nif_exact);
        }
        // query params
        if ($nif_partial !== null) {
            $queryParams['nif[partial]'] = ObjectSerializer::toQueryValue($nif_partial);
        }
        // query params
        if ($nif_start !== null) {
            $queryParams['nif[start]'] = ObjectSerializer::toQueryValue($nif_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($type_end !== null) {
            $queryParams['type[end]'] = ObjectSerializer::toQueryValue($type_end);
        }
        // query params
        if ($type_exact !== null) {
            $queryParams['type[exact]'] = ObjectSerializer::toQueryValue($type_exact);
        }
        // query params
        if ($type_partial !== null) {
            $queryParams['type[partial]'] = ObjectSerializer::toQueryValue($type_partial);
        }
        // query params
        if ($type_start !== null) {
            $queryParams['type[start]'] = ObjectSerializer::toQueryValue($type_start);
        }
        // query params
        if ($voicemail_notification_template !== null) {
            $queryParams['voicemailNotificationTemplate'] = ObjectSerializer::toQueryValue($voicemail_notification_template);
        }
        // query params
        if ($voicemail_notification_template2 !== null) {
            $queryParams['voicemailNotificationTemplate[]'] = ObjectSerializer::toQueryValue($voicemail_notification_template2);
        }
        // query params
        if ($voicemail_notification_template_exists !== null) {
            $queryParams['voicemailNotificationTemplate[exists]'] = ObjectSerializer::toQueryValue($voicemail_notification_template_exists);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_nif !== null) {
            $queryParams['_order[nif]'] = ObjectSerializer::toQueryValue($_order_nif);
        }
        // query params
        if ($_order_type !== null) {
            $queryParams['_order[type]'] = ObjectSerializer::toQueryValue($_order_type);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCompanyItem
     *
     * Retrieves a Company resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CompanyDetailed
     */
    public function getCompanyItem($id)
    {
        list($response) = $this->getCompanyItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getCompanyItemWithHttpInfo
     *
     * Retrieves a Company resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CompanyDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCompanyItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CompanyDetailed';
        $request = $this->getCompanyItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CompanyDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCompanyItemAsync
     *
     * Retrieves a Company resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyItemAsync($id)
    {
        return $this->getCompanyItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCompanyItemAsyncWithHttpInfo
     *
     * Retrieves a Company resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CompanyDetailed';
        $request = $this->getCompanyItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCompanyItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCompanyItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCompanyItem'
            );
        }

        $resourcePath = '/companies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCountryCollection
     *
     * Retrieves the collection of Country resources.
     *
     * @param  string $code code (optional)
     * @param  string $code_end code_end (optional)
     * @param  string $code_exact code_exact (optional)
     * @param  string $code_partial code_partial (optional)
     * @param  string $code_start code_start (optional)
     * @param  string $country_code country_code (optional)
     * @param  string $country_code_end country_code_end (optional)
     * @param  string $country_code_exact country_code_exact (optional)
     * @param  bool $country_code_exists country_code_exists (optional)
     * @param  string $country_code_partial country_code_partial (optional)
     * @param  string $country_code_start country_code_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  bool $name_ca_exists name_ca_exists (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  bool $name_en_exists name_en_exists (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  bool $name_es_exists name_es_exists (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  bool $name_it_exists name_it_exists (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $_order_code _order_code (optional)
     * @param  string $_order_country_code _order_country_code (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CountryCollection[]
     */
    public function getCountryCollection($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $country_code = null, $country_code_end = null, $country_code_exact = null, $country_code_exists = null, $country_code_partial = null, $country_code_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_code = null, $_order_country_code = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getCountryCollectionWithHttpInfo($code, $code_end, $code_exact, $code_partial, $code_start, $country_code, $country_code_end, $country_code_exact, $country_code_exists, $country_code_partial, $country_code_start, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $_order_code, $_order_country_code, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getCountryCollectionWithHttpInfo
     *
     * Retrieves the collection of Country resources.
     *
     * @param  string $code (optional)
     * @param  string $code_end (optional)
     * @param  string $code_exact (optional)
     * @param  string $code_partial (optional)
     * @param  string $code_start (optional)
     * @param  string $country_code (optional)
     * @param  string $country_code_end (optional)
     * @param  string $country_code_exact (optional)
     * @param  bool $country_code_exists (optional)
     * @param  string $country_code_partial (optional)
     * @param  string $country_code_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_code (optional)
     * @param  string $_order_country_code (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CountryCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCountryCollectionWithHttpInfo($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $country_code = null, $country_code_end = null, $country_code_exact = null, $country_code_exists = null, $country_code_partial = null, $country_code_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_code = null, $_order_country_code = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\CountryCollection[]';
        $request = $this->getCountryCollectionRequest($code, $code_end, $code_exact, $code_partial, $code_start, $country_code, $country_code_end, $country_code_exact, $country_code_exists, $country_code_partial, $country_code_start, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $_order_code, $_order_country_code, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CountryCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCountryCollectionAsync
     *
     * Retrieves the collection of Country resources.
     *
     * @param  string $code (optional)
     * @param  string $code_end (optional)
     * @param  string $code_exact (optional)
     * @param  string $code_partial (optional)
     * @param  string $code_start (optional)
     * @param  string $country_code (optional)
     * @param  string $country_code_end (optional)
     * @param  string $country_code_exact (optional)
     * @param  bool $country_code_exists (optional)
     * @param  string $country_code_partial (optional)
     * @param  string $country_code_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_code (optional)
     * @param  string $_order_country_code (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCountryCollectionAsync($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $country_code = null, $country_code_end = null, $country_code_exact = null, $country_code_exists = null, $country_code_partial = null, $country_code_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_code = null, $_order_country_code = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getCountryCollectionAsyncWithHttpInfo($code, $code_end, $code_exact, $code_partial, $code_start, $country_code, $country_code_end, $country_code_exact, $country_code_exists, $country_code_partial, $country_code_start, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $_order_code, $_order_country_code, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCountryCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Country resources.
     *
     * @param  string $code (optional)
     * @param  string $code_end (optional)
     * @param  string $code_exact (optional)
     * @param  string $code_partial (optional)
     * @param  string $code_start (optional)
     * @param  string $country_code (optional)
     * @param  string $country_code_end (optional)
     * @param  string $country_code_exact (optional)
     * @param  bool $country_code_exists (optional)
     * @param  string $country_code_partial (optional)
     * @param  string $country_code_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_code (optional)
     * @param  string $_order_country_code (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCountryCollectionAsyncWithHttpInfo($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $country_code = null, $country_code_end = null, $country_code_exact = null, $country_code_exists = null, $country_code_partial = null, $country_code_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_code = null, $_order_country_code = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\CountryCollection[]';
        $request = $this->getCountryCollectionRequest($code, $code_end, $code_exact, $code_partial, $code_start, $country_code, $country_code_end, $country_code_exact, $country_code_exists, $country_code_partial, $country_code_start, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $_order_code, $_order_country_code, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCountryCollection'
     *
     * @param  string $code (optional)
     * @param  string $code_end (optional)
     * @param  string $code_exact (optional)
     * @param  string $code_partial (optional)
     * @param  string $code_start (optional)
     * @param  string $country_code (optional)
     * @param  string $country_code_end (optional)
     * @param  string $country_code_exact (optional)
     * @param  bool $country_code_exists (optional)
     * @param  string $country_code_partial (optional)
     * @param  string $country_code_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_code (optional)
     * @param  string $_order_country_code (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCountryCollectionRequest($code = null, $code_end = null, $code_exact = null, $code_partial = null, $code_start = null, $country_code = null, $country_code_end = null, $country_code_exact = null, $country_code_exists = null, $country_code_partial = null, $country_code_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_code = null, $_order_country_code = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code);
        }
        // query params
        if ($code_end !== null) {
            $queryParams['code[end]'] = ObjectSerializer::toQueryValue($code_end);
        }
        // query params
        if ($code_exact !== null) {
            $queryParams['code[exact]'] = ObjectSerializer::toQueryValue($code_exact);
        }
        // query params
        if ($code_partial !== null) {
            $queryParams['code[partial]'] = ObjectSerializer::toQueryValue($code_partial);
        }
        // query params
        if ($code_start !== null) {
            $queryParams['code[start]'] = ObjectSerializer::toQueryValue($code_start);
        }
        // query params
        if ($country_code !== null) {
            $queryParams['countryCode'] = ObjectSerializer::toQueryValue($country_code);
        }
        // query params
        if ($country_code_end !== null) {
            $queryParams['countryCode[end]'] = ObjectSerializer::toQueryValue($country_code_end);
        }
        // query params
        if ($country_code_exact !== null) {
            $queryParams['countryCode[exact]'] = ObjectSerializer::toQueryValue($country_code_exact);
        }
        // query params
        if ($country_code_exists !== null) {
            $queryParams['countryCode[exists]'] = ObjectSerializer::toQueryValue($country_code_exists);
        }
        // query params
        if ($country_code_partial !== null) {
            $queryParams['countryCode[partial]'] = ObjectSerializer::toQueryValue($country_code_partial);
        }
        // query params
        if ($country_code_start !== null) {
            $queryParams['countryCode[start]'] = ObjectSerializer::toQueryValue($country_code_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_exists !== null) {
            $queryParams['name.ca[exists]'] = ObjectSerializer::toQueryValue($name_ca_exists);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_exists !== null) {
            $queryParams['name.en[exists]'] = ObjectSerializer::toQueryValue($name_en_exists);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_exists !== null) {
            $queryParams['name.es[exists]'] = ObjectSerializer::toQueryValue($name_es_exists);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_exists !== null) {
            $queryParams['name.it[exists]'] = ObjectSerializer::toQueryValue($name_it_exists);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($_order_code !== null) {
            $queryParams['_order[code]'] = ObjectSerializer::toQueryValue($_order_code);
        }
        // query params
        if ($_order_country_code !== null) {
            $queryParams['_order[countryCode]'] = ObjectSerializer::toQueryValue($_order_country_code);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCountryItem
     *
     * Retrieves a Country resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CountryDetailed
     */
    public function getCountryItem($id)
    {
        list($response) = $this->getCountryItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getCountryItemWithHttpInfo
     *
     * Retrieves a Country resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CountryDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCountryItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CountryDetailed';
        $request = $this->getCountryItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CountryDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCountryItemAsync
     *
     * Retrieves a Country resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCountryItemAsync($id)
    {
        return $this->getCountryItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCountryItemAsyncWithHttpInfo
     *
     * Retrieves a Country resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCountryItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CountryDetailed';
        $request = $this->getCountryItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCountryItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCountryItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCountryItem'
            );
        }

        $resourcePath = '/countries/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrencyCollection
     *
     * Retrieves the collection of Currency resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $iden iden (optional)
     * @param  string $iden_end iden_end (optional)
     * @param  string $iden_exact iden_exact (optional)
     * @param  string $iden_partial iden_partial (optional)
     * @param  string $iden_start iden_start (optional)
     * @param  string $name name (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $symbol symbol (optional)
     * @param  string $symbol_end symbol_end (optional)
     * @param  string $symbol_exact symbol_exact (optional)
     * @param  string $symbol_partial symbol_partial (optional)
     * @param  string $symbol_start symbol_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_iden _order_iden (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  string $_order_symbol _order_symbol (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CurrencyCollection[]
     */
    public function getCurrencyCollection($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $symbol = null, $symbol_end = null, $symbol_exact = null, $symbol_partial = null, $symbol_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_symbol = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getCurrencyCollectionWithHttpInfo($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $symbol, $symbol_end, $symbol_exact, $symbol_partial, $symbol_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_symbol, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getCurrencyCollectionWithHttpInfo
     *
     * Retrieves the collection of Currency resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $symbol (optional)
     * @param  string $symbol_end (optional)
     * @param  string $symbol_exact (optional)
     * @param  string $symbol_partial (optional)
     * @param  string $symbol_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_symbol (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CurrencyCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrencyCollectionWithHttpInfo($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $symbol = null, $symbol_end = null, $symbol_exact = null, $symbol_partial = null, $symbol_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_symbol = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\CurrencyCollection[]';
        $request = $this->getCurrencyCollectionRequest($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $symbol, $symbol_end, $symbol_exact, $symbol_partial, $symbol_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_symbol, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CurrencyCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrencyCollectionAsync
     *
     * Retrieves the collection of Currency resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $symbol (optional)
     * @param  string $symbol_end (optional)
     * @param  string $symbol_exact (optional)
     * @param  string $symbol_partial (optional)
     * @param  string $symbol_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_symbol (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyCollectionAsync($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $symbol = null, $symbol_end = null, $symbol_exact = null, $symbol_partial = null, $symbol_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_symbol = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getCurrencyCollectionAsyncWithHttpInfo($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $symbol, $symbol_end, $symbol_exact, $symbol_partial, $symbol_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_symbol, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrencyCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Currency resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $symbol (optional)
     * @param  string $symbol_end (optional)
     * @param  string $symbol_exact (optional)
     * @param  string $symbol_partial (optional)
     * @param  string $symbol_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_symbol (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyCollectionAsyncWithHttpInfo($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $symbol = null, $symbol_end = null, $symbol_exact = null, $symbol_partial = null, $symbol_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_symbol = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\CurrencyCollection[]';
        $request = $this->getCurrencyCollectionRequest($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $symbol, $symbol_end, $symbol_exact, $symbol_partial, $symbol_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_symbol, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrencyCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $symbol (optional)
     * @param  string $symbol_end (optional)
     * @param  string $symbol_exact (optional)
     * @param  string $symbol_partial (optional)
     * @param  string $symbol_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_symbol (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrencyCollectionRequest($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $symbol = null, $symbol_end = null, $symbol_exact = null, $symbol_partial = null, $symbol_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_symbol = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($iden !== null) {
            $queryParams['iden'] = ObjectSerializer::toQueryValue($iden);
        }
        // query params
        if ($iden_end !== null) {
            $queryParams['iden[end]'] = ObjectSerializer::toQueryValue($iden_end);
        }
        // query params
        if ($iden_exact !== null) {
            $queryParams['iden[exact]'] = ObjectSerializer::toQueryValue($iden_exact);
        }
        // query params
        if ($iden_partial !== null) {
            $queryParams['iden[partial]'] = ObjectSerializer::toQueryValue($iden_partial);
        }
        // query params
        if ($iden_start !== null) {
            $queryParams['iden[start]'] = ObjectSerializer::toQueryValue($iden_start);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($symbol !== null) {
            $queryParams['symbol'] = ObjectSerializer::toQueryValue($symbol);
        }
        // query params
        if ($symbol_end !== null) {
            $queryParams['symbol[end]'] = ObjectSerializer::toQueryValue($symbol_end);
        }
        // query params
        if ($symbol_exact !== null) {
            $queryParams['symbol[exact]'] = ObjectSerializer::toQueryValue($symbol_exact);
        }
        // query params
        if ($symbol_partial !== null) {
            $queryParams['symbol[partial]'] = ObjectSerializer::toQueryValue($symbol_partial);
        }
        // query params
        if ($symbol_start !== null) {
            $queryParams['symbol[start]'] = ObjectSerializer::toQueryValue($symbol_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_iden !== null) {
            $queryParams['_order[iden]'] = ObjectSerializer::toQueryValue($_order_iden);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_order_symbol !== null) {
            $queryParams['_order[symbol]'] = ObjectSerializer::toQueryValue($_order_symbol);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrencyItem
     *
     * Retrieves a Currency resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CurrencyDetailed
     */
    public function getCurrencyItem($id)
    {
        list($response) = $this->getCurrencyItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getCurrencyItemWithHttpInfo
     *
     * Retrieves a Currency resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CurrencyDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrencyItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CurrencyDetailed';
        $request = $this->getCurrencyItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CurrencyDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrencyItemAsync
     *
     * Retrieves a Currency resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyItemAsync($id)
    {
        return $this->getCurrencyItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrencyItemAsyncWithHttpInfo
     *
     * Retrieves a Currency resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\CurrencyDetailed';
        $request = $this->getCurrencyItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrencyItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrencyItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCurrencyItem'
            );
        }

        $resourcePath = '/currencies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDdiCollection
     *
     * Retrieves the collection of Ddi resources.
     *
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  string $country country (optional)
     * @param  string $country2 country2 (optional)
     * @param  bool $country_exists country_exists (optional)
     * @param  string $ddi ddi (optional)
     * @param  string $ddi_provider ddi_provider (optional)
     * @param  string $ddi_provider2 ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists ddi_provider_exists (optional)
     * @param  string $ddi_end ddi_end (optional)
     * @param  string $ddi_exact ddi_exact (optional)
     * @param  string $ddi_partial ddi_partial (optional)
     * @param  string $ddi_start ddi_start (optional)
     * @param  string $ddie164 ddie164 (optional)
     * @param  string $ddie164_end ddie164_end (optional)
     * @param  string $ddie164_exact ddie164_exact (optional)
     * @param  bool $ddie164_exists ddie164_exists (optional)
     * @param  string $ddie164_partial ddie164_partial (optional)
     * @param  string $ddie164_start ddie164_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $_order_ddi _order_ddi (optional)
     * @param  string $_order_ddie164 _order_ddie164 (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiCollection[]
     */
    public function getDdiCollection($company = null, $company2 = null, $country = null, $country2 = null, $country_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi_end = null, $ddi_exact = null, $ddi_partial = null, $ddi_start = null, $ddie164 = null, $ddie164_end = null, $ddie164_exact = null, $ddie164_exists = null, $ddie164_partial = null, $ddie164_start = null, $id_exact = null, $_order_ddi = null, $_order_ddie164 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getDdiCollectionWithHttpInfo($company, $company2, $country, $country2, $country_exists, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi_end, $ddi_exact, $ddi_partial, $ddi_start, $ddie164, $ddie164_end, $ddie164_exact, $ddie164_exists, $ddie164_partial, $ddie164_start, $id_exact, $_order_ddi, $_order_ddie164, $_order_id, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getDdiCollectionWithHttpInfo
     *
     * Retrieves the collection of Ddi resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi_end (optional)
     * @param  string $ddi_exact (optional)
     * @param  string $ddi_partial (optional)
     * @param  string $ddi_start (optional)
     * @param  string $ddie164 (optional)
     * @param  string $ddie164_end (optional)
     * @param  string $ddie164_exact (optional)
     * @param  bool $ddie164_exists (optional)
     * @param  string $ddie164_partial (optional)
     * @param  string $ddie164_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_ddi (optional)
     * @param  string $_order_ddie164 (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDdiCollectionWithHttpInfo($company = null, $company2 = null, $country = null, $country2 = null, $country_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi_end = null, $ddi_exact = null, $ddi_partial = null, $ddi_start = null, $ddie164 = null, $ddie164_end = null, $ddie164_exact = null, $ddie164_exists = null, $ddie164_partial = null, $ddie164_start = null, $id_exact = null, $_order_ddi = null, $_order_ddie164 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DdiCollection[]';
        $request = $this->getDdiCollectionRequest($company, $company2, $country, $country2, $country_exists, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi_end, $ddi_exact, $ddi_partial, $ddi_start, $ddie164, $ddie164_end, $ddie164_exact, $ddie164_exists, $ddie164_partial, $ddie164_start, $id_exact, $_order_ddi, $_order_ddie164, $_order_id, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDdiCollectionAsync
     *
     * Retrieves the collection of Ddi resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi_end (optional)
     * @param  string $ddi_exact (optional)
     * @param  string $ddi_partial (optional)
     * @param  string $ddi_start (optional)
     * @param  string $ddie164 (optional)
     * @param  string $ddie164_end (optional)
     * @param  string $ddie164_exact (optional)
     * @param  bool $ddie164_exists (optional)
     * @param  string $ddie164_partial (optional)
     * @param  string $ddie164_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_ddi (optional)
     * @param  string $_order_ddie164 (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiCollectionAsync($company = null, $company2 = null, $country = null, $country2 = null, $country_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi_end = null, $ddi_exact = null, $ddi_partial = null, $ddi_start = null, $ddie164 = null, $ddie164_end = null, $ddie164_exact = null, $ddie164_exists = null, $ddie164_partial = null, $ddie164_start = null, $id_exact = null, $_order_ddi = null, $_order_ddie164 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getDdiCollectionAsyncWithHttpInfo($company, $company2, $country, $country2, $country_exists, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi_end, $ddi_exact, $ddi_partial, $ddi_start, $ddie164, $ddie164_end, $ddie164_exact, $ddie164_exists, $ddie164_partial, $ddie164_start, $id_exact, $_order_ddi, $_order_ddie164, $_order_id, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDdiCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Ddi resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi_end (optional)
     * @param  string $ddi_exact (optional)
     * @param  string $ddi_partial (optional)
     * @param  string $ddi_start (optional)
     * @param  string $ddie164 (optional)
     * @param  string $ddie164_end (optional)
     * @param  string $ddie164_exact (optional)
     * @param  bool $ddie164_exists (optional)
     * @param  string $ddie164_partial (optional)
     * @param  string $ddie164_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_ddi (optional)
     * @param  string $_order_ddie164 (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiCollectionAsyncWithHttpInfo($company = null, $company2 = null, $country = null, $country2 = null, $country_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi_end = null, $ddi_exact = null, $ddi_partial = null, $ddi_start = null, $ddie164 = null, $ddie164_end = null, $ddie164_exact = null, $ddie164_exists = null, $ddie164_partial = null, $ddie164_start = null, $id_exact = null, $_order_ddi = null, $_order_ddie164 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DdiCollection[]';
        $request = $this->getDdiCollectionRequest($company, $company2, $country, $country2, $country_exists, $ddi, $ddi_provider, $ddi_provider2, $ddi_provider_exists, $ddi_end, $ddi_exact, $ddi_partial, $ddi_start, $ddie164, $ddie164_end, $ddie164_exact, $ddie164_exists, $ddie164_partial, $ddie164_start, $id_exact, $_order_ddi, $_order_ddie164, $_order_id, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDdiCollection'
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  string $ddi (optional)
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  bool $ddi_provider_exists (optional)
     * @param  string $ddi_end (optional)
     * @param  string $ddi_exact (optional)
     * @param  string $ddi_partial (optional)
     * @param  string $ddi_start (optional)
     * @param  string $ddie164 (optional)
     * @param  string $ddie164_end (optional)
     * @param  string $ddie164_exact (optional)
     * @param  bool $ddie164_exists (optional)
     * @param  string $ddie164_partial (optional)
     * @param  string $ddie164_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_ddi (optional)
     * @param  string $_order_ddie164 (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDdiCollectionRequest($company = null, $company2 = null, $country = null, $country2 = null, $country_exists = null, $ddi = null, $ddi_provider = null, $ddi_provider2 = null, $ddi_provider_exists = null, $ddi_end = null, $ddi_exact = null, $ddi_partial = null, $ddi_start = null, $ddie164 = null, $ddie164_end = null, $ddie164_exact = null, $ddie164_exists = null, $ddie164_partial = null, $ddie164_start = null, $id_exact = null, $_order_ddi = null, $_order_ddie164 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/ddis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($country !== null) {
            $queryParams['country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($country2 !== null) {
            $queryParams['country[]'] = ObjectSerializer::toQueryValue($country2);
        }
        // query params
        if ($country_exists !== null) {
            $queryParams['country[exists]'] = ObjectSerializer::toQueryValue($country_exists);
        }
        // query params
        if ($ddi !== null) {
            $queryParams['ddi'] = ObjectSerializer::toQueryValue($ddi);
        }
        // query params
        if ($ddi_provider !== null) {
            $queryParams['ddiProvider'] = ObjectSerializer::toQueryValue($ddi_provider);
        }
        // query params
        if ($ddi_provider2 !== null) {
            $queryParams['ddiProvider[]'] = ObjectSerializer::toQueryValue($ddi_provider2);
        }
        // query params
        if ($ddi_provider_exists !== null) {
            $queryParams['ddiProvider[exists]'] = ObjectSerializer::toQueryValue($ddi_provider_exists);
        }
        // query params
        if ($ddi_end !== null) {
            $queryParams['ddi[end]'] = ObjectSerializer::toQueryValue($ddi_end);
        }
        // query params
        if ($ddi_exact !== null) {
            $queryParams['ddi[exact]'] = ObjectSerializer::toQueryValue($ddi_exact);
        }
        // query params
        if ($ddi_partial !== null) {
            $queryParams['ddi[partial]'] = ObjectSerializer::toQueryValue($ddi_partial);
        }
        // query params
        if ($ddi_start !== null) {
            $queryParams['ddi[start]'] = ObjectSerializer::toQueryValue($ddi_start);
        }
        // query params
        if ($ddie164 !== null) {
            $queryParams['ddie164'] = ObjectSerializer::toQueryValue($ddie164);
        }
        // query params
        if ($ddie164_end !== null) {
            $queryParams['ddie164[end]'] = ObjectSerializer::toQueryValue($ddie164_end);
        }
        // query params
        if ($ddie164_exact !== null) {
            $queryParams['ddie164[exact]'] = ObjectSerializer::toQueryValue($ddie164_exact);
        }
        // query params
        if ($ddie164_exists !== null) {
            $queryParams['ddie164[exists]'] = ObjectSerializer::toQueryValue($ddie164_exists);
        }
        // query params
        if ($ddie164_partial !== null) {
            $queryParams['ddie164[partial]'] = ObjectSerializer::toQueryValue($ddie164_partial);
        }
        // query params
        if ($ddie164_start !== null) {
            $queryParams['ddie164[start]'] = ObjectSerializer::toQueryValue($ddie164_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($_order_ddi !== null) {
            $queryParams['_order[ddi]'] = ObjectSerializer::toQueryValue($_order_ddi);
        }
        // query params
        if ($_order_ddie164 !== null) {
            $queryParams['_order[ddie164]'] = ObjectSerializer::toQueryValue($_order_ddie164);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDdiItem
     *
     * Retrieves a Ddi resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiDetailed
     */
    public function getDdiItem($id)
    {
        list($response) = $this->getDdiItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDdiItemWithHttpInfo
     *
     * Retrieves a Ddi resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDdiItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DdiDetailed';
        $request = $this->getDdiItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDdiItemAsync
     *
     * Retrieves a Ddi resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiItemAsync($id)
    {
        return $this->getDdiItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDdiItemAsyncWithHttpInfo
     *
     * Retrieves a Ddi resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DdiDetailed';
        $request = $this->getDdiItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDdiItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDdiItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDdiItem'
            );
        }

        $resourcePath = '/ddis/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDdiProviderAddressCollection
     *
     * Retrieves the collection of DdiProviderAddress resources.
     *
     * @param  string $ddi_provider ddi_provider (optional)
     * @param  string $ddi_provider2 ddi_provider2 (optional)
     * @param  string $description description (optional)
     * @param  string $description_end description_end (optional)
     * @param  string $description_exact description_exact (optional)
     * @param  bool $description_exists description_exists (optional)
     * @param  string $description_partial description_partial (optional)
     * @param  string $description_start description_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $ip ip (optional)
     * @param  string $ip_end ip_end (optional)
     * @param  string $ip_exact ip_exact (optional)
     * @param  bool $ip_exists ip_exists (optional)
     * @param  string $ip_partial ip_partial (optional)
     * @param  string $ip_start ip_start (optional)
     * @param  string $_order_description _order_description (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_ip _order_ip (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderAddressCollection[]
     */
    public function getDdiProviderAddressCollection($ddi_provider = null, $ddi_provider2 = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $_order_description = null, $_order_id = null, $_order_ip = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getDdiProviderAddressCollectionWithHttpInfo($ddi_provider, $ddi_provider2, $description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $_order_description, $_order_id, $_order_ip, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getDdiProviderAddressCollectionWithHttpInfo
     *
     * Retrieves the collection of DdiProviderAddress resources.
     *
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderAddressCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDdiProviderAddressCollectionWithHttpInfo($ddi_provider = null, $ddi_provider2 = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $_order_description = null, $_order_id = null, $_order_ip = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderAddressCollection[]';
        $request = $this->getDdiProviderAddressCollectionRequest($ddi_provider, $ddi_provider2, $description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $_order_description, $_order_id, $_order_ip, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderAddressCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDdiProviderAddressCollectionAsync
     *
     * Retrieves the collection of DdiProviderAddress resources.
     *
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderAddressCollectionAsync($ddi_provider = null, $ddi_provider2 = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $_order_description = null, $_order_id = null, $_order_ip = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getDdiProviderAddressCollectionAsyncWithHttpInfo($ddi_provider, $ddi_provider2, $description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $_order_description, $_order_id, $_order_ip, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDdiProviderAddressCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of DdiProviderAddress resources.
     *
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderAddressCollectionAsyncWithHttpInfo($ddi_provider = null, $ddi_provider2 = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $_order_description = null, $_order_id = null, $_order_ip = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderAddressCollection[]';
        $request = $this->getDdiProviderAddressCollectionRequest($ddi_provider, $ddi_provider2, $description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $ip, $ip_end, $ip_exact, $ip_exists, $ip_partial, $ip_start, $_order_description, $_order_id, $_order_ip, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDdiProviderAddressCollection'
     *
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  bool $ip_exists (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDdiProviderAddressCollectionRequest($ddi_provider = null, $ddi_provider2 = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_exists = null, $ip_partial = null, $ip_start = null, $_order_description = null, $_order_id = null, $_order_ip = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/ddi_provider_addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ddi_provider !== null) {
            $queryParams['ddiProvider'] = ObjectSerializer::toQueryValue($ddi_provider);
        }
        // query params
        if ($ddi_provider2 !== null) {
            $queryParams['ddiProvider[]'] = ObjectSerializer::toQueryValue($ddi_provider2);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($description_end !== null) {
            $queryParams['description[end]'] = ObjectSerializer::toQueryValue($description_end);
        }
        // query params
        if ($description_exact !== null) {
            $queryParams['description[exact]'] = ObjectSerializer::toQueryValue($description_exact);
        }
        // query params
        if ($description_exists !== null) {
            $queryParams['description[exists]'] = ObjectSerializer::toQueryValue($description_exists);
        }
        // query params
        if ($description_partial !== null) {
            $queryParams['description[partial]'] = ObjectSerializer::toQueryValue($description_partial);
        }
        // query params
        if ($description_start !== null) {
            $queryParams['description[start]'] = ObjectSerializer::toQueryValue($description_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }
        // query params
        if ($ip_end !== null) {
            $queryParams['ip[end]'] = ObjectSerializer::toQueryValue($ip_end);
        }
        // query params
        if ($ip_exact !== null) {
            $queryParams['ip[exact]'] = ObjectSerializer::toQueryValue($ip_exact);
        }
        // query params
        if ($ip_exists !== null) {
            $queryParams['ip[exists]'] = ObjectSerializer::toQueryValue($ip_exists);
        }
        // query params
        if ($ip_partial !== null) {
            $queryParams['ip[partial]'] = ObjectSerializer::toQueryValue($ip_partial);
        }
        // query params
        if ($ip_start !== null) {
            $queryParams['ip[start]'] = ObjectSerializer::toQueryValue($ip_start);
        }
        // query params
        if ($_order_description !== null) {
            $queryParams['_order[description]'] = ObjectSerializer::toQueryValue($_order_description);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_ip !== null) {
            $queryParams['_order[ip]'] = ObjectSerializer::toQueryValue($_order_ip);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDdiProviderAddressItem
     *
     * Retrieves a DdiProviderAddress resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderAddressDetailed
     */
    public function getDdiProviderAddressItem($id)
    {
        list($response) = $this->getDdiProviderAddressItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDdiProviderAddressItemWithHttpInfo
     *
     * Retrieves a DdiProviderAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderAddressDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDdiProviderAddressItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderAddressDetailed';
        $request = $this->getDdiProviderAddressItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderAddressDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDdiProviderAddressItemAsync
     *
     * Retrieves a DdiProviderAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderAddressItemAsync($id)
    {
        return $this->getDdiProviderAddressItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDdiProviderAddressItemAsyncWithHttpInfo
     *
     * Retrieves a DdiProviderAddress resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderAddressItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderAddressDetailed';
        $request = $this->getDdiProviderAddressItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDdiProviderAddressItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDdiProviderAddressItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDdiProviderAddressItem'
            );
        }

        $resourcePath = '/ddi_provider_addresses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDdiProviderCollection
     *
     * Retrieves the collection of DdiProvider resources.
     *
     * @param  string $description description (optional)
     * @param  string $description_end description_end (optional)
     * @param  string $description_exact description_exact (optional)
     * @param  string $description_partial description_partial (optional)
     * @param  string $description_start description_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $proxy_trunk proxy_trunk (optional)
     * @param  string $proxy_trunk2 proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $_order_description _order_description (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderCollection[]
     */
    public function getDdiProviderCollection($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getDdiProviderCollectionWithHttpInfo($description, $description_end, $description_exact, $description_partial, $description_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $proxy_trunk, $proxy_trunk2, $proxy_trunk_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getDdiProviderCollectionWithHttpInfo
     *
     * Retrieves the collection of DdiProvider resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $proxy_trunk (optional)
     * @param  string $proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDdiProviderCollectionWithHttpInfo($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderCollection[]';
        $request = $this->getDdiProviderCollectionRequest($description, $description_end, $description_exact, $description_partial, $description_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $proxy_trunk, $proxy_trunk2, $proxy_trunk_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDdiProviderCollectionAsync
     *
     * Retrieves the collection of DdiProvider resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $proxy_trunk (optional)
     * @param  string $proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderCollectionAsync($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getDdiProviderCollectionAsyncWithHttpInfo($description, $description_end, $description_exact, $description_partial, $description_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $proxy_trunk, $proxy_trunk2, $proxy_trunk_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_id, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDdiProviderCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of DdiProvider resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $proxy_trunk (optional)
     * @param  string $proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderCollectionAsyncWithHttpInfo($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderCollection[]';
        $request = $this->getDdiProviderCollectionRequest($description, $description_end, $description_exact, $description_partial, $description_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $proxy_trunk, $proxy_trunk2, $proxy_trunk_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDdiProviderCollection'
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $proxy_trunk (optional)
     * @param  string $proxy_trunk2 (optional)
     * @param  bool $proxy_trunk_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDdiProviderCollectionRequest($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $proxy_trunk = null, $proxy_trunk2 = null, $proxy_trunk_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/ddi_providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($description_end !== null) {
            $queryParams['description[end]'] = ObjectSerializer::toQueryValue($description_end);
        }
        // query params
        if ($description_exact !== null) {
            $queryParams['description[exact]'] = ObjectSerializer::toQueryValue($description_exact);
        }
        // query params
        if ($description_partial !== null) {
            $queryParams['description[partial]'] = ObjectSerializer::toQueryValue($description_partial);
        }
        // query params
        if ($description_start !== null) {
            $queryParams['description[start]'] = ObjectSerializer::toQueryValue($description_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($proxy_trunk !== null) {
            $queryParams['proxyTrunk'] = ObjectSerializer::toQueryValue($proxy_trunk);
        }
        // query params
        if ($proxy_trunk2 !== null) {
            $queryParams['proxyTrunk[]'] = ObjectSerializer::toQueryValue($proxy_trunk2);
        }
        // query params
        if ($proxy_trunk_exists !== null) {
            $queryParams['proxyTrunk[exists]'] = ObjectSerializer::toQueryValue($proxy_trunk_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($_order_description !== null) {
            $queryParams['_order[description]'] = ObjectSerializer::toQueryValue($_order_description);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDdiProviderItem
     *
     * Retrieves a DdiProvider resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderDetailed
     */
    public function getDdiProviderItem($id)
    {
        list($response) = $this->getDdiProviderItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDdiProviderItemWithHttpInfo
     *
     * Retrieves a DdiProvider resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDdiProviderItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderDetailed';
        $request = $this->getDdiProviderItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDdiProviderItemAsync
     *
     * Retrieves a DdiProvider resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderItemAsync($id)
    {
        return $this->getDdiProviderItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDdiProviderItemAsyncWithHttpInfo
     *
     * Retrieves a DdiProvider resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderDetailed';
        $request = $this->getDdiProviderItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDdiProviderItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDdiProviderItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDdiProviderItem'
            );
        }

        $resourcePath = '/ddi_providers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDdiProviderRegistrationCollection
     *
     * Retrieves the collection of DdiProviderRegistration resources.
     *
     * @param  string $ddi_provider ddi_provider (optional)
     * @param  string $ddi_provider2 ddi_provider2 (optional)
     * @param  string $domain domain (optional)
     * @param  string $domain_end domain_end (optional)
     * @param  string $domain_exact domain_exact (optional)
     * @param  string $domain_partial domain_partial (optional)
     * @param  string $domain_start domain_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  int $status_expires status_expires (optional)
     * @param  bool $status_in_progress status_in_progress (optional)
     * @param  bool $status_registered status_registered (optional)
     * @param  string $username username (optional)
     * @param  string $username_end username_end (optional)
     * @param  string $username_exact username_exact (optional)
     * @param  string $username_partial username_partial (optional)
     * @param  string $username_start username_start (optional)
     * @param  string $_order_domain _order_domain (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_username _order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderRegistrationDetailedCollection[]
     */
    public function getDdiProviderRegistrationCollection($ddi_provider = null, $ddi_provider2 = null, $domain = null, $domain_end = null, $domain_exact = null, $domain_partial = null, $domain_start = null, $id_exact = null, $status_expires = null, $status_in_progress = null, $status_registered = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_domain = null, $_order_id = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getDdiProviderRegistrationCollectionWithHttpInfo($ddi_provider, $ddi_provider2, $domain, $domain_end, $domain_exact, $domain_partial, $domain_start, $id_exact, $status_expires, $status_in_progress, $status_registered, $username, $username_end, $username_exact, $username_partial, $username_start, $_order_domain, $_order_id, $_order_username, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getDdiProviderRegistrationCollectionWithHttpInfo
     *
     * Retrieves the collection of DdiProviderRegistration resources.
     *
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  string $domain (optional)
     * @param  string $domain_end (optional)
     * @param  string $domain_exact (optional)
     * @param  string $domain_partial (optional)
     * @param  string $domain_start (optional)
     * @param  int $id_exact (optional)
     * @param  int $status_expires (optional)
     * @param  bool $status_in_progress (optional)
     * @param  bool $status_registered (optional)
     * @param  string $username (optional)
     * @param  string $username_end (optional)
     * @param  string $username_exact (optional)
     * @param  string $username_partial (optional)
     * @param  string $username_start (optional)
     * @param  string $_order_domain (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderRegistrationDetailedCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDdiProviderRegistrationCollectionWithHttpInfo($ddi_provider = null, $ddi_provider2 = null, $domain = null, $domain_end = null, $domain_exact = null, $domain_partial = null, $domain_start = null, $id_exact = null, $status_expires = null, $status_in_progress = null, $status_registered = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_domain = null, $_order_id = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderRegistrationDetailedCollection[]';
        $request = $this->getDdiProviderRegistrationCollectionRequest($ddi_provider, $ddi_provider2, $domain, $domain_end, $domain_exact, $domain_partial, $domain_start, $id_exact, $status_expires, $status_in_progress, $status_registered, $username, $username_end, $username_exact, $username_partial, $username_start, $_order_domain, $_order_id, $_order_username, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderRegistrationDetailedCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDdiProviderRegistrationCollectionAsync
     *
     * Retrieves the collection of DdiProviderRegistration resources.
     *
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  string $domain (optional)
     * @param  string $domain_end (optional)
     * @param  string $domain_exact (optional)
     * @param  string $domain_partial (optional)
     * @param  string $domain_start (optional)
     * @param  int $id_exact (optional)
     * @param  int $status_expires (optional)
     * @param  bool $status_in_progress (optional)
     * @param  bool $status_registered (optional)
     * @param  string $username (optional)
     * @param  string $username_end (optional)
     * @param  string $username_exact (optional)
     * @param  string $username_partial (optional)
     * @param  string $username_start (optional)
     * @param  string $_order_domain (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderRegistrationCollectionAsync($ddi_provider = null, $ddi_provider2 = null, $domain = null, $domain_end = null, $domain_exact = null, $domain_partial = null, $domain_start = null, $id_exact = null, $status_expires = null, $status_in_progress = null, $status_registered = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_domain = null, $_order_id = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getDdiProviderRegistrationCollectionAsyncWithHttpInfo($ddi_provider, $ddi_provider2, $domain, $domain_end, $domain_exact, $domain_partial, $domain_start, $id_exact, $status_expires, $status_in_progress, $status_registered, $username, $username_end, $username_exact, $username_partial, $username_start, $_order_domain, $_order_id, $_order_username, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDdiProviderRegistrationCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of DdiProviderRegistration resources.
     *
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  string $domain (optional)
     * @param  string $domain_end (optional)
     * @param  string $domain_exact (optional)
     * @param  string $domain_partial (optional)
     * @param  string $domain_start (optional)
     * @param  int $id_exact (optional)
     * @param  int $status_expires (optional)
     * @param  bool $status_in_progress (optional)
     * @param  bool $status_registered (optional)
     * @param  string $username (optional)
     * @param  string $username_end (optional)
     * @param  string $username_exact (optional)
     * @param  string $username_partial (optional)
     * @param  string $username_start (optional)
     * @param  string $_order_domain (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderRegistrationCollectionAsyncWithHttpInfo($ddi_provider = null, $ddi_provider2 = null, $domain = null, $domain_end = null, $domain_exact = null, $domain_partial = null, $domain_start = null, $id_exact = null, $status_expires = null, $status_in_progress = null, $status_registered = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_domain = null, $_order_id = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderRegistrationDetailedCollection[]';
        $request = $this->getDdiProviderRegistrationCollectionRequest($ddi_provider, $ddi_provider2, $domain, $domain_end, $domain_exact, $domain_partial, $domain_start, $id_exact, $status_expires, $status_in_progress, $status_registered, $username, $username_end, $username_exact, $username_partial, $username_start, $_order_domain, $_order_id, $_order_username, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDdiProviderRegistrationCollection'
     *
     * @param  string $ddi_provider (optional)
     * @param  string $ddi_provider2 (optional)
     * @param  string $domain (optional)
     * @param  string $domain_end (optional)
     * @param  string $domain_exact (optional)
     * @param  string $domain_partial (optional)
     * @param  string $domain_start (optional)
     * @param  int $id_exact (optional)
     * @param  int $status_expires (optional)
     * @param  bool $status_in_progress (optional)
     * @param  bool $status_registered (optional)
     * @param  string $username (optional)
     * @param  string $username_end (optional)
     * @param  string $username_exact (optional)
     * @param  string $username_partial (optional)
     * @param  string $username_start (optional)
     * @param  string $_order_domain (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_username (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDdiProviderRegistrationCollectionRequest($ddi_provider = null, $ddi_provider2 = null, $domain = null, $domain_end = null, $domain_exact = null, $domain_partial = null, $domain_start = null, $id_exact = null, $status_expires = null, $status_in_progress = null, $status_registered = null, $username = null, $username_end = null, $username_exact = null, $username_partial = null, $username_start = null, $_order_domain = null, $_order_id = null, $_order_username = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/ddi_provider_registrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ddi_provider !== null) {
            $queryParams['ddiProvider'] = ObjectSerializer::toQueryValue($ddi_provider);
        }
        // query params
        if ($ddi_provider2 !== null) {
            $queryParams['ddiProvider[]'] = ObjectSerializer::toQueryValue($ddi_provider2);
        }
        // query params
        if ($domain !== null) {
            $queryParams['domain'] = ObjectSerializer::toQueryValue($domain);
        }
        // query params
        if ($domain_end !== null) {
            $queryParams['domain[end]'] = ObjectSerializer::toQueryValue($domain_end);
        }
        // query params
        if ($domain_exact !== null) {
            $queryParams['domain[exact]'] = ObjectSerializer::toQueryValue($domain_exact);
        }
        // query params
        if ($domain_partial !== null) {
            $queryParams['domain[partial]'] = ObjectSerializer::toQueryValue($domain_partial);
        }
        // query params
        if ($domain_start !== null) {
            $queryParams['domain[start]'] = ObjectSerializer::toQueryValue($domain_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($status_expires !== null) {
            $queryParams['status.expires'] = ObjectSerializer::toQueryValue($status_expires);
        }
        // query params
        if ($status_in_progress !== null) {
            $queryParams['status.inProgress'] = ObjectSerializer::toQueryValue($status_in_progress);
        }
        // query params
        if ($status_registered !== null) {
            $queryParams['status.registered'] = ObjectSerializer::toQueryValue($status_registered);
        }
        // query params
        if ($username !== null) {
            $queryParams['username'] = ObjectSerializer::toQueryValue($username);
        }
        // query params
        if ($username_end !== null) {
            $queryParams['username[end]'] = ObjectSerializer::toQueryValue($username_end);
        }
        // query params
        if ($username_exact !== null) {
            $queryParams['username[exact]'] = ObjectSerializer::toQueryValue($username_exact);
        }
        // query params
        if ($username_partial !== null) {
            $queryParams['username[partial]'] = ObjectSerializer::toQueryValue($username_partial);
        }
        // query params
        if ($username_start !== null) {
            $queryParams['username[start]'] = ObjectSerializer::toQueryValue($username_start);
        }
        // query params
        if ($_order_domain !== null) {
            $queryParams['_order[domain]'] = ObjectSerializer::toQueryValue($_order_domain);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_username !== null) {
            $queryParams['_order[username]'] = ObjectSerializer::toQueryValue($_order_username);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDdiProviderRegistrationItem
     *
     * Retrieves a DdiProviderRegistration resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderRegistrationDetailed
     */
    public function getDdiProviderRegistrationItem($id)
    {
        list($response) = $this->getDdiProviderRegistrationItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDdiProviderRegistrationItemWithHttpInfo
     *
     * Retrieves a DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderRegistrationDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDdiProviderRegistrationItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderRegistrationDetailed';
        $request = $this->getDdiProviderRegistrationItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderRegistrationDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDdiProviderRegistrationItemAsync
     *
     * Retrieves a DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderRegistrationItemAsync($id)
    {
        return $this->getDdiProviderRegistrationItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDdiProviderRegistrationItemAsyncWithHttpInfo
     *
     * Retrieves a DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDdiProviderRegistrationItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderRegistrationDetailed';
        $request = $this->getDdiProviderRegistrationItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDdiProviderRegistrationItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDdiProviderRegistrationItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDdiProviderRegistrationItem'
            );
        }

        $resourcePath = '/ddi_provider_registrations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinationCollection
     *
     * Retrieves the collection of Destination resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  bool $name_ca_exists name_ca_exists (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  bool $name_en_exists name_en_exists (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  bool $name_es_exists name_es_exists (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  bool $name_it_exists name_it_exists (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $prefix prefix (optional)
     * @param  string $prefix_end prefix_end (optional)
     * @param  string $prefix_exact prefix_exact (optional)
     * @param  string $prefix_partial prefix_partial (optional)
     * @param  string $prefix_start prefix_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  string $_order_prefix _order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationCollection[]
     */
    public function getDestinationCollection($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getDestinationCollectionWithHttpInfo($id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $prefix, $prefix_end, $prefix_exact, $prefix_partial, $prefix_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_prefix, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getDestinationCollectionWithHttpInfo
     *
     * Retrieves the collection of Destination resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $prefix (optional)
     * @param  string $prefix_end (optional)
     * @param  string $prefix_exact (optional)
     * @param  string $prefix_partial (optional)
     * @param  string $prefix_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinationCollectionWithHttpInfo($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationCollection[]';
        $request = $this->getDestinationCollectionRequest($id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $prefix, $prefix_end, $prefix_exact, $prefix_partial, $prefix_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_prefix, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinationCollectionAsync
     *
     * Retrieves the collection of Destination resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $prefix (optional)
     * @param  string $prefix_end (optional)
     * @param  string $prefix_exact (optional)
     * @param  string $prefix_partial (optional)
     * @param  string $prefix_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationCollectionAsync($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getDestinationCollectionAsyncWithHttpInfo($id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $prefix, $prefix_end, $prefix_exact, $prefix_partial, $prefix_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_prefix, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinationCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Destination resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $prefix (optional)
     * @param  string $prefix_end (optional)
     * @param  string $prefix_exact (optional)
     * @param  string $prefix_partial (optional)
     * @param  string $prefix_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationCollectionAsyncWithHttpInfo($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationCollection[]';
        $request = $this->getDestinationCollectionRequest($id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $prefix, $prefix_end, $prefix_exact, $prefix_partial, $prefix_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_prefix, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinationCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $prefix (optional)
     * @param  string $prefix_end (optional)
     * @param  string $prefix_exact (optional)
     * @param  string $prefix_partial (optional)
     * @param  string $prefix_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinationCollectionRequest($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/destinations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_exists !== null) {
            $queryParams['name.ca[exists]'] = ObjectSerializer::toQueryValue($name_ca_exists);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_exists !== null) {
            $queryParams['name.en[exists]'] = ObjectSerializer::toQueryValue($name_en_exists);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_exists !== null) {
            $queryParams['name.es[exists]'] = ObjectSerializer::toQueryValue($name_es_exists);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_exists !== null) {
            $queryParams['name.it[exists]'] = ObjectSerializer::toQueryValue($name_it_exists);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($prefix !== null) {
            $queryParams['prefix'] = ObjectSerializer::toQueryValue($prefix);
        }
        // query params
        if ($prefix_end !== null) {
            $queryParams['prefix[end]'] = ObjectSerializer::toQueryValue($prefix_end);
        }
        // query params
        if ($prefix_exact !== null) {
            $queryParams['prefix[exact]'] = ObjectSerializer::toQueryValue($prefix_exact);
        }
        // query params
        if ($prefix_partial !== null) {
            $queryParams['prefix[partial]'] = ObjectSerializer::toQueryValue($prefix_partial);
        }
        // query params
        if ($prefix_start !== null) {
            $queryParams['prefix[start]'] = ObjectSerializer::toQueryValue($prefix_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_order_prefix !== null) {
            $queryParams['_order[prefix]'] = ObjectSerializer::toQueryValue($_order_prefix);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinationItem
     *
     * Retrieves a Destination resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationDetailed
     */
    public function getDestinationItem($id)
    {
        list($response) = $this->getDestinationItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDestinationItemWithHttpInfo
     *
     * Retrieves a Destination resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinationItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DestinationDetailed';
        $request = $this->getDestinationItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinationItemAsync
     *
     * Retrieves a Destination resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationItemAsync($id)
    {
        return $this->getDestinationItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinationItemAsyncWithHttpInfo
     *
     * Retrieves a Destination resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DestinationDetailed';
        $request = $this->getDestinationItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinationItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinationItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDestinationItem'
            );
        }

        $resourcePath = '/destinations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinationRateCollection
     *
     * Retrieves the collection of DestinationRate resources.
     *
     * @param  string $connect_fee connect_fee (optional)
     * @param  string $connect_fee_between connect_fee_between (optional)
     * @param  string $connect_fee_gt connect_fee_gt (optional)
     * @param  string $connect_fee_gte connect_fee_gte (optional)
     * @param  string $connect_fee_lt connect_fee_lt (optional)
     * @param  string $connect_fee_lte connect_fee_lte (optional)
     * @param  string $cost cost (optional)
     * @param  string $cost_between cost_between (optional)
     * @param  string $cost_gt cost_gt (optional)
     * @param  string $cost_gte cost_gte (optional)
     * @param  string $cost_lt cost_lt (optional)
     * @param  string $cost_lte cost_lte (optional)
     * @param  string $destination destination (optional)
     * @param  string $destination_rate_group destination_rate_group (optional)
     * @param  string $destination_rate_group2 destination_rate_group2 (optional)
     * @param  string $destination2 destination2 (optional)
     * @param  string $group_interval_start group_interval_start (optional)
     * @param  string $group_interval_start_end group_interval_start_end (optional)
     * @param  string $group_interval_start_exact group_interval_start_exact (optional)
     * @param  string $group_interval_start_partial group_interval_start_partial (optional)
     * @param  string $group_interval_start_start group_interval_start_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $rate_increment rate_increment (optional)
     * @param  string $rate_increment_end rate_increment_end (optional)
     * @param  string $rate_increment_exact rate_increment_exact (optional)
     * @param  string $rate_increment_partial rate_increment_partial (optional)
     * @param  string $rate_increment_start rate_increment_start (optional)
     * @param  string $_order_connect_fee _order_connect_fee (optional)
     * @param  string $_order_cost _order_cost (optional)
     * @param  string $_order_group_interval_start _order_group_interval_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_rate_increment _order_rate_increment (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationRateCollection[]
     */
    public function getDestinationRateCollection($connect_fee = null, $connect_fee_between = null, $connect_fee_gt = null, $connect_fee_gte = null, $connect_fee_lt = null, $connect_fee_lte = null, $cost = null, $cost_between = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $destination = null, $destination_rate_group = null, $destination_rate_group2 = null, $destination2 = null, $group_interval_start = null, $group_interval_start_end = null, $group_interval_start_exact = null, $group_interval_start_partial = null, $group_interval_start_start = null, $id_exact = null, $rate_increment = null, $rate_increment_end = null, $rate_increment_exact = null, $rate_increment_partial = null, $rate_increment_start = null, $_order_connect_fee = null, $_order_cost = null, $_order_group_interval_start = null, $_order_id = null, $_order_rate_increment = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getDestinationRateCollectionWithHttpInfo($connect_fee, $connect_fee_between, $connect_fee_gt, $connect_fee_gte, $connect_fee_lt, $connect_fee_lte, $cost, $cost_between, $cost_gt, $cost_gte, $cost_lt, $cost_lte, $destination, $destination_rate_group, $destination_rate_group2, $destination2, $group_interval_start, $group_interval_start_end, $group_interval_start_exact, $group_interval_start_partial, $group_interval_start_start, $id_exact, $rate_increment, $rate_increment_end, $rate_increment_exact, $rate_increment_partial, $rate_increment_start, $_order_connect_fee, $_order_cost, $_order_group_interval_start, $_order_id, $_order_rate_increment, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getDestinationRateCollectionWithHttpInfo
     *
     * Retrieves the collection of DestinationRate resources.
     *
     * @param  string $connect_fee (optional)
     * @param  string $connect_fee_between (optional)
     * @param  string $connect_fee_gt (optional)
     * @param  string $connect_fee_gte (optional)
     * @param  string $connect_fee_lt (optional)
     * @param  string $connect_fee_lte (optional)
     * @param  string $cost (optional)
     * @param  string $cost_between (optional)
     * @param  string $cost_gt (optional)
     * @param  string $cost_gte (optional)
     * @param  string $cost_lt (optional)
     * @param  string $cost_lte (optional)
     * @param  string $destination (optional)
     * @param  string $destination_rate_group (optional)
     * @param  string $destination_rate_group2 (optional)
     * @param  string $destination2 (optional)
     * @param  string $group_interval_start (optional)
     * @param  string $group_interval_start_end (optional)
     * @param  string $group_interval_start_exact (optional)
     * @param  string $group_interval_start_partial (optional)
     * @param  string $group_interval_start_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $rate_increment (optional)
     * @param  string $rate_increment_end (optional)
     * @param  string $rate_increment_exact (optional)
     * @param  string $rate_increment_partial (optional)
     * @param  string $rate_increment_start (optional)
     * @param  string $_order_connect_fee (optional)
     * @param  string $_order_cost (optional)
     * @param  string $_order_group_interval_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_rate_increment (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationRateCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinationRateCollectionWithHttpInfo($connect_fee = null, $connect_fee_between = null, $connect_fee_gt = null, $connect_fee_gte = null, $connect_fee_lt = null, $connect_fee_lte = null, $cost = null, $cost_between = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $destination = null, $destination_rate_group = null, $destination_rate_group2 = null, $destination2 = null, $group_interval_start = null, $group_interval_start_end = null, $group_interval_start_exact = null, $group_interval_start_partial = null, $group_interval_start_start = null, $id_exact = null, $rate_increment = null, $rate_increment_end = null, $rate_increment_exact = null, $rate_increment_partial = null, $rate_increment_start = null, $_order_connect_fee = null, $_order_cost = null, $_order_group_interval_start = null, $_order_id = null, $_order_rate_increment = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateCollection[]';
        $request = $this->getDestinationRateCollectionRequest($connect_fee, $connect_fee_between, $connect_fee_gt, $connect_fee_gte, $connect_fee_lt, $connect_fee_lte, $cost, $cost_between, $cost_gt, $cost_gte, $cost_lt, $cost_lte, $destination, $destination_rate_group, $destination_rate_group2, $destination2, $group_interval_start, $group_interval_start_end, $group_interval_start_exact, $group_interval_start_partial, $group_interval_start_start, $id_exact, $rate_increment, $rate_increment_end, $rate_increment_exact, $rate_increment_partial, $rate_increment_start, $_order_connect_fee, $_order_cost, $_order_group_interval_start, $_order_id, $_order_rate_increment, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationRateCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinationRateCollectionAsync
     *
     * Retrieves the collection of DestinationRate resources.
     *
     * @param  string $connect_fee (optional)
     * @param  string $connect_fee_between (optional)
     * @param  string $connect_fee_gt (optional)
     * @param  string $connect_fee_gte (optional)
     * @param  string $connect_fee_lt (optional)
     * @param  string $connect_fee_lte (optional)
     * @param  string $cost (optional)
     * @param  string $cost_between (optional)
     * @param  string $cost_gt (optional)
     * @param  string $cost_gte (optional)
     * @param  string $cost_lt (optional)
     * @param  string $cost_lte (optional)
     * @param  string $destination (optional)
     * @param  string $destination_rate_group (optional)
     * @param  string $destination_rate_group2 (optional)
     * @param  string $destination2 (optional)
     * @param  string $group_interval_start (optional)
     * @param  string $group_interval_start_end (optional)
     * @param  string $group_interval_start_exact (optional)
     * @param  string $group_interval_start_partial (optional)
     * @param  string $group_interval_start_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $rate_increment (optional)
     * @param  string $rate_increment_end (optional)
     * @param  string $rate_increment_exact (optional)
     * @param  string $rate_increment_partial (optional)
     * @param  string $rate_increment_start (optional)
     * @param  string $_order_connect_fee (optional)
     * @param  string $_order_cost (optional)
     * @param  string $_order_group_interval_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_rate_increment (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationRateCollectionAsync($connect_fee = null, $connect_fee_between = null, $connect_fee_gt = null, $connect_fee_gte = null, $connect_fee_lt = null, $connect_fee_lte = null, $cost = null, $cost_between = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $destination = null, $destination_rate_group = null, $destination_rate_group2 = null, $destination2 = null, $group_interval_start = null, $group_interval_start_end = null, $group_interval_start_exact = null, $group_interval_start_partial = null, $group_interval_start_start = null, $id_exact = null, $rate_increment = null, $rate_increment_end = null, $rate_increment_exact = null, $rate_increment_partial = null, $rate_increment_start = null, $_order_connect_fee = null, $_order_cost = null, $_order_group_interval_start = null, $_order_id = null, $_order_rate_increment = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getDestinationRateCollectionAsyncWithHttpInfo($connect_fee, $connect_fee_between, $connect_fee_gt, $connect_fee_gte, $connect_fee_lt, $connect_fee_lte, $cost, $cost_between, $cost_gt, $cost_gte, $cost_lt, $cost_lte, $destination, $destination_rate_group, $destination_rate_group2, $destination2, $group_interval_start, $group_interval_start_end, $group_interval_start_exact, $group_interval_start_partial, $group_interval_start_start, $id_exact, $rate_increment, $rate_increment_end, $rate_increment_exact, $rate_increment_partial, $rate_increment_start, $_order_connect_fee, $_order_cost, $_order_group_interval_start, $_order_id, $_order_rate_increment, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinationRateCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of DestinationRate resources.
     *
     * @param  string $connect_fee (optional)
     * @param  string $connect_fee_between (optional)
     * @param  string $connect_fee_gt (optional)
     * @param  string $connect_fee_gte (optional)
     * @param  string $connect_fee_lt (optional)
     * @param  string $connect_fee_lte (optional)
     * @param  string $cost (optional)
     * @param  string $cost_between (optional)
     * @param  string $cost_gt (optional)
     * @param  string $cost_gte (optional)
     * @param  string $cost_lt (optional)
     * @param  string $cost_lte (optional)
     * @param  string $destination (optional)
     * @param  string $destination_rate_group (optional)
     * @param  string $destination_rate_group2 (optional)
     * @param  string $destination2 (optional)
     * @param  string $group_interval_start (optional)
     * @param  string $group_interval_start_end (optional)
     * @param  string $group_interval_start_exact (optional)
     * @param  string $group_interval_start_partial (optional)
     * @param  string $group_interval_start_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $rate_increment (optional)
     * @param  string $rate_increment_end (optional)
     * @param  string $rate_increment_exact (optional)
     * @param  string $rate_increment_partial (optional)
     * @param  string $rate_increment_start (optional)
     * @param  string $_order_connect_fee (optional)
     * @param  string $_order_cost (optional)
     * @param  string $_order_group_interval_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_rate_increment (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationRateCollectionAsyncWithHttpInfo($connect_fee = null, $connect_fee_between = null, $connect_fee_gt = null, $connect_fee_gte = null, $connect_fee_lt = null, $connect_fee_lte = null, $cost = null, $cost_between = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $destination = null, $destination_rate_group = null, $destination_rate_group2 = null, $destination2 = null, $group_interval_start = null, $group_interval_start_end = null, $group_interval_start_exact = null, $group_interval_start_partial = null, $group_interval_start_start = null, $id_exact = null, $rate_increment = null, $rate_increment_end = null, $rate_increment_exact = null, $rate_increment_partial = null, $rate_increment_start = null, $_order_connect_fee = null, $_order_cost = null, $_order_group_interval_start = null, $_order_id = null, $_order_rate_increment = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateCollection[]';
        $request = $this->getDestinationRateCollectionRequest($connect_fee, $connect_fee_between, $connect_fee_gt, $connect_fee_gte, $connect_fee_lt, $connect_fee_lte, $cost, $cost_between, $cost_gt, $cost_gte, $cost_lt, $cost_lte, $destination, $destination_rate_group, $destination_rate_group2, $destination2, $group_interval_start, $group_interval_start_end, $group_interval_start_exact, $group_interval_start_partial, $group_interval_start_start, $id_exact, $rate_increment, $rate_increment_end, $rate_increment_exact, $rate_increment_partial, $rate_increment_start, $_order_connect_fee, $_order_cost, $_order_group_interval_start, $_order_id, $_order_rate_increment, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinationRateCollection'
     *
     * @param  string $connect_fee (optional)
     * @param  string $connect_fee_between (optional)
     * @param  string $connect_fee_gt (optional)
     * @param  string $connect_fee_gte (optional)
     * @param  string $connect_fee_lt (optional)
     * @param  string $connect_fee_lte (optional)
     * @param  string $cost (optional)
     * @param  string $cost_between (optional)
     * @param  string $cost_gt (optional)
     * @param  string $cost_gte (optional)
     * @param  string $cost_lt (optional)
     * @param  string $cost_lte (optional)
     * @param  string $destination (optional)
     * @param  string $destination_rate_group (optional)
     * @param  string $destination_rate_group2 (optional)
     * @param  string $destination2 (optional)
     * @param  string $group_interval_start (optional)
     * @param  string $group_interval_start_end (optional)
     * @param  string $group_interval_start_exact (optional)
     * @param  string $group_interval_start_partial (optional)
     * @param  string $group_interval_start_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $rate_increment (optional)
     * @param  string $rate_increment_end (optional)
     * @param  string $rate_increment_exact (optional)
     * @param  string $rate_increment_partial (optional)
     * @param  string $rate_increment_start (optional)
     * @param  string $_order_connect_fee (optional)
     * @param  string $_order_cost (optional)
     * @param  string $_order_group_interval_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_rate_increment (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinationRateCollectionRequest($connect_fee = null, $connect_fee_between = null, $connect_fee_gt = null, $connect_fee_gte = null, $connect_fee_lt = null, $connect_fee_lte = null, $cost = null, $cost_between = null, $cost_gt = null, $cost_gte = null, $cost_lt = null, $cost_lte = null, $destination = null, $destination_rate_group = null, $destination_rate_group2 = null, $destination2 = null, $group_interval_start = null, $group_interval_start_end = null, $group_interval_start_exact = null, $group_interval_start_partial = null, $group_interval_start_start = null, $id_exact = null, $rate_increment = null, $rate_increment_end = null, $rate_increment_exact = null, $rate_increment_partial = null, $rate_increment_start = null, $_order_connect_fee = null, $_order_cost = null, $_order_group_interval_start = null, $_order_id = null, $_order_rate_increment = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/destination_rates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($connect_fee !== null) {
            $queryParams['connectFee'] = ObjectSerializer::toQueryValue($connect_fee);
        }
        // query params
        if ($connect_fee_between !== null) {
            $queryParams['connectFee[between]'] = ObjectSerializer::toQueryValue($connect_fee_between);
        }
        // query params
        if ($connect_fee_gt !== null) {
            $queryParams['connectFee[gt]'] = ObjectSerializer::toQueryValue($connect_fee_gt);
        }
        // query params
        if ($connect_fee_gte !== null) {
            $queryParams['connectFee[gte]'] = ObjectSerializer::toQueryValue($connect_fee_gte);
        }
        // query params
        if ($connect_fee_lt !== null) {
            $queryParams['connectFee[lt]'] = ObjectSerializer::toQueryValue($connect_fee_lt);
        }
        // query params
        if ($connect_fee_lte !== null) {
            $queryParams['connectFee[lte]'] = ObjectSerializer::toQueryValue($connect_fee_lte);
        }
        // query params
        if ($cost !== null) {
            $queryParams['cost'] = ObjectSerializer::toQueryValue($cost);
        }
        // query params
        if ($cost_between !== null) {
            $queryParams['cost[between]'] = ObjectSerializer::toQueryValue($cost_between);
        }
        // query params
        if ($cost_gt !== null) {
            $queryParams['cost[gt]'] = ObjectSerializer::toQueryValue($cost_gt);
        }
        // query params
        if ($cost_gte !== null) {
            $queryParams['cost[gte]'] = ObjectSerializer::toQueryValue($cost_gte);
        }
        // query params
        if ($cost_lt !== null) {
            $queryParams['cost[lt]'] = ObjectSerializer::toQueryValue($cost_lt);
        }
        // query params
        if ($cost_lte !== null) {
            $queryParams['cost[lte]'] = ObjectSerializer::toQueryValue($cost_lte);
        }
        // query params
        if ($destination !== null) {
            $queryParams['destination'] = ObjectSerializer::toQueryValue($destination);
        }
        // query params
        if ($destination_rate_group !== null) {
            $queryParams['destinationRateGroup'] = ObjectSerializer::toQueryValue($destination_rate_group);
        }
        // query params
        if ($destination_rate_group2 !== null) {
            $queryParams['destinationRateGroup[]'] = ObjectSerializer::toQueryValue($destination_rate_group2);
        }
        // query params
        if ($destination2 !== null) {
            $queryParams['destination[]'] = ObjectSerializer::toQueryValue($destination2);
        }
        // query params
        if ($group_interval_start !== null) {
            $queryParams['groupIntervalStart'] = ObjectSerializer::toQueryValue($group_interval_start);
        }
        // query params
        if ($group_interval_start_end !== null) {
            $queryParams['groupIntervalStart[end]'] = ObjectSerializer::toQueryValue($group_interval_start_end);
        }
        // query params
        if ($group_interval_start_exact !== null) {
            $queryParams['groupIntervalStart[exact]'] = ObjectSerializer::toQueryValue($group_interval_start_exact);
        }
        // query params
        if ($group_interval_start_partial !== null) {
            $queryParams['groupIntervalStart[partial]'] = ObjectSerializer::toQueryValue($group_interval_start_partial);
        }
        // query params
        if ($group_interval_start_start !== null) {
            $queryParams['groupIntervalStart[start]'] = ObjectSerializer::toQueryValue($group_interval_start_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($rate_increment !== null) {
            $queryParams['rateIncrement'] = ObjectSerializer::toQueryValue($rate_increment);
        }
        // query params
        if ($rate_increment_end !== null) {
            $queryParams['rateIncrement[end]'] = ObjectSerializer::toQueryValue($rate_increment_end);
        }
        // query params
        if ($rate_increment_exact !== null) {
            $queryParams['rateIncrement[exact]'] = ObjectSerializer::toQueryValue($rate_increment_exact);
        }
        // query params
        if ($rate_increment_partial !== null) {
            $queryParams['rateIncrement[partial]'] = ObjectSerializer::toQueryValue($rate_increment_partial);
        }
        // query params
        if ($rate_increment_start !== null) {
            $queryParams['rateIncrement[start]'] = ObjectSerializer::toQueryValue($rate_increment_start);
        }
        // query params
        if ($_order_connect_fee !== null) {
            $queryParams['_order[connectFee]'] = ObjectSerializer::toQueryValue($_order_connect_fee);
        }
        // query params
        if ($_order_cost !== null) {
            $queryParams['_order[cost]'] = ObjectSerializer::toQueryValue($_order_cost);
        }
        // query params
        if ($_order_group_interval_start !== null) {
            $queryParams['_order[groupIntervalStart]'] = ObjectSerializer::toQueryValue($_order_group_interval_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_rate_increment !== null) {
            $queryParams['_order[rateIncrement]'] = ObjectSerializer::toQueryValue($_order_rate_increment);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinationRateGroupCollection
     *
     * Retrieves the collection of DestinationRateGroup resources.
     *
     * @param  string $currency currency (optional)
     * @param  string $currency2 currency2 (optional)
     * @param  bool $currency_exists currency_exists (optional)
     * @param  string $file_base_name file_base_name (optional)
     * @param  string $file_base_name_end file_base_name_end (optional)
     * @param  string $file_base_name_exact file_base_name_exact (optional)
     * @param  bool $file_base_name_exists file_base_name_exists (optional)
     * @param  string $file_base_name_partial file_base_name_partial (optional)
     * @param  string $file_base_name_start file_base_name_start (optional)
     * @param  int $file_file_size file_file_size (optional)
     * @param  string $file_file_size_between file_file_size_between (optional)
     * @param  bool $file_file_size_exists file_file_size_exists (optional)
     * @param  string $file_file_size_gt file_file_size_gt (optional)
     * @param  string $file_file_size_gte file_file_size_gte (optional)
     * @param  string $file_file_size_lt file_file_size_lt (optional)
     * @param  string $file_file_size_lte file_file_size_lte (optional)
     * @param  string $file_mime_type file_mime_type (optional)
     * @param  string $file_mime_type_end file_mime_type_end (optional)
     * @param  string $file_mime_type_exact file_mime_type_exact (optional)
     * @param  bool $file_mime_type_exists file_mime_type_exists (optional)
     * @param  string $file_mime_type_partial file_mime_type_partial (optional)
     * @param  string $file_mime_type_start file_mime_type_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $status status (optional)
     * @param  string $status_end status_end (optional)
     * @param  string $status_exact status_exact (optional)
     * @param  bool $status_exists status_exists (optional)
     * @param  string $status_partial status_partial (optional)
     * @param  string $status_start status_start (optional)
     * @param  string $_order_file_base_name _order_file_base_name (optional)
     * @param  string $_order_file_file_size _order_file_file_size (optional)
     * @param  string $_order_file_importer_arguments _order_file_importer_arguments (optional)
     * @param  string $_order_file_mime_type _order_file_mime_type (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  string $_order_status _order_status (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationRateGroupCollection[]
     */
    public function getDestinationRateGroupCollection($currency = null, $currency2 = null, $currency_exists = null, $file_base_name = null, $file_base_name_end = null, $file_base_name_exact = null, $file_base_name_exists = null, $file_base_name_partial = null, $file_base_name_start = null, $file_file_size = null, $file_file_size_between = null, $file_file_size_exists = null, $file_file_size_gt = null, $file_file_size_gte = null, $file_file_size_lt = null, $file_file_size_lte = null, $file_mime_type = null, $file_mime_type_end = null, $file_mime_type_exact = null, $file_mime_type_exists = null, $file_mime_type_partial = null, $file_mime_type_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $_order_file_base_name = null, $_order_file_file_size = null, $_order_file_importer_arguments = null, $_order_file_mime_type = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_status = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getDestinationRateGroupCollectionWithHttpInfo($currency, $currency2, $currency_exists, $file_base_name, $file_base_name_end, $file_base_name_exact, $file_base_name_exists, $file_base_name_partial, $file_base_name_start, $file_file_size, $file_file_size_between, $file_file_size_exists, $file_file_size_gt, $file_file_size_gte, $file_file_size_lt, $file_file_size_lte, $file_mime_type, $file_mime_type_end, $file_mime_type_exact, $file_mime_type_exists, $file_mime_type_partial, $file_mime_type_start, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $status, $status_end, $status_exact, $status_exists, $status_partial, $status_start, $_order_file_base_name, $_order_file_file_size, $_order_file_importer_arguments, $_order_file_mime_type, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_status, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getDestinationRateGroupCollectionWithHttpInfo
     *
     * Retrieves the collection of DestinationRateGroup resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $file_base_name (optional)
     * @param  string $file_base_name_end (optional)
     * @param  string $file_base_name_exact (optional)
     * @param  bool $file_base_name_exists (optional)
     * @param  string $file_base_name_partial (optional)
     * @param  string $file_base_name_start (optional)
     * @param  int $file_file_size (optional)
     * @param  string $file_file_size_between (optional)
     * @param  bool $file_file_size_exists (optional)
     * @param  string $file_file_size_gt (optional)
     * @param  string $file_file_size_gte (optional)
     * @param  string $file_file_size_lt (optional)
     * @param  string $file_file_size_lte (optional)
     * @param  string $file_mime_type (optional)
     * @param  string $file_mime_type_end (optional)
     * @param  string $file_mime_type_exact (optional)
     * @param  bool $file_mime_type_exists (optional)
     * @param  string $file_mime_type_partial (optional)
     * @param  string $file_mime_type_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $status (optional)
     * @param  string $status_end (optional)
     * @param  string $status_exact (optional)
     * @param  bool $status_exists (optional)
     * @param  string $status_partial (optional)
     * @param  string $status_start (optional)
     * @param  string $_order_file_base_name (optional)
     * @param  string $_order_file_file_size (optional)
     * @param  string $_order_file_importer_arguments (optional)
     * @param  string $_order_file_mime_type (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_status (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationRateGroupCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinationRateGroupCollectionWithHttpInfo($currency = null, $currency2 = null, $currency_exists = null, $file_base_name = null, $file_base_name_end = null, $file_base_name_exact = null, $file_base_name_exists = null, $file_base_name_partial = null, $file_base_name_start = null, $file_file_size = null, $file_file_size_between = null, $file_file_size_exists = null, $file_file_size_gt = null, $file_file_size_gte = null, $file_file_size_lt = null, $file_file_size_lte = null, $file_mime_type = null, $file_mime_type_end = null, $file_mime_type_exact = null, $file_mime_type_exists = null, $file_mime_type_partial = null, $file_mime_type_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $_order_file_base_name = null, $_order_file_file_size = null, $_order_file_importer_arguments = null, $_order_file_mime_type = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_status = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateGroupCollection[]';
        $request = $this->getDestinationRateGroupCollectionRequest($currency, $currency2, $currency_exists, $file_base_name, $file_base_name_end, $file_base_name_exact, $file_base_name_exists, $file_base_name_partial, $file_base_name_start, $file_file_size, $file_file_size_between, $file_file_size_exists, $file_file_size_gt, $file_file_size_gte, $file_file_size_lt, $file_file_size_lte, $file_mime_type, $file_mime_type_end, $file_mime_type_exact, $file_mime_type_exists, $file_mime_type_partial, $file_mime_type_start, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $status, $status_end, $status_exact, $status_exists, $status_partial, $status_start, $_order_file_base_name, $_order_file_file_size, $_order_file_importer_arguments, $_order_file_mime_type, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_status, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationRateGroupCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinationRateGroupCollectionAsync
     *
     * Retrieves the collection of DestinationRateGroup resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $file_base_name (optional)
     * @param  string $file_base_name_end (optional)
     * @param  string $file_base_name_exact (optional)
     * @param  bool $file_base_name_exists (optional)
     * @param  string $file_base_name_partial (optional)
     * @param  string $file_base_name_start (optional)
     * @param  int $file_file_size (optional)
     * @param  string $file_file_size_between (optional)
     * @param  bool $file_file_size_exists (optional)
     * @param  string $file_file_size_gt (optional)
     * @param  string $file_file_size_gte (optional)
     * @param  string $file_file_size_lt (optional)
     * @param  string $file_file_size_lte (optional)
     * @param  string $file_mime_type (optional)
     * @param  string $file_mime_type_end (optional)
     * @param  string $file_mime_type_exact (optional)
     * @param  bool $file_mime_type_exists (optional)
     * @param  string $file_mime_type_partial (optional)
     * @param  string $file_mime_type_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $status (optional)
     * @param  string $status_end (optional)
     * @param  string $status_exact (optional)
     * @param  bool $status_exists (optional)
     * @param  string $status_partial (optional)
     * @param  string $status_start (optional)
     * @param  string $_order_file_base_name (optional)
     * @param  string $_order_file_file_size (optional)
     * @param  string $_order_file_importer_arguments (optional)
     * @param  string $_order_file_mime_type (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_status (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationRateGroupCollectionAsync($currency = null, $currency2 = null, $currency_exists = null, $file_base_name = null, $file_base_name_end = null, $file_base_name_exact = null, $file_base_name_exists = null, $file_base_name_partial = null, $file_base_name_start = null, $file_file_size = null, $file_file_size_between = null, $file_file_size_exists = null, $file_file_size_gt = null, $file_file_size_gte = null, $file_file_size_lt = null, $file_file_size_lte = null, $file_mime_type = null, $file_mime_type_end = null, $file_mime_type_exact = null, $file_mime_type_exists = null, $file_mime_type_partial = null, $file_mime_type_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $_order_file_base_name = null, $_order_file_file_size = null, $_order_file_importer_arguments = null, $_order_file_mime_type = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_status = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getDestinationRateGroupCollectionAsyncWithHttpInfo($currency, $currency2, $currency_exists, $file_base_name, $file_base_name_end, $file_base_name_exact, $file_base_name_exists, $file_base_name_partial, $file_base_name_start, $file_file_size, $file_file_size_between, $file_file_size_exists, $file_file_size_gt, $file_file_size_gte, $file_file_size_lt, $file_file_size_lte, $file_mime_type, $file_mime_type_end, $file_mime_type_exact, $file_mime_type_exists, $file_mime_type_partial, $file_mime_type_start, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $status, $status_end, $status_exact, $status_exists, $status_partial, $status_start, $_order_file_base_name, $_order_file_file_size, $_order_file_importer_arguments, $_order_file_mime_type, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_status, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinationRateGroupCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of DestinationRateGroup resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $file_base_name (optional)
     * @param  string $file_base_name_end (optional)
     * @param  string $file_base_name_exact (optional)
     * @param  bool $file_base_name_exists (optional)
     * @param  string $file_base_name_partial (optional)
     * @param  string $file_base_name_start (optional)
     * @param  int $file_file_size (optional)
     * @param  string $file_file_size_between (optional)
     * @param  bool $file_file_size_exists (optional)
     * @param  string $file_file_size_gt (optional)
     * @param  string $file_file_size_gte (optional)
     * @param  string $file_file_size_lt (optional)
     * @param  string $file_file_size_lte (optional)
     * @param  string $file_mime_type (optional)
     * @param  string $file_mime_type_end (optional)
     * @param  string $file_mime_type_exact (optional)
     * @param  bool $file_mime_type_exists (optional)
     * @param  string $file_mime_type_partial (optional)
     * @param  string $file_mime_type_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $status (optional)
     * @param  string $status_end (optional)
     * @param  string $status_exact (optional)
     * @param  bool $status_exists (optional)
     * @param  string $status_partial (optional)
     * @param  string $status_start (optional)
     * @param  string $_order_file_base_name (optional)
     * @param  string $_order_file_file_size (optional)
     * @param  string $_order_file_importer_arguments (optional)
     * @param  string $_order_file_mime_type (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_status (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationRateGroupCollectionAsyncWithHttpInfo($currency = null, $currency2 = null, $currency_exists = null, $file_base_name = null, $file_base_name_end = null, $file_base_name_exact = null, $file_base_name_exists = null, $file_base_name_partial = null, $file_base_name_start = null, $file_file_size = null, $file_file_size_between = null, $file_file_size_exists = null, $file_file_size_gt = null, $file_file_size_gte = null, $file_file_size_lt = null, $file_file_size_lte = null, $file_mime_type = null, $file_mime_type_end = null, $file_mime_type_exact = null, $file_mime_type_exists = null, $file_mime_type_partial = null, $file_mime_type_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $_order_file_base_name = null, $_order_file_file_size = null, $_order_file_importer_arguments = null, $_order_file_mime_type = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_status = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateGroupCollection[]';
        $request = $this->getDestinationRateGroupCollectionRequest($currency, $currency2, $currency_exists, $file_base_name, $file_base_name_end, $file_base_name_exact, $file_base_name_exists, $file_base_name_partial, $file_base_name_start, $file_file_size, $file_file_size_between, $file_file_size_exists, $file_file_size_gt, $file_file_size_gte, $file_file_size_lt, $file_file_size_lte, $file_mime_type, $file_mime_type_end, $file_mime_type_exact, $file_mime_type_exists, $file_mime_type_partial, $file_mime_type_start, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $status, $status_end, $status_exact, $status_exists, $status_partial, $status_start, $_order_file_base_name, $_order_file_file_size, $_order_file_importer_arguments, $_order_file_mime_type, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_status, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinationRateGroupCollection'
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  string $file_base_name (optional)
     * @param  string $file_base_name_end (optional)
     * @param  string $file_base_name_exact (optional)
     * @param  bool $file_base_name_exists (optional)
     * @param  string $file_base_name_partial (optional)
     * @param  string $file_base_name_start (optional)
     * @param  int $file_file_size (optional)
     * @param  string $file_file_size_between (optional)
     * @param  bool $file_file_size_exists (optional)
     * @param  string $file_file_size_gt (optional)
     * @param  string $file_file_size_gte (optional)
     * @param  string $file_file_size_lt (optional)
     * @param  string $file_file_size_lte (optional)
     * @param  string $file_mime_type (optional)
     * @param  string $file_mime_type_end (optional)
     * @param  string $file_mime_type_exact (optional)
     * @param  bool $file_mime_type_exists (optional)
     * @param  string $file_mime_type_partial (optional)
     * @param  string $file_mime_type_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $status (optional)
     * @param  string $status_end (optional)
     * @param  string $status_exact (optional)
     * @param  bool $status_exists (optional)
     * @param  string $status_partial (optional)
     * @param  string $status_start (optional)
     * @param  string $_order_file_base_name (optional)
     * @param  string $_order_file_file_size (optional)
     * @param  string $_order_file_importer_arguments (optional)
     * @param  string $_order_file_mime_type (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_status (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinationRateGroupCollectionRequest($currency = null, $currency2 = null, $currency_exists = null, $file_base_name = null, $file_base_name_end = null, $file_base_name_exact = null, $file_base_name_exists = null, $file_base_name_partial = null, $file_base_name_start = null, $file_file_size = null, $file_file_size_between = null, $file_file_size_exists = null, $file_file_size_gt = null, $file_file_size_gte = null, $file_file_size_lt = null, $file_file_size_lte = null, $file_mime_type = null, $file_mime_type_end = null, $file_mime_type_exact = null, $file_mime_type_exists = null, $file_mime_type_partial = null, $file_mime_type_start = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $_order_file_base_name = null, $_order_file_file_size = null, $_order_file_importer_arguments = null, $_order_file_mime_type = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_status = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/destination_rate_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency);
        }
        // query params
        if ($currency2 !== null) {
            $queryParams['currency[]'] = ObjectSerializer::toQueryValue($currency2);
        }
        // query params
        if ($currency_exists !== null) {
            $queryParams['currency[exists]'] = ObjectSerializer::toQueryValue($currency_exists);
        }
        // query params
        if ($file_base_name !== null) {
            $queryParams['file.baseName'] = ObjectSerializer::toQueryValue($file_base_name);
        }
        // query params
        if ($file_base_name_end !== null) {
            $queryParams['file.baseName[end]'] = ObjectSerializer::toQueryValue($file_base_name_end);
        }
        // query params
        if ($file_base_name_exact !== null) {
            $queryParams['file.baseName[exact]'] = ObjectSerializer::toQueryValue($file_base_name_exact);
        }
        // query params
        if ($file_base_name_exists !== null) {
            $queryParams['file.baseName[exists]'] = ObjectSerializer::toQueryValue($file_base_name_exists);
        }
        // query params
        if ($file_base_name_partial !== null) {
            $queryParams['file.baseName[partial]'] = ObjectSerializer::toQueryValue($file_base_name_partial);
        }
        // query params
        if ($file_base_name_start !== null) {
            $queryParams['file.baseName[start]'] = ObjectSerializer::toQueryValue($file_base_name_start);
        }
        // query params
        if ($file_file_size !== null) {
            $queryParams['file.fileSize'] = ObjectSerializer::toQueryValue($file_file_size);
        }
        // query params
        if ($file_file_size_between !== null) {
            $queryParams['file.fileSize[between]'] = ObjectSerializer::toQueryValue($file_file_size_between);
        }
        // query params
        if ($file_file_size_exists !== null) {
            $queryParams['file.fileSize[exists]'] = ObjectSerializer::toQueryValue($file_file_size_exists);
        }
        // query params
        if ($file_file_size_gt !== null) {
            $queryParams['file.fileSize[gt]'] = ObjectSerializer::toQueryValue($file_file_size_gt);
        }
        // query params
        if ($file_file_size_gte !== null) {
            $queryParams['file.fileSize[gte]'] = ObjectSerializer::toQueryValue($file_file_size_gte);
        }
        // query params
        if ($file_file_size_lt !== null) {
            $queryParams['file.fileSize[lt]'] = ObjectSerializer::toQueryValue($file_file_size_lt);
        }
        // query params
        if ($file_file_size_lte !== null) {
            $queryParams['file.fileSize[lte]'] = ObjectSerializer::toQueryValue($file_file_size_lte);
        }
        // query params
        if ($file_mime_type !== null) {
            $queryParams['file.mimeType'] = ObjectSerializer::toQueryValue($file_mime_type);
        }
        // query params
        if ($file_mime_type_end !== null) {
            $queryParams['file.mimeType[end]'] = ObjectSerializer::toQueryValue($file_mime_type_end);
        }
        // query params
        if ($file_mime_type_exact !== null) {
            $queryParams['file.mimeType[exact]'] = ObjectSerializer::toQueryValue($file_mime_type_exact);
        }
        // query params
        if ($file_mime_type_exists !== null) {
            $queryParams['file.mimeType[exists]'] = ObjectSerializer::toQueryValue($file_mime_type_exists);
        }
        // query params
        if ($file_mime_type_partial !== null) {
            $queryParams['file.mimeType[partial]'] = ObjectSerializer::toQueryValue($file_mime_type_partial);
        }
        // query params
        if ($file_mime_type_start !== null) {
            $queryParams['file.mimeType[start]'] = ObjectSerializer::toQueryValue($file_mime_type_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($status_end !== null) {
            $queryParams['status[end]'] = ObjectSerializer::toQueryValue($status_end);
        }
        // query params
        if ($status_exact !== null) {
            $queryParams['status[exact]'] = ObjectSerializer::toQueryValue($status_exact);
        }
        // query params
        if ($status_exists !== null) {
            $queryParams['status[exists]'] = ObjectSerializer::toQueryValue($status_exists);
        }
        // query params
        if ($status_partial !== null) {
            $queryParams['status[partial]'] = ObjectSerializer::toQueryValue($status_partial);
        }
        // query params
        if ($status_start !== null) {
            $queryParams['status[start]'] = ObjectSerializer::toQueryValue($status_start);
        }
        // query params
        if ($_order_file_base_name !== null) {
            $queryParams['_order[file.baseName]'] = ObjectSerializer::toQueryValue($_order_file_base_name);
        }
        // query params
        if ($_order_file_file_size !== null) {
            $queryParams['_order[file.fileSize]'] = ObjectSerializer::toQueryValue($_order_file_file_size);
        }
        // query params
        if ($_order_file_importer_arguments !== null) {
            $queryParams['_order[file.importerArguments]'] = ObjectSerializer::toQueryValue($_order_file_importer_arguments);
        }
        // query params
        if ($_order_file_mime_type !== null) {
            $queryParams['_order[file.mimeType]'] = ObjectSerializer::toQueryValue($_order_file_mime_type);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_order_status !== null) {
            $queryParams['_order[status]'] = ObjectSerializer::toQueryValue($_order_status);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinationRateGroupItem
     *
     * Retrieves a DestinationRateGroup resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationRateGroupDetailed
     */
    public function getDestinationRateGroupItem($id)
    {
        list($response) = $this->getDestinationRateGroupItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDestinationRateGroupItemWithHttpInfo
     *
     * Retrieves a DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationRateGroupDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinationRateGroupItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateGroupDetailed';
        $request = $this->getDestinationRateGroupItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationRateGroupDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinationRateGroupItemAsync
     *
     * Retrieves a DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationRateGroupItemAsync($id)
    {
        return $this->getDestinationRateGroupItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinationRateGroupItemAsyncWithHttpInfo
     *
     * Retrieves a DestinationRateGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationRateGroupItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateGroupDetailed';
        $request = $this->getDestinationRateGroupItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinationRateGroupItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinationRateGroupItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDestinationRateGroupItem'
            );
        }

        $resourcePath = '/destination_rate_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinationRateItem
     *
     * Retrieves a DestinationRate resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationRateDetailed
     */
    public function getDestinationRateItem($id)
    {
        list($response) = $this->getDestinationRateItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDestinationRateItemWithHttpInfo
     *
     * Retrieves a DestinationRate resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationRateDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinationRateItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateDetailed';
        $request = $this->getDestinationRateItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationRateDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinationRateItemAsync
     *
     * Retrieves a DestinationRate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationRateItemAsync($id)
    {
        return $this->getDestinationRateItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinationRateItemAsyncWithHttpInfo
     *
     * Retrieves a DestinationRate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinationRateItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateDetailed';
        $request = $this->getDestinationRateItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinationRateItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinationRateItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDestinationRateItem'
            );
        }

        $resourcePath = '/destination_rates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFaxCollection
     *
     * Retrieves the collection of Fax resources.
     *
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  string $email email (optional)
     * @param  string $email_end email_end (optional)
     * @param  string $email_exact email_exact (optional)
     * @param  bool $email_exists email_exists (optional)
     * @param  string $email_partial email_partial (optional)
     * @param  string $email_start email_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  bool $send_by_email send_by_email (optional)
     * @param  string $_order_email _order_email (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_send_by_email _order_send_by_email (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FaxCollection[]
     */
    public function getFaxCollection($company = null, $company2 = null, $email = null, $email_end = null, $email_exact = null, $email_exists = null, $email_partial = null, $email_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $send_by_email = null, $_order_email = null, $_order_id = null, $_order_name = null, $_order_send_by_email = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getFaxCollectionWithHttpInfo($company, $company2, $email, $email_end, $email_exact, $email_exists, $email_partial, $email_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $send_by_email, $_order_email, $_order_id, $_order_name, $_order_send_by_email, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getFaxCollectionWithHttpInfo
     *
     * Retrieves the collection of Fax resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  bool $email_exists (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  bool $send_by_email (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_send_by_email (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FaxCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFaxCollectionWithHttpInfo($company = null, $company2 = null, $email = null, $email_end = null, $email_exact = null, $email_exists = null, $email_partial = null, $email_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $send_by_email = null, $_order_email = null, $_order_id = null, $_order_name = null, $_order_send_by_email = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FaxCollection[]';
        $request = $this->getFaxCollectionRequest($company, $company2, $email, $email_end, $email_exact, $email_exists, $email_partial, $email_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $send_by_email, $_order_email, $_order_id, $_order_name, $_order_send_by_email, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FaxCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFaxCollectionAsync
     *
     * Retrieves the collection of Fax resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  bool $email_exists (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  bool $send_by_email (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_send_by_email (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFaxCollectionAsync($company = null, $company2 = null, $email = null, $email_end = null, $email_exact = null, $email_exists = null, $email_partial = null, $email_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $send_by_email = null, $_order_email = null, $_order_id = null, $_order_name = null, $_order_send_by_email = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getFaxCollectionAsyncWithHttpInfo($company, $company2, $email, $email_end, $email_exact, $email_exists, $email_partial, $email_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $send_by_email, $_order_email, $_order_id, $_order_name, $_order_send_by_email, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFaxCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Fax resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  bool $email_exists (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  bool $send_by_email (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_send_by_email (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFaxCollectionAsyncWithHttpInfo($company = null, $company2 = null, $email = null, $email_end = null, $email_exact = null, $email_exists = null, $email_partial = null, $email_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $send_by_email = null, $_order_email = null, $_order_id = null, $_order_name = null, $_order_send_by_email = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FaxCollection[]';
        $request = $this->getFaxCollectionRequest($company, $company2, $email, $email_end, $email_exact, $email_exists, $email_partial, $email_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $send_by_email, $_order_email, $_order_id, $_order_name, $_order_send_by_email, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFaxCollection'
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $email (optional)
     * @param  string $email_end (optional)
     * @param  string $email_exact (optional)
     * @param  bool $email_exists (optional)
     * @param  string $email_partial (optional)
     * @param  string $email_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  bool $send_by_email (optional)
     * @param  string $_order_email (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_send_by_email (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFaxCollectionRequest($company = null, $company2 = null, $email = null, $email_end = null, $email_exact = null, $email_exists = null, $email_partial = null, $email_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $send_by_email = null, $_order_email = null, $_order_id = null, $_order_name = null, $_order_send_by_email = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/faxes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($email_end !== null) {
            $queryParams['email[end]'] = ObjectSerializer::toQueryValue($email_end);
        }
        // query params
        if ($email_exact !== null) {
            $queryParams['email[exact]'] = ObjectSerializer::toQueryValue($email_exact);
        }
        // query params
        if ($email_exists !== null) {
            $queryParams['email[exists]'] = ObjectSerializer::toQueryValue($email_exists);
        }
        // query params
        if ($email_partial !== null) {
            $queryParams['email[partial]'] = ObjectSerializer::toQueryValue($email_partial);
        }
        // query params
        if ($email_start !== null) {
            $queryParams['email[start]'] = ObjectSerializer::toQueryValue($email_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($send_by_email !== null) {
            $queryParams['sendByEmail'] = ObjectSerializer::toQueryValue($send_by_email);
        }
        // query params
        if ($_order_email !== null) {
            $queryParams['_order[email]'] = ObjectSerializer::toQueryValue($_order_email);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_send_by_email !== null) {
            $queryParams['_order[sendByEmail]'] = ObjectSerializer::toQueryValue($_order_send_by_email);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureCollection
     *
     * Retrieves the collection of Feature resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $iden iden (optional)
     * @param  string $iden_end iden_end (optional)
     * @param  string $iden_exact iden_exact (optional)
     * @param  string $iden_partial iden_partial (optional)
     * @param  string $iden_start iden_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_iden _order_iden (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FeatureCollection[]
     */
    public function getFeatureCollection($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $_order_id = null, $_order_iden = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getFeatureCollectionWithHttpInfo($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $_order_id, $_order_iden, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getFeatureCollectionWithHttpInfo
     *
     * Retrieves the collection of Feature resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FeatureCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureCollectionWithHttpInfo($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $_order_id = null, $_order_iden = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FeatureCollection[]';
        $request = $this->getFeatureCollectionRequest($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $_order_id, $_order_iden, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FeatureCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureCollectionAsync
     *
     * Retrieves the collection of Feature resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureCollectionAsync($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $_order_id = null, $_order_iden = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getFeatureCollectionAsyncWithHttpInfo($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $_order_id, $_order_iden, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Feature resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureCollectionAsyncWithHttpInfo($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $_order_id = null, $_order_iden = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FeatureCollection[]';
        $request = $this->getFeatureCollectionRequest($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $_order_id, $_order_iden, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureCollectionRequest($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $_order_id = null, $_order_iden = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/features';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($iden !== null) {
            $queryParams['iden'] = ObjectSerializer::toQueryValue($iden);
        }
        // query params
        if ($iden_end !== null) {
            $queryParams['iden[end]'] = ObjectSerializer::toQueryValue($iden_end);
        }
        // query params
        if ($iden_exact !== null) {
            $queryParams['iden[exact]'] = ObjectSerializer::toQueryValue($iden_exact);
        }
        // query params
        if ($iden_partial !== null) {
            $queryParams['iden[partial]'] = ObjectSerializer::toQueryValue($iden_partial);
        }
        // query params
        if ($iden_start !== null) {
            $queryParams['iden[start]'] = ObjectSerializer::toQueryValue($iden_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_iden !== null) {
            $queryParams['_order[iden]'] = ObjectSerializer::toQueryValue($_order_iden);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureItem
     *
     * Retrieves a Feature resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FeatureDetailed
     */
    public function getFeatureItem($id)
    {
        list($response) = $this->getFeatureItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFeatureItemWithHttpInfo
     *
     * Retrieves a Feature resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FeatureDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FeatureDetailed';
        $request = $this->getFeatureItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FeatureDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureItemAsync
     *
     * Retrieves a Feature resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureItemAsync($id)
    {
        return $this->getFeatureItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureItemAsyncWithHttpInfo
     *
     * Retrieves a Feature resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FeatureDetailed';
        $request = $this->getFeatureItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFeatureItem'
            );
        }

        $resourcePath = '/features/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeaturesRelBrandCollection
     *
     * Retrieves the collection of FeaturesRelBrand resources.
     *
     * @param  string $feature feature (optional)
     * @param  string $feature2 feature2 (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FeaturesRelBrandCollection[]
     */
    public function getFeaturesRelBrandCollection($feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getFeaturesRelBrandCollectionWithHttpInfo($feature, $feature2, $id_exact, $_order_id, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getFeaturesRelBrandCollectionWithHttpInfo
     *
     * Retrieves the collection of FeaturesRelBrand resources.
     *
     * @param  string $feature (optional)
     * @param  string $feature2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FeaturesRelBrandCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeaturesRelBrandCollectionWithHttpInfo($feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelBrandCollection[]';
        $request = $this->getFeaturesRelBrandCollectionRequest($feature, $feature2, $id_exact, $_order_id, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FeaturesRelBrandCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeaturesRelBrandCollectionAsync
     *
     * Retrieves the collection of FeaturesRelBrand resources.
     *
     * @param  string $feature (optional)
     * @param  string $feature2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesRelBrandCollectionAsync($feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getFeaturesRelBrandCollectionAsyncWithHttpInfo($feature, $feature2, $id_exact, $_order_id, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeaturesRelBrandCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of FeaturesRelBrand resources.
     *
     * @param  string $feature (optional)
     * @param  string $feature2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesRelBrandCollectionAsyncWithHttpInfo($feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelBrandCollection[]';
        $request = $this->getFeaturesRelBrandCollectionRequest($feature, $feature2, $id_exact, $_order_id, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeaturesRelBrandCollection'
     *
     * @param  string $feature (optional)
     * @param  string $feature2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeaturesRelBrandCollectionRequest($feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/features_rel_brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($feature !== null) {
            $queryParams['feature'] = ObjectSerializer::toQueryValue($feature);
        }
        // query params
        if ($feature2 !== null) {
            $queryParams['feature[]'] = ObjectSerializer::toQueryValue($feature2);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeaturesRelBrandItem
     *
     * Retrieves a FeaturesRelBrand resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FeaturesRelBrandDetailed
     */
    public function getFeaturesRelBrandItem($id)
    {
        list($response) = $this->getFeaturesRelBrandItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFeaturesRelBrandItemWithHttpInfo
     *
     * Retrieves a FeaturesRelBrand resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FeaturesRelBrandDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeaturesRelBrandItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelBrandDetailed';
        $request = $this->getFeaturesRelBrandItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FeaturesRelBrandDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeaturesRelBrandItemAsync
     *
     * Retrieves a FeaturesRelBrand resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesRelBrandItemAsync($id)
    {
        return $this->getFeaturesRelBrandItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeaturesRelBrandItemAsyncWithHttpInfo
     *
     * Retrieves a FeaturesRelBrand resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesRelBrandItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelBrandDetailed';
        $request = $this->getFeaturesRelBrandItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeaturesRelBrandItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeaturesRelBrandItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFeaturesRelBrandItem'
            );
        }

        $resourcePath = '/features_rel_brands/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeaturesRelCompanyCollection
     *
     * Retrieves the collection of FeaturesRelCompany resources.
     *
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  string $feature feature (optional)
     * @param  string $feature2 feature2 (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FeaturesRelCompanyCollection[]
     */
    public function getFeaturesRelCompanyCollection($company = null, $company2 = null, $feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getFeaturesRelCompanyCollectionWithHttpInfo($company, $company2, $feature, $feature2, $id_exact, $_order_id, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getFeaturesRelCompanyCollectionWithHttpInfo
     *
     * Retrieves the collection of FeaturesRelCompany resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $feature (optional)
     * @param  string $feature2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FeaturesRelCompanyCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeaturesRelCompanyCollectionWithHttpInfo($company = null, $company2 = null, $feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelCompanyCollection[]';
        $request = $this->getFeaturesRelCompanyCollectionRequest($company, $company2, $feature, $feature2, $id_exact, $_order_id, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FeaturesRelCompanyCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeaturesRelCompanyCollectionAsync
     *
     * Retrieves the collection of FeaturesRelCompany resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $feature (optional)
     * @param  string $feature2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesRelCompanyCollectionAsync($company = null, $company2 = null, $feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getFeaturesRelCompanyCollectionAsyncWithHttpInfo($company, $company2, $feature, $feature2, $id_exact, $_order_id, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeaturesRelCompanyCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of FeaturesRelCompany resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $feature (optional)
     * @param  string $feature2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesRelCompanyCollectionAsyncWithHttpInfo($company = null, $company2 = null, $feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelCompanyCollection[]';
        $request = $this->getFeaturesRelCompanyCollectionRequest($company, $company2, $feature, $feature2, $id_exact, $_order_id, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeaturesRelCompanyCollection'
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $feature (optional)
     * @param  string $feature2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeaturesRelCompanyCollectionRequest($company = null, $company2 = null, $feature = null, $feature2 = null, $id_exact = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/features_rel_companies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($feature !== null) {
            $queryParams['feature'] = ObjectSerializer::toQueryValue($feature);
        }
        // query params
        if ($feature2 !== null) {
            $queryParams['feature[]'] = ObjectSerializer::toQueryValue($feature2);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeaturesRelCompanyItem
     *
     * Retrieves a FeaturesRelCompany resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FeaturesRelCompanyDetailed
     */
    public function getFeaturesRelCompanyItem($id)
    {
        list($response) = $this->getFeaturesRelCompanyItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFeaturesRelCompanyItemWithHttpInfo
     *
     * Retrieves a FeaturesRelCompany resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FeaturesRelCompanyDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeaturesRelCompanyItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelCompanyDetailed';
        $request = $this->getFeaturesRelCompanyItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FeaturesRelCompanyDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeaturesRelCompanyItemAsync
     *
     * Retrieves a FeaturesRelCompany resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesRelCompanyItemAsync($id)
    {
        return $this->getFeaturesRelCompanyItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeaturesRelCompanyItemAsyncWithHttpInfo
     *
     * Retrieves a FeaturesRelCompany resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesRelCompanyItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelCompanyDetailed';
        $request = $this->getFeaturesRelCompanyItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeaturesRelCompanyItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeaturesRelCompanyItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFeaturesRelCompanyItem'
            );
        }

        $resourcePath = '/features_rel_companies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFixedCostCollection
     *
     * Retrieves the collection of FixedCost resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostCollection[]
     */
    public function getFixedCostCollection($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getFixedCostCollectionWithHttpInfo($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getFixedCostCollectionWithHttpInfo
     *
     * Retrieves the collection of FixedCost resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFixedCostCollectionWithHttpInfo($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostCollection[]';
        $request = $this->getFixedCostCollectionRequest($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFixedCostCollectionAsync
     *
     * Retrieves the collection of FixedCost resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostCollectionAsync($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getFixedCostCollectionAsyncWithHttpInfo($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFixedCostCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of FixedCost resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostCollectionAsyncWithHttpInfo($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostCollection[]';
        $request = $this->getFixedCostCollectionRequest($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFixedCostCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFixedCostCollectionRequest($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/fixed_costs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFixedCostItem
     *
     * Retrieves a FixedCost resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostDetailed
     */
    public function getFixedCostItem($id)
    {
        list($response) = $this->getFixedCostItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFixedCostItemWithHttpInfo
     *
     * Retrieves a FixedCost resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFixedCostItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FixedCostDetailed';
        $request = $this->getFixedCostItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFixedCostItemAsync
     *
     * Retrieves a FixedCost resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostItemAsync($id)
    {
        return $this->getFixedCostItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFixedCostItemAsyncWithHttpInfo
     *
     * Retrieves a FixedCost resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FixedCostDetailed';
        $request = $this->getFixedCostItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFixedCostItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFixedCostItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFixedCostItem'
            );
        }

        $resourcePath = '/fixed_costs/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFixedCostsRelInvoiceCollection
     *
     * Retrieves the collection of FixedCostsRelInvoice resources.
     *
     * @param  string $fixed_cost fixed_cost (optional)
     * @param  float $fixed_cost_cost fixed_cost_cost (optional)
     * @param  string $fixed_cost_description fixed_cost_description (optional)
     * @param  string $fixed_cost_name fixed_cost_name (optional)
     * @param  string $fixed_cost2 fixed_cost2 (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $invoice invoice (optional)
     * @param  int $invoice_company invoice_company (optional)
     * @param  string $invoice_in_date invoice_in_date (optional)
     * @param  int $invoice_invoice_template invoice_invoice_template (optional)
     * @param  string $invoice_number invoice_number (optional)
     * @param  int $invoice_number_sequence invoice_number_sequence (optional)
     * @param  string $invoice_out_date invoice_out_date (optional)
     * @param  int $invoice_scheduler invoice_scheduler (optional)
     * @param  string $invoice_status invoice_status (optional)
     * @param  string $invoice_status_msg invoice_status_msg (optional)
     * @param  float $invoice_tax_rate invoice_tax_rate (optional)
     * @param  float $invoice_total invoice_total (optional)
     * @param  float $invoice_total_with_tax invoice_total_with_tax (optional)
     * @param  string $invoice2 invoice2 (optional)
     * @param  int $quantity quantity (optional)
     * @param  string $quantity_between quantity_between (optional)
     * @param  bool $quantity_exists quantity_exists (optional)
     * @param  string $quantity_gt quantity_gt (optional)
     * @param  string $quantity_gte quantity_gte (optional)
     * @param  string $quantity_lt quantity_lt (optional)
     * @param  string $quantity_lte quantity_lte (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_quantity _order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostsRelInvoiceDetailedCollection[]
     */
    public function getFixedCostsRelInvoiceCollection($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice = null, $invoice_company = null, $invoice_in_date = null, $invoice_invoice_template = null, $invoice_number = null, $invoice_number_sequence = null, $invoice_out_date = null, $invoice_scheduler = null, $invoice_status = null, $invoice_status_msg = null, $invoice_tax_rate = null, $invoice_total = null, $invoice_total_with_tax = null, $invoice2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getFixedCostsRelInvoiceCollectionWithHttpInfo($fixed_cost, $fixed_cost_cost, $fixed_cost_description, $fixed_cost_name, $fixed_cost2, $id_exact, $invoice, $invoice_company, $invoice_in_date, $invoice_invoice_template, $invoice_number, $invoice_number_sequence, $invoice_out_date, $invoice_scheduler, $invoice_status, $invoice_status_msg, $invoice_tax_rate, $invoice_total, $invoice_total_with_tax, $invoice2, $quantity, $quantity_between, $quantity_exists, $quantity_gt, $quantity_gte, $quantity_lt, $quantity_lte, $_order_id, $_order_quantity, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getFixedCostsRelInvoiceCollectionWithHttpInfo
     *
     * Retrieves the collection of FixedCostsRelInvoice resources.
     *
     * @param  string $fixed_cost (optional)
     * @param  float $fixed_cost_cost (optional)
     * @param  string $fixed_cost_description (optional)
     * @param  string $fixed_cost_name (optional)
     * @param  string $fixed_cost2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice (optional)
     * @param  int $invoice_company (optional)
     * @param  string $invoice_in_date (optional)
     * @param  int $invoice_invoice_template (optional)
     * @param  string $invoice_number (optional)
     * @param  int $invoice_number_sequence (optional)
     * @param  string $invoice_out_date (optional)
     * @param  int $invoice_scheduler (optional)
     * @param  string $invoice_status (optional)
     * @param  string $invoice_status_msg (optional)
     * @param  float $invoice_tax_rate (optional)
     * @param  float $invoice_total (optional)
     * @param  float $invoice_total_with_tax (optional)
     * @param  string $invoice2 (optional)
     * @param  int $quantity (optional)
     * @param  string $quantity_between (optional)
     * @param  bool $quantity_exists (optional)
     * @param  string $quantity_gt (optional)
     * @param  string $quantity_gte (optional)
     * @param  string $quantity_lt (optional)
     * @param  string $quantity_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostsRelInvoiceDetailedCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFixedCostsRelInvoiceCollectionWithHttpInfo($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice = null, $invoice_company = null, $invoice_in_date = null, $invoice_invoice_template = null, $invoice_number = null, $invoice_number_sequence = null, $invoice_out_date = null, $invoice_scheduler = null, $invoice_status = null, $invoice_status_msg = null, $invoice_tax_rate = null, $invoice_total = null, $invoice_total_with_tax = null, $invoice2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceDetailedCollection[]';
        $request = $this->getFixedCostsRelInvoiceCollectionRequest($fixed_cost, $fixed_cost_cost, $fixed_cost_description, $fixed_cost_name, $fixed_cost2, $id_exact, $invoice, $invoice_company, $invoice_in_date, $invoice_invoice_template, $invoice_number, $invoice_number_sequence, $invoice_out_date, $invoice_scheduler, $invoice_status, $invoice_status_msg, $invoice_tax_rate, $invoice_total, $invoice_total_with_tax, $invoice2, $quantity, $quantity_between, $quantity_exists, $quantity_gt, $quantity_gte, $quantity_lt, $quantity_lte, $_order_id, $_order_quantity, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostsRelInvoiceDetailedCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFixedCostsRelInvoiceCollectionAsync
     *
     * Retrieves the collection of FixedCostsRelInvoice resources.
     *
     * @param  string $fixed_cost (optional)
     * @param  float $fixed_cost_cost (optional)
     * @param  string $fixed_cost_description (optional)
     * @param  string $fixed_cost_name (optional)
     * @param  string $fixed_cost2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice (optional)
     * @param  int $invoice_company (optional)
     * @param  string $invoice_in_date (optional)
     * @param  int $invoice_invoice_template (optional)
     * @param  string $invoice_number (optional)
     * @param  int $invoice_number_sequence (optional)
     * @param  string $invoice_out_date (optional)
     * @param  int $invoice_scheduler (optional)
     * @param  string $invoice_status (optional)
     * @param  string $invoice_status_msg (optional)
     * @param  float $invoice_tax_rate (optional)
     * @param  float $invoice_total (optional)
     * @param  float $invoice_total_with_tax (optional)
     * @param  string $invoice2 (optional)
     * @param  int $quantity (optional)
     * @param  string $quantity_between (optional)
     * @param  bool $quantity_exists (optional)
     * @param  string $quantity_gt (optional)
     * @param  string $quantity_gte (optional)
     * @param  string $quantity_lt (optional)
     * @param  string $quantity_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostsRelInvoiceCollectionAsync($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice = null, $invoice_company = null, $invoice_in_date = null, $invoice_invoice_template = null, $invoice_number = null, $invoice_number_sequence = null, $invoice_out_date = null, $invoice_scheduler = null, $invoice_status = null, $invoice_status_msg = null, $invoice_tax_rate = null, $invoice_total = null, $invoice_total_with_tax = null, $invoice2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getFixedCostsRelInvoiceCollectionAsyncWithHttpInfo($fixed_cost, $fixed_cost_cost, $fixed_cost_description, $fixed_cost_name, $fixed_cost2, $id_exact, $invoice, $invoice_company, $invoice_in_date, $invoice_invoice_template, $invoice_number, $invoice_number_sequence, $invoice_out_date, $invoice_scheduler, $invoice_status, $invoice_status_msg, $invoice_tax_rate, $invoice_total, $invoice_total_with_tax, $invoice2, $quantity, $quantity_between, $quantity_exists, $quantity_gt, $quantity_gte, $quantity_lt, $quantity_lte, $_order_id, $_order_quantity, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFixedCostsRelInvoiceCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of FixedCostsRelInvoice resources.
     *
     * @param  string $fixed_cost (optional)
     * @param  float $fixed_cost_cost (optional)
     * @param  string $fixed_cost_description (optional)
     * @param  string $fixed_cost_name (optional)
     * @param  string $fixed_cost2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice (optional)
     * @param  int $invoice_company (optional)
     * @param  string $invoice_in_date (optional)
     * @param  int $invoice_invoice_template (optional)
     * @param  string $invoice_number (optional)
     * @param  int $invoice_number_sequence (optional)
     * @param  string $invoice_out_date (optional)
     * @param  int $invoice_scheduler (optional)
     * @param  string $invoice_status (optional)
     * @param  string $invoice_status_msg (optional)
     * @param  float $invoice_tax_rate (optional)
     * @param  float $invoice_total (optional)
     * @param  float $invoice_total_with_tax (optional)
     * @param  string $invoice2 (optional)
     * @param  int $quantity (optional)
     * @param  string $quantity_between (optional)
     * @param  bool $quantity_exists (optional)
     * @param  string $quantity_gt (optional)
     * @param  string $quantity_gte (optional)
     * @param  string $quantity_lt (optional)
     * @param  string $quantity_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostsRelInvoiceCollectionAsyncWithHttpInfo($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice = null, $invoice_company = null, $invoice_in_date = null, $invoice_invoice_template = null, $invoice_number = null, $invoice_number_sequence = null, $invoice_out_date = null, $invoice_scheduler = null, $invoice_status = null, $invoice_status_msg = null, $invoice_tax_rate = null, $invoice_total = null, $invoice_total_with_tax = null, $invoice2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceDetailedCollection[]';
        $request = $this->getFixedCostsRelInvoiceCollectionRequest($fixed_cost, $fixed_cost_cost, $fixed_cost_description, $fixed_cost_name, $fixed_cost2, $id_exact, $invoice, $invoice_company, $invoice_in_date, $invoice_invoice_template, $invoice_number, $invoice_number_sequence, $invoice_out_date, $invoice_scheduler, $invoice_status, $invoice_status_msg, $invoice_tax_rate, $invoice_total, $invoice_total_with_tax, $invoice2, $quantity, $quantity_between, $quantity_exists, $quantity_gt, $quantity_gte, $quantity_lt, $quantity_lte, $_order_id, $_order_quantity, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFixedCostsRelInvoiceCollection'
     *
     * @param  string $fixed_cost (optional)
     * @param  float $fixed_cost_cost (optional)
     * @param  string $fixed_cost_description (optional)
     * @param  string $fixed_cost_name (optional)
     * @param  string $fixed_cost2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice (optional)
     * @param  int $invoice_company (optional)
     * @param  string $invoice_in_date (optional)
     * @param  int $invoice_invoice_template (optional)
     * @param  string $invoice_number (optional)
     * @param  int $invoice_number_sequence (optional)
     * @param  string $invoice_out_date (optional)
     * @param  int $invoice_scheduler (optional)
     * @param  string $invoice_status (optional)
     * @param  string $invoice_status_msg (optional)
     * @param  float $invoice_tax_rate (optional)
     * @param  float $invoice_total (optional)
     * @param  float $invoice_total_with_tax (optional)
     * @param  string $invoice2 (optional)
     * @param  int $quantity (optional)
     * @param  string $quantity_between (optional)
     * @param  bool $quantity_exists (optional)
     * @param  string $quantity_gt (optional)
     * @param  string $quantity_gte (optional)
     * @param  string $quantity_lt (optional)
     * @param  string $quantity_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFixedCostsRelInvoiceCollectionRequest($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice = null, $invoice_company = null, $invoice_in_date = null, $invoice_invoice_template = null, $invoice_number = null, $invoice_number_sequence = null, $invoice_out_date = null, $invoice_scheduler = null, $invoice_status = null, $invoice_status_msg = null, $invoice_tax_rate = null, $invoice_total = null, $invoice_total_with_tax = null, $invoice2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/fixed_costs_rel_invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fixed_cost !== null) {
            $queryParams['fixedCost'] = ObjectSerializer::toQueryValue($fixed_cost);
        }
        // query params
        if ($fixed_cost_cost !== null) {
            $queryParams['fixedCost.cost'] = ObjectSerializer::toQueryValue($fixed_cost_cost);
        }
        // query params
        if ($fixed_cost_description !== null) {
            $queryParams['fixedCost.description'] = ObjectSerializer::toQueryValue($fixed_cost_description);
        }
        // query params
        if ($fixed_cost_name !== null) {
            $queryParams['fixedCost.name'] = ObjectSerializer::toQueryValue($fixed_cost_name);
        }
        // query params
        if ($fixed_cost2 !== null) {
            $queryParams['fixedCost[]'] = ObjectSerializer::toQueryValue($fixed_cost2);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($invoice !== null) {
            $queryParams['invoice'] = ObjectSerializer::toQueryValue($invoice);
        }
        // query params
        if ($invoice_company !== null) {
            $queryParams['invoice.company'] = ObjectSerializer::toQueryValue($invoice_company);
        }
        // query params
        if ($invoice_in_date !== null) {
            $queryParams['invoice.inDate'] = ObjectSerializer::toQueryValue($invoice_in_date);
        }
        // query params
        if ($invoice_invoice_template !== null) {
            $queryParams['invoice.invoiceTemplate'] = ObjectSerializer::toQueryValue($invoice_invoice_template);
        }
        // query params
        if ($invoice_number !== null) {
            $queryParams['invoice.number'] = ObjectSerializer::toQueryValue($invoice_number);
        }
        // query params
        if ($invoice_number_sequence !== null) {
            $queryParams['invoice.numberSequence'] = ObjectSerializer::toQueryValue($invoice_number_sequence);
        }
        // query params
        if ($invoice_out_date !== null) {
            $queryParams['invoice.outDate'] = ObjectSerializer::toQueryValue($invoice_out_date);
        }
        // query params
        if ($invoice_scheduler !== null) {
            $queryParams['invoice.scheduler'] = ObjectSerializer::toQueryValue($invoice_scheduler);
        }
        // query params
        if ($invoice_status !== null) {
            $queryParams['invoice.status'] = ObjectSerializer::toQueryValue($invoice_status);
        }
        // query params
        if ($invoice_status_msg !== null) {
            $queryParams['invoice.statusMsg'] = ObjectSerializer::toQueryValue($invoice_status_msg);
        }
        // query params
        if ($invoice_tax_rate !== null) {
            $queryParams['invoice.taxRate'] = ObjectSerializer::toQueryValue($invoice_tax_rate);
        }
        // query params
        if ($invoice_total !== null) {
            $queryParams['invoice.total'] = ObjectSerializer::toQueryValue($invoice_total);
        }
        // query params
        if ($invoice_total_with_tax !== null) {
            $queryParams['invoice.totalWithTax'] = ObjectSerializer::toQueryValue($invoice_total_with_tax);
        }
        // query params
        if ($invoice2 !== null) {
            $queryParams['invoice[]'] = ObjectSerializer::toQueryValue($invoice2);
        }
        // query params
        if ($quantity !== null) {
            $queryParams['quantity'] = ObjectSerializer::toQueryValue($quantity);
        }
        // query params
        if ($quantity_between !== null) {
            $queryParams['quantity[between]'] = ObjectSerializer::toQueryValue($quantity_between);
        }
        // query params
        if ($quantity_exists !== null) {
            $queryParams['quantity[exists]'] = ObjectSerializer::toQueryValue($quantity_exists);
        }
        // query params
        if ($quantity_gt !== null) {
            $queryParams['quantity[gt]'] = ObjectSerializer::toQueryValue($quantity_gt);
        }
        // query params
        if ($quantity_gte !== null) {
            $queryParams['quantity[gte]'] = ObjectSerializer::toQueryValue($quantity_gte);
        }
        // query params
        if ($quantity_lt !== null) {
            $queryParams['quantity[lt]'] = ObjectSerializer::toQueryValue($quantity_lt);
        }
        // query params
        if ($quantity_lte !== null) {
            $queryParams['quantity[lte]'] = ObjectSerializer::toQueryValue($quantity_lte);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_quantity !== null) {
            $queryParams['_order[quantity]'] = ObjectSerializer::toQueryValue($_order_quantity);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFixedCostsRelInvoiceItem
     *
     * Retrieves a FixedCostsRelInvoice resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostsRelInvoiceDetailed
     */
    public function getFixedCostsRelInvoiceItem($id)
    {
        list($response) = $this->getFixedCostsRelInvoiceItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFixedCostsRelInvoiceItemWithHttpInfo
     *
     * Retrieves a FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostsRelInvoiceDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFixedCostsRelInvoiceItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceDetailed';
        $request = $this->getFixedCostsRelInvoiceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostsRelInvoiceDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFixedCostsRelInvoiceItemAsync
     *
     * Retrieves a FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostsRelInvoiceItemAsync($id)
    {
        return $this->getFixedCostsRelInvoiceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFixedCostsRelInvoiceItemAsyncWithHttpInfo
     *
     * Retrieves a FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostsRelInvoiceItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceDetailed';
        $request = $this->getFixedCostsRelInvoiceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFixedCostsRelInvoiceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFixedCostsRelInvoiceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFixedCostsRelInvoiceItem'
            );
        }

        $resourcePath = '/fixed_costs_rel_invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFixedCostsRelInvoiceSchedulerCollection
     *
     * Retrieves the collection of FixedCostsRelInvoiceScheduler resources.
     *
     * @param  string $fixed_cost fixed_cost (optional)
     * @param  float $fixed_cost_cost fixed_cost_cost (optional)
     * @param  string $fixed_cost_description fixed_cost_description (optional)
     * @param  string $fixed_cost_name fixed_cost_name (optional)
     * @param  string $fixed_cost2 fixed_cost2 (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $invoice_scheduler invoice_scheduler (optional)
     * @param  int $invoice_scheduler_brand invoice_scheduler_brand (optional)
     * @param  int $invoice_scheduler_company invoice_scheduler_company (optional)
     * @param  string $invoice_scheduler_email invoice_scheduler_email (optional)
     * @param  int $invoice_scheduler_frequency invoice_scheduler_frequency (optional)
     * @param  int $invoice_scheduler_invoice_template invoice_scheduler_invoice_template (optional)
     * @param  string $invoice_scheduler_last_execution invoice_scheduler_last_execution (optional)
     * @param  string $invoice_scheduler_last_execution_error invoice_scheduler_last_execution_error (optional)
     * @param  string $invoice_scheduler_name invoice_scheduler_name (optional)
     * @param  string $invoice_scheduler_next_execution invoice_scheduler_next_execution (optional)
     * @param  int $invoice_scheduler_number_sequence invoice_scheduler_number_sequence (optional)
     * @param  float $invoice_scheduler_tax_rate invoice_scheduler_tax_rate (optional)
     * @param  string $invoice_scheduler_unit invoice_scheduler_unit (optional)
     * @param  string $invoice_scheduler2 invoice_scheduler2 (optional)
     * @param  int $quantity quantity (optional)
     * @param  string $quantity_between quantity_between (optional)
     * @param  bool $quantity_exists quantity_exists (optional)
     * @param  string $quantity_gt quantity_gt (optional)
     * @param  string $quantity_gte quantity_gte (optional)
     * @param  string $quantity_lt quantity_lt (optional)
     * @param  string $quantity_lte quantity_lte (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_quantity _order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailedCollection[]
     */
    public function getFixedCostsRelInvoiceSchedulerCollection($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice_scheduler = null, $invoice_scheduler_brand = null, $invoice_scheduler_company = null, $invoice_scheduler_email = null, $invoice_scheduler_frequency = null, $invoice_scheduler_invoice_template = null, $invoice_scheduler_last_execution = null, $invoice_scheduler_last_execution_error = null, $invoice_scheduler_name = null, $invoice_scheduler_next_execution = null, $invoice_scheduler_number_sequence = null, $invoice_scheduler_tax_rate = null, $invoice_scheduler_unit = null, $invoice_scheduler2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getFixedCostsRelInvoiceSchedulerCollectionWithHttpInfo($fixed_cost, $fixed_cost_cost, $fixed_cost_description, $fixed_cost_name, $fixed_cost2, $id_exact, $invoice_scheduler, $invoice_scheduler_brand, $invoice_scheduler_company, $invoice_scheduler_email, $invoice_scheduler_frequency, $invoice_scheduler_invoice_template, $invoice_scheduler_last_execution, $invoice_scheduler_last_execution_error, $invoice_scheduler_name, $invoice_scheduler_next_execution, $invoice_scheduler_number_sequence, $invoice_scheduler_tax_rate, $invoice_scheduler_unit, $invoice_scheduler2, $quantity, $quantity_between, $quantity_exists, $quantity_gt, $quantity_gte, $quantity_lt, $quantity_lte, $_order_id, $_order_quantity, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getFixedCostsRelInvoiceSchedulerCollectionWithHttpInfo
     *
     * Retrieves the collection of FixedCostsRelInvoiceScheduler resources.
     *
     * @param  string $fixed_cost (optional)
     * @param  float $fixed_cost_cost (optional)
     * @param  string $fixed_cost_description (optional)
     * @param  string $fixed_cost_name (optional)
     * @param  string $fixed_cost2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_scheduler (optional)
     * @param  int $invoice_scheduler_brand (optional)
     * @param  int $invoice_scheduler_company (optional)
     * @param  string $invoice_scheduler_email (optional)
     * @param  int $invoice_scheduler_frequency (optional)
     * @param  int $invoice_scheduler_invoice_template (optional)
     * @param  string $invoice_scheduler_last_execution (optional)
     * @param  string $invoice_scheduler_last_execution_error (optional)
     * @param  string $invoice_scheduler_name (optional)
     * @param  string $invoice_scheduler_next_execution (optional)
     * @param  int $invoice_scheduler_number_sequence (optional)
     * @param  float $invoice_scheduler_tax_rate (optional)
     * @param  string $invoice_scheduler_unit (optional)
     * @param  string $invoice_scheduler2 (optional)
     * @param  int $quantity (optional)
     * @param  string $quantity_between (optional)
     * @param  bool $quantity_exists (optional)
     * @param  string $quantity_gt (optional)
     * @param  string $quantity_gte (optional)
     * @param  string $quantity_lt (optional)
     * @param  string $quantity_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailedCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFixedCostsRelInvoiceSchedulerCollectionWithHttpInfo($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice_scheduler = null, $invoice_scheduler_brand = null, $invoice_scheduler_company = null, $invoice_scheduler_email = null, $invoice_scheduler_frequency = null, $invoice_scheduler_invoice_template = null, $invoice_scheduler_last_execution = null, $invoice_scheduler_last_execution_error = null, $invoice_scheduler_name = null, $invoice_scheduler_next_execution = null, $invoice_scheduler_number_sequence = null, $invoice_scheduler_tax_rate = null, $invoice_scheduler_unit = null, $invoice_scheduler2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailedCollection[]';
        $request = $this->getFixedCostsRelInvoiceSchedulerCollectionRequest($fixed_cost, $fixed_cost_cost, $fixed_cost_description, $fixed_cost_name, $fixed_cost2, $id_exact, $invoice_scheduler, $invoice_scheduler_brand, $invoice_scheduler_company, $invoice_scheduler_email, $invoice_scheduler_frequency, $invoice_scheduler_invoice_template, $invoice_scheduler_last_execution, $invoice_scheduler_last_execution_error, $invoice_scheduler_name, $invoice_scheduler_next_execution, $invoice_scheduler_number_sequence, $invoice_scheduler_tax_rate, $invoice_scheduler_unit, $invoice_scheduler2, $quantity, $quantity_between, $quantity_exists, $quantity_gt, $quantity_gte, $quantity_lt, $quantity_lte, $_order_id, $_order_quantity, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailedCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFixedCostsRelInvoiceSchedulerCollectionAsync
     *
     * Retrieves the collection of FixedCostsRelInvoiceScheduler resources.
     *
     * @param  string $fixed_cost (optional)
     * @param  float $fixed_cost_cost (optional)
     * @param  string $fixed_cost_description (optional)
     * @param  string $fixed_cost_name (optional)
     * @param  string $fixed_cost2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_scheduler (optional)
     * @param  int $invoice_scheduler_brand (optional)
     * @param  int $invoice_scheduler_company (optional)
     * @param  string $invoice_scheduler_email (optional)
     * @param  int $invoice_scheduler_frequency (optional)
     * @param  int $invoice_scheduler_invoice_template (optional)
     * @param  string $invoice_scheduler_last_execution (optional)
     * @param  string $invoice_scheduler_last_execution_error (optional)
     * @param  string $invoice_scheduler_name (optional)
     * @param  string $invoice_scheduler_next_execution (optional)
     * @param  int $invoice_scheduler_number_sequence (optional)
     * @param  float $invoice_scheduler_tax_rate (optional)
     * @param  string $invoice_scheduler_unit (optional)
     * @param  string $invoice_scheduler2 (optional)
     * @param  int $quantity (optional)
     * @param  string $quantity_between (optional)
     * @param  bool $quantity_exists (optional)
     * @param  string $quantity_gt (optional)
     * @param  string $quantity_gte (optional)
     * @param  string $quantity_lt (optional)
     * @param  string $quantity_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostsRelInvoiceSchedulerCollectionAsync($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice_scheduler = null, $invoice_scheduler_brand = null, $invoice_scheduler_company = null, $invoice_scheduler_email = null, $invoice_scheduler_frequency = null, $invoice_scheduler_invoice_template = null, $invoice_scheduler_last_execution = null, $invoice_scheduler_last_execution_error = null, $invoice_scheduler_name = null, $invoice_scheduler_next_execution = null, $invoice_scheduler_number_sequence = null, $invoice_scheduler_tax_rate = null, $invoice_scheduler_unit = null, $invoice_scheduler2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getFixedCostsRelInvoiceSchedulerCollectionAsyncWithHttpInfo($fixed_cost, $fixed_cost_cost, $fixed_cost_description, $fixed_cost_name, $fixed_cost2, $id_exact, $invoice_scheduler, $invoice_scheduler_brand, $invoice_scheduler_company, $invoice_scheduler_email, $invoice_scheduler_frequency, $invoice_scheduler_invoice_template, $invoice_scheduler_last_execution, $invoice_scheduler_last_execution_error, $invoice_scheduler_name, $invoice_scheduler_next_execution, $invoice_scheduler_number_sequence, $invoice_scheduler_tax_rate, $invoice_scheduler_unit, $invoice_scheduler2, $quantity, $quantity_between, $quantity_exists, $quantity_gt, $quantity_gte, $quantity_lt, $quantity_lte, $_order_id, $_order_quantity, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFixedCostsRelInvoiceSchedulerCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of FixedCostsRelInvoiceScheduler resources.
     *
     * @param  string $fixed_cost (optional)
     * @param  float $fixed_cost_cost (optional)
     * @param  string $fixed_cost_description (optional)
     * @param  string $fixed_cost_name (optional)
     * @param  string $fixed_cost2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_scheduler (optional)
     * @param  int $invoice_scheduler_brand (optional)
     * @param  int $invoice_scheduler_company (optional)
     * @param  string $invoice_scheduler_email (optional)
     * @param  int $invoice_scheduler_frequency (optional)
     * @param  int $invoice_scheduler_invoice_template (optional)
     * @param  string $invoice_scheduler_last_execution (optional)
     * @param  string $invoice_scheduler_last_execution_error (optional)
     * @param  string $invoice_scheduler_name (optional)
     * @param  string $invoice_scheduler_next_execution (optional)
     * @param  int $invoice_scheduler_number_sequence (optional)
     * @param  float $invoice_scheduler_tax_rate (optional)
     * @param  string $invoice_scheduler_unit (optional)
     * @param  string $invoice_scheduler2 (optional)
     * @param  int $quantity (optional)
     * @param  string $quantity_between (optional)
     * @param  bool $quantity_exists (optional)
     * @param  string $quantity_gt (optional)
     * @param  string $quantity_gte (optional)
     * @param  string $quantity_lt (optional)
     * @param  string $quantity_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostsRelInvoiceSchedulerCollectionAsyncWithHttpInfo($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice_scheduler = null, $invoice_scheduler_brand = null, $invoice_scheduler_company = null, $invoice_scheduler_email = null, $invoice_scheduler_frequency = null, $invoice_scheduler_invoice_template = null, $invoice_scheduler_last_execution = null, $invoice_scheduler_last_execution_error = null, $invoice_scheduler_name = null, $invoice_scheduler_next_execution = null, $invoice_scheduler_number_sequence = null, $invoice_scheduler_tax_rate = null, $invoice_scheduler_unit = null, $invoice_scheduler2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailedCollection[]';
        $request = $this->getFixedCostsRelInvoiceSchedulerCollectionRequest($fixed_cost, $fixed_cost_cost, $fixed_cost_description, $fixed_cost_name, $fixed_cost2, $id_exact, $invoice_scheduler, $invoice_scheduler_brand, $invoice_scheduler_company, $invoice_scheduler_email, $invoice_scheduler_frequency, $invoice_scheduler_invoice_template, $invoice_scheduler_last_execution, $invoice_scheduler_last_execution_error, $invoice_scheduler_name, $invoice_scheduler_next_execution, $invoice_scheduler_number_sequence, $invoice_scheduler_tax_rate, $invoice_scheduler_unit, $invoice_scheduler2, $quantity, $quantity_between, $quantity_exists, $quantity_gt, $quantity_gte, $quantity_lt, $quantity_lte, $_order_id, $_order_quantity, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFixedCostsRelInvoiceSchedulerCollection'
     *
     * @param  string $fixed_cost (optional)
     * @param  float $fixed_cost_cost (optional)
     * @param  string $fixed_cost_description (optional)
     * @param  string $fixed_cost_name (optional)
     * @param  string $fixed_cost2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_scheduler (optional)
     * @param  int $invoice_scheduler_brand (optional)
     * @param  int $invoice_scheduler_company (optional)
     * @param  string $invoice_scheduler_email (optional)
     * @param  int $invoice_scheduler_frequency (optional)
     * @param  int $invoice_scheduler_invoice_template (optional)
     * @param  string $invoice_scheduler_last_execution (optional)
     * @param  string $invoice_scheduler_last_execution_error (optional)
     * @param  string $invoice_scheduler_name (optional)
     * @param  string $invoice_scheduler_next_execution (optional)
     * @param  int $invoice_scheduler_number_sequence (optional)
     * @param  float $invoice_scheduler_tax_rate (optional)
     * @param  string $invoice_scheduler_unit (optional)
     * @param  string $invoice_scheduler2 (optional)
     * @param  int $quantity (optional)
     * @param  string $quantity_between (optional)
     * @param  bool $quantity_exists (optional)
     * @param  string $quantity_gt (optional)
     * @param  string $quantity_gte (optional)
     * @param  string $quantity_lt (optional)
     * @param  string $quantity_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_quantity (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFixedCostsRelInvoiceSchedulerCollectionRequest($fixed_cost = null, $fixed_cost_cost = null, $fixed_cost_description = null, $fixed_cost_name = null, $fixed_cost2 = null, $id_exact = null, $invoice_scheduler = null, $invoice_scheduler_brand = null, $invoice_scheduler_company = null, $invoice_scheduler_email = null, $invoice_scheduler_frequency = null, $invoice_scheduler_invoice_template = null, $invoice_scheduler_last_execution = null, $invoice_scheduler_last_execution_error = null, $invoice_scheduler_name = null, $invoice_scheduler_next_execution = null, $invoice_scheduler_number_sequence = null, $invoice_scheduler_tax_rate = null, $invoice_scheduler_unit = null, $invoice_scheduler2 = null, $quantity = null, $quantity_between = null, $quantity_exists = null, $quantity_gt = null, $quantity_gte = null, $quantity_lt = null, $quantity_lte = null, $_order_id = null, $_order_quantity = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/fixed_costs_rel_invoice_schedulers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fixed_cost !== null) {
            $queryParams['fixedCost'] = ObjectSerializer::toQueryValue($fixed_cost);
        }
        // query params
        if ($fixed_cost_cost !== null) {
            $queryParams['fixedCost.cost'] = ObjectSerializer::toQueryValue($fixed_cost_cost);
        }
        // query params
        if ($fixed_cost_description !== null) {
            $queryParams['fixedCost.description'] = ObjectSerializer::toQueryValue($fixed_cost_description);
        }
        // query params
        if ($fixed_cost_name !== null) {
            $queryParams['fixedCost.name'] = ObjectSerializer::toQueryValue($fixed_cost_name);
        }
        // query params
        if ($fixed_cost2 !== null) {
            $queryParams['fixedCost[]'] = ObjectSerializer::toQueryValue($fixed_cost2);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($invoice_scheduler !== null) {
            $queryParams['invoiceScheduler'] = ObjectSerializer::toQueryValue($invoice_scheduler);
        }
        // query params
        if ($invoice_scheduler_brand !== null) {
            $queryParams['invoiceScheduler.brand'] = ObjectSerializer::toQueryValue($invoice_scheduler_brand);
        }
        // query params
        if ($invoice_scheduler_company !== null) {
            $queryParams['invoiceScheduler.company'] = ObjectSerializer::toQueryValue($invoice_scheduler_company);
        }
        // query params
        if ($invoice_scheduler_email !== null) {
            $queryParams['invoiceScheduler.email'] = ObjectSerializer::toQueryValue($invoice_scheduler_email);
        }
        // query params
        if ($invoice_scheduler_frequency !== null) {
            $queryParams['invoiceScheduler.frequency'] = ObjectSerializer::toQueryValue($invoice_scheduler_frequency);
        }
        // query params
        if ($invoice_scheduler_invoice_template !== null) {
            $queryParams['invoiceScheduler.invoiceTemplate'] = ObjectSerializer::toQueryValue($invoice_scheduler_invoice_template);
        }
        // query params
        if ($invoice_scheduler_last_execution !== null) {
            $queryParams['invoiceScheduler.lastExecution'] = ObjectSerializer::toQueryValue($invoice_scheduler_last_execution);
        }
        // query params
        if ($invoice_scheduler_last_execution_error !== null) {
            $queryParams['invoiceScheduler.lastExecutionError'] = ObjectSerializer::toQueryValue($invoice_scheduler_last_execution_error);
        }
        // query params
        if ($invoice_scheduler_name !== null) {
            $queryParams['invoiceScheduler.name'] = ObjectSerializer::toQueryValue($invoice_scheduler_name);
        }
        // query params
        if ($invoice_scheduler_next_execution !== null) {
            $queryParams['invoiceScheduler.nextExecution'] = ObjectSerializer::toQueryValue($invoice_scheduler_next_execution);
        }
        // query params
        if ($invoice_scheduler_number_sequence !== null) {
            $queryParams['invoiceScheduler.numberSequence'] = ObjectSerializer::toQueryValue($invoice_scheduler_number_sequence);
        }
        // query params
        if ($invoice_scheduler_tax_rate !== null) {
            $queryParams['invoiceScheduler.taxRate'] = ObjectSerializer::toQueryValue($invoice_scheduler_tax_rate);
        }
        // query params
        if ($invoice_scheduler_unit !== null) {
            $queryParams['invoiceScheduler.unit'] = ObjectSerializer::toQueryValue($invoice_scheduler_unit);
        }
        // query params
        if ($invoice_scheduler2 !== null) {
            $queryParams['invoiceScheduler[]'] = ObjectSerializer::toQueryValue($invoice_scheduler2);
        }
        // query params
        if ($quantity !== null) {
            $queryParams['quantity'] = ObjectSerializer::toQueryValue($quantity);
        }
        // query params
        if ($quantity_between !== null) {
            $queryParams['quantity[between]'] = ObjectSerializer::toQueryValue($quantity_between);
        }
        // query params
        if ($quantity_exists !== null) {
            $queryParams['quantity[exists]'] = ObjectSerializer::toQueryValue($quantity_exists);
        }
        // query params
        if ($quantity_gt !== null) {
            $queryParams['quantity[gt]'] = ObjectSerializer::toQueryValue($quantity_gt);
        }
        // query params
        if ($quantity_gte !== null) {
            $queryParams['quantity[gte]'] = ObjectSerializer::toQueryValue($quantity_gte);
        }
        // query params
        if ($quantity_lt !== null) {
            $queryParams['quantity[lt]'] = ObjectSerializer::toQueryValue($quantity_lt);
        }
        // query params
        if ($quantity_lte !== null) {
            $queryParams['quantity[lte]'] = ObjectSerializer::toQueryValue($quantity_lte);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_quantity !== null) {
            $queryParams['_order[quantity]'] = ObjectSerializer::toQueryValue($_order_quantity);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFixedCostsRelInvoiceSchedulerItem
     *
     * Retrieves a FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailed
     */
    public function getFixedCostsRelInvoiceSchedulerItem($id)
    {
        list($response) = $this->getFixedCostsRelInvoiceSchedulerItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFixedCostsRelInvoiceSchedulerItemWithHttpInfo
     *
     * Retrieves a FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFixedCostsRelInvoiceSchedulerItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailed';
        $request = $this->getFixedCostsRelInvoiceSchedulerItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFixedCostsRelInvoiceSchedulerItemAsync
     *
     * Retrieves a FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostsRelInvoiceSchedulerItemAsync($id)
    {
        return $this->getFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo
     *
     * Retrieves a FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceSchedulerDetailed';
        $request = $this->getFixedCostsRelInvoiceSchedulerItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFixedCostsRelInvoiceSchedulerItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFixedCostsRelInvoiceSchedulerItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFixedCostsRelInvoiceSchedulerItem'
            );
        }

        $resourcePath = '/fixed_costs_rel_invoice_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFriendCollection
     *
     * Retrieves the collection of Friend resources.
     *
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  string $description description (optional)
     * @param  string $description_end description_end (optional)
     * @param  string $description_exact description_exact (optional)
     * @param  string $description_partial description_partial (optional)
     * @param  string $description_start description_start (optional)
     * @param  string $direct_connectivity direct_connectivity (optional)
     * @param  string $direct_connectivity_end direct_connectivity_end (optional)
     * @param  string $direct_connectivity_exact direct_connectivity_exact (optional)
     * @param  string $direct_connectivity_partial direct_connectivity_partial (optional)
     * @param  string $direct_connectivity_start direct_connectivity_start (optional)
     * @param  int $domain domain (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $inter_company inter_company (optional)
     * @param  string $inter_company2 inter_company2 (optional)
     * @param  bool $inter_company_exists inter_company_exists (optional)
     * @param  string $language language (optional)
     * @param  string $language2 language2 (optional)
     * @param  bool $language_exists language_exists (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  int $priority priority (optional)
     * @param  string $priority_between priority_between (optional)
     * @param  string $priority_gt priority_gt (optional)
     * @param  string $priority_gte priority_gte (optional)
     * @param  string $priority_lt priority_lt (optional)
     * @param  string $priority_lte priority_lte (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $_order_description _order_description (optional)
     * @param  string $_order_direct_connectivity _order_direct_connectivity (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_priority _order_priority (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FriendCollection[]
     */
    public function getFriendCollection($company = null, $company2 = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $direct_connectivity = null, $direct_connectivity_end = null, $direct_connectivity_exact = null, $direct_connectivity_partial = null, $direct_connectivity_start = null, $domain = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_direct_connectivity = null, $_order_id = null, $_order_name = null, $_order_priority = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getFriendCollectionWithHttpInfo($company, $company2, $description, $description_end, $description_exact, $description_partial, $description_start, $direct_connectivity, $direct_connectivity_end, $direct_connectivity_exact, $direct_connectivity_partial, $direct_connectivity_start, $domain, $id_exact, $inter_company, $inter_company2, $inter_company_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $priority, $priority_between, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_direct_connectivity, $_order_id, $_order_name, $_order_priority, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getFriendCollectionWithHttpInfo
     *
     * Retrieves the collection of Friend resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  string $direct_connectivity (optional)
     * @param  string $direct_connectivity_end (optional)
     * @param  string $direct_connectivity_exact (optional)
     * @param  string $direct_connectivity_partial (optional)
     * @param  string $direct_connectivity_start (optional)
     * @param  int $domain (optional)
     * @param  int $id_exact (optional)
     * @param  string $inter_company (optional)
     * @param  string $inter_company2 (optional)
     * @param  bool $inter_company_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_direct_connectivity (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_priority (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FriendCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFriendCollectionWithHttpInfo($company = null, $company2 = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $direct_connectivity = null, $direct_connectivity_end = null, $direct_connectivity_exact = null, $direct_connectivity_partial = null, $direct_connectivity_start = null, $domain = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_direct_connectivity = null, $_order_id = null, $_order_name = null, $_order_priority = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\FriendCollection[]';
        $request = $this->getFriendCollectionRequest($company, $company2, $description, $description_end, $description_exact, $description_partial, $description_start, $direct_connectivity, $direct_connectivity_end, $direct_connectivity_exact, $direct_connectivity_partial, $direct_connectivity_start, $domain, $id_exact, $inter_company, $inter_company2, $inter_company_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $priority, $priority_between, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_direct_connectivity, $_order_id, $_order_name, $_order_priority, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FriendCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFriendCollectionAsync
     *
     * Retrieves the collection of Friend resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  string $direct_connectivity (optional)
     * @param  string $direct_connectivity_end (optional)
     * @param  string $direct_connectivity_exact (optional)
     * @param  string $direct_connectivity_partial (optional)
     * @param  string $direct_connectivity_start (optional)
     * @param  int $domain (optional)
     * @param  int $id_exact (optional)
     * @param  string $inter_company (optional)
     * @param  string $inter_company2 (optional)
     * @param  bool $inter_company_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_direct_connectivity (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_priority (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFriendCollectionAsync($company = null, $company2 = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $direct_connectivity = null, $direct_connectivity_end = null, $direct_connectivity_exact = null, $direct_connectivity_partial = null, $direct_connectivity_start = null, $domain = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_direct_connectivity = null, $_order_id = null, $_order_name = null, $_order_priority = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getFriendCollectionAsyncWithHttpInfo($company, $company2, $description, $description_end, $description_exact, $description_partial, $description_start, $direct_connectivity, $direct_connectivity_end, $direct_connectivity_exact, $direct_connectivity_partial, $direct_connectivity_start, $domain, $id_exact, $inter_company, $inter_company2, $inter_company_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $priority, $priority_between, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_direct_connectivity, $_order_id, $_order_name, $_order_priority, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFriendCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Friend resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  string $direct_connectivity (optional)
     * @param  string $direct_connectivity_end (optional)
     * @param  string $direct_connectivity_exact (optional)
     * @param  string $direct_connectivity_partial (optional)
     * @param  string $direct_connectivity_start (optional)
     * @param  int $domain (optional)
     * @param  int $id_exact (optional)
     * @param  string $inter_company (optional)
     * @param  string $inter_company2 (optional)
     * @param  bool $inter_company_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_direct_connectivity (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_priority (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFriendCollectionAsyncWithHttpInfo($company = null, $company2 = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $direct_connectivity = null, $direct_connectivity_end = null, $direct_connectivity_exact = null, $direct_connectivity_partial = null, $direct_connectivity_start = null, $domain = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_direct_connectivity = null, $_order_id = null, $_order_name = null, $_order_priority = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\FriendCollection[]';
        $request = $this->getFriendCollectionRequest($company, $company2, $description, $description_end, $description_exact, $description_partial, $description_start, $direct_connectivity, $direct_connectivity_end, $direct_connectivity_exact, $direct_connectivity_partial, $direct_connectivity_start, $domain, $id_exact, $inter_company, $inter_company2, $inter_company_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $priority, $priority_between, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_description, $_order_direct_connectivity, $_order_id, $_order_name, $_order_priority, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFriendCollection'
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  string $direct_connectivity (optional)
     * @param  string $direct_connectivity_end (optional)
     * @param  string $direct_connectivity_exact (optional)
     * @param  string $direct_connectivity_partial (optional)
     * @param  string $direct_connectivity_start (optional)
     * @param  int $domain (optional)
     * @param  int $id_exact (optional)
     * @param  string $inter_company (optional)
     * @param  string $inter_company2 (optional)
     * @param  bool $inter_company_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_direct_connectivity (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_priority (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFriendCollectionRequest($company = null, $company2 = null, $description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $direct_connectivity = null, $direct_connectivity_end = null, $direct_connectivity_exact = null, $direct_connectivity_partial = null, $direct_connectivity_start = null, $domain = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_description = null, $_order_direct_connectivity = null, $_order_id = null, $_order_name = null, $_order_priority = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/friends';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($description_end !== null) {
            $queryParams['description[end]'] = ObjectSerializer::toQueryValue($description_end);
        }
        // query params
        if ($description_exact !== null) {
            $queryParams['description[exact]'] = ObjectSerializer::toQueryValue($description_exact);
        }
        // query params
        if ($description_partial !== null) {
            $queryParams['description[partial]'] = ObjectSerializer::toQueryValue($description_partial);
        }
        // query params
        if ($description_start !== null) {
            $queryParams['description[start]'] = ObjectSerializer::toQueryValue($description_start);
        }
        // query params
        if ($direct_connectivity !== null) {
            $queryParams['directConnectivity'] = ObjectSerializer::toQueryValue($direct_connectivity);
        }
        // query params
        if ($direct_connectivity_end !== null) {
            $queryParams['directConnectivity[end]'] = ObjectSerializer::toQueryValue($direct_connectivity_end);
        }
        // query params
        if ($direct_connectivity_exact !== null) {
            $queryParams['directConnectivity[exact]'] = ObjectSerializer::toQueryValue($direct_connectivity_exact);
        }
        // query params
        if ($direct_connectivity_partial !== null) {
            $queryParams['directConnectivity[partial]'] = ObjectSerializer::toQueryValue($direct_connectivity_partial);
        }
        // query params
        if ($direct_connectivity_start !== null) {
            $queryParams['directConnectivity[start]'] = ObjectSerializer::toQueryValue($direct_connectivity_start);
        }
        // query params
        if ($domain !== null) {
            $queryParams['domain'] = ObjectSerializer::toQueryValue($domain);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($inter_company !== null) {
            $queryParams['interCompany'] = ObjectSerializer::toQueryValue($inter_company);
        }
        // query params
        if ($inter_company2 !== null) {
            $queryParams['interCompany[]'] = ObjectSerializer::toQueryValue($inter_company2);
        }
        // query params
        if ($inter_company_exists !== null) {
            $queryParams['interCompany[exists]'] = ObjectSerializer::toQueryValue($inter_company_exists);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($language2 !== null) {
            $queryParams['language[]'] = ObjectSerializer::toQueryValue($language2);
        }
        // query params
        if ($language_exists !== null) {
            $queryParams['language[exists]'] = ObjectSerializer::toQueryValue($language_exists);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority);
        }
        // query params
        if ($priority_between !== null) {
            $queryParams['priority[between]'] = ObjectSerializer::toQueryValue($priority_between);
        }
        // query params
        if ($priority_gt !== null) {
            $queryParams['priority[gt]'] = ObjectSerializer::toQueryValue($priority_gt);
        }
        // query params
        if ($priority_gte !== null) {
            $queryParams['priority[gte]'] = ObjectSerializer::toQueryValue($priority_gte);
        }
        // query params
        if ($priority_lt !== null) {
            $queryParams['priority[lt]'] = ObjectSerializer::toQueryValue($priority_lt);
        }
        // query params
        if ($priority_lte !== null) {
            $queryParams['priority[lte]'] = ObjectSerializer::toQueryValue($priority_lte);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($_order_description !== null) {
            $queryParams['_order[description]'] = ObjectSerializer::toQueryValue($_order_description);
        }
        // query params
        if ($_order_direct_connectivity !== null) {
            $queryParams['_order[directConnectivity]'] = ObjectSerializer::toQueryValue($_order_direct_connectivity);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_priority !== null) {
            $queryParams['_order[priority]'] = ObjectSerializer::toQueryValue($_order_priority);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFriendItem
     *
     * Retrieves a Friend resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FriendDetailed
     */
    public function getFriendItem($id)
    {
        list($response) = $this->getFriendItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFriendItemWithHttpInfo
     *
     * Retrieves a Friend resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FriendDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFriendItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FriendDetailed';
        $request = $this->getFriendItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FriendDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFriendItemAsync
     *
     * Retrieves a Friend resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFriendItemAsync($id)
    {
        return $this->getFriendItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFriendItemAsyncWithHttpInfo
     *
     * Retrieves a Friend resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFriendItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\FriendDetailed';
        $request = $this->getFriendItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFriendItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFriendItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFriendItem'
            );
        }

        $resourcePath = '/friends/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceCollection
     *
     * Retrieves the collection of Invoice resources.
     *
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $in_date in_date (optional)
     * @param  string $in_date_after in_date_after (optional)
     * @param  string $in_date_before in_date_before (optional)
     * @param  bool $in_date_exists in_date_exists (optional)
     * @param  string $in_date_start in_date_start (optional)
     * @param  string $in_date_strictly_after in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before in_date_strictly_before (optional)
     * @param  string $invoice_template invoice_template (optional)
     * @param  string $invoice_template2 invoice_template2 (optional)
     * @param  bool $invoice_template_exists invoice_template_exists (optional)
     * @param  string $number number (optional)
     * @param  string $number_sequence number_sequence (optional)
     * @param  string $number_sequence2 number_sequence2 (optional)
     * @param  bool $number_sequence_exists number_sequence_exists (optional)
     * @param  string $number_end number_end (optional)
     * @param  string $number_exact number_exact (optional)
     * @param  bool $number_exists number_exists (optional)
     * @param  string $number_partial number_partial (optional)
     * @param  string $number_start number_start (optional)
     * @param  string $out_date out_date (optional)
     * @param  string $out_date_after out_date_after (optional)
     * @param  string $out_date_before out_date_before (optional)
     * @param  bool $out_date_exists out_date_exists (optional)
     * @param  string $out_date_start out_date_start (optional)
     * @param  string $out_date_strictly_after out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before out_date_strictly_before (optional)
     * @param  string $pdf pdf (optional)
     * @param  string $pdf_base_name pdf_base_name (optional)
     * @param  string $pdf_base_name_end pdf_base_name_end (optional)
     * @param  string $pdf_base_name_exact pdf_base_name_exact (optional)
     * @param  bool $pdf_base_name_exists pdf_base_name_exists (optional)
     * @param  string $pdf_base_name_partial pdf_base_name_partial (optional)
     * @param  string $pdf_base_name_start pdf_base_name_start (optional)
     * @param  int $pdf_file_size pdf_file_size (optional)
     * @param  string $pdf_file_size_between pdf_file_size_between (optional)
     * @param  bool $pdf_file_size_exists pdf_file_size_exists (optional)
     * @param  string $pdf_file_size_gt pdf_file_size_gt (optional)
     * @param  string $pdf_file_size_gte pdf_file_size_gte (optional)
     * @param  string $pdf_file_size_lt pdf_file_size_lt (optional)
     * @param  string $pdf_file_size_lte pdf_file_size_lte (optional)
     * @param  string $pdf_mime_type pdf_mime_type (optional)
     * @param  string $pdf_mime_type_end pdf_mime_type_end (optional)
     * @param  string $pdf_mime_type_exact pdf_mime_type_exact (optional)
     * @param  bool $pdf_mime_type_exists pdf_mime_type_exists (optional)
     * @param  string $pdf_mime_type_partial pdf_mime_type_partial (optional)
     * @param  string $pdf_mime_type_start pdf_mime_type_start (optional)
     * @param  string $scheduler scheduler (optional)
     * @param  string $scheduler2 scheduler2 (optional)
     * @param  bool $scheduler_exists scheduler_exists (optional)
     * @param  string $status status (optional)
     * @param  string $status_end status_end (optional)
     * @param  string $status_exact status_exact (optional)
     * @param  bool $status_exists status_exists (optional)
     * @param  string $status_partial status_partial (optional)
     * @param  string $status_start status_start (optional)
     * @param  string $total total (optional)
     * @param  string $total_with_tax total_with_tax (optional)
     * @param  string $total_with_tax_between total_with_tax_between (optional)
     * @param  bool $total_with_tax_exists total_with_tax_exists (optional)
     * @param  string $total_with_tax_gt total_with_tax_gt (optional)
     * @param  string $total_with_tax_gte total_with_tax_gte (optional)
     * @param  string $total_with_tax_lt total_with_tax_lt (optional)
     * @param  string $total_with_tax_lte total_with_tax_lte (optional)
     * @param  string $total_between total_between (optional)
     * @param  bool $total_exists total_exists (optional)
     * @param  string $total_gt total_gt (optional)
     * @param  string $total_gte total_gte (optional)
     * @param  string $total_lt total_lt (optional)
     * @param  string $total_lte total_lte (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_in_date _order_in_date (optional)
     * @param  string $_order_number _order_number (optional)
     * @param  string $_order_out_date _order_out_date (optional)
     * @param  string $_order_pdf_base_name _order_pdf_base_name (optional)
     * @param  string $_order_pdf_file_size _order_pdf_file_size (optional)
     * @param  string $_order_pdf_mime_type _order_pdf_mime_type (optional)
     * @param  string $_order_status _order_status (optional)
     * @param  string $_order_total_with_tax _order_total_with_tax (optional)
     * @param  string $_order_total _order_total (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceCollection[]
     */
    public function getInvoiceCollection($company = null, $company2 = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_exists = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $number = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $number_end = null, $number_exact = null, $number_exists = null, $number_partial = null, $number_start = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_exists = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $pdf = null, $pdf_base_name = null, $pdf_base_name_end = null, $pdf_base_name_exact = null, $pdf_base_name_exists = null, $pdf_base_name_partial = null, $pdf_base_name_start = null, $pdf_file_size = null, $pdf_file_size_between = null, $pdf_file_size_exists = null, $pdf_file_size_gt = null, $pdf_file_size_gte = null, $pdf_file_size_lt = null, $pdf_file_size_lte = null, $pdf_mime_type = null, $pdf_mime_type_end = null, $pdf_mime_type_exact = null, $pdf_mime_type_exists = null, $pdf_mime_type_partial = null, $pdf_mime_type_start = null, $scheduler = null, $scheduler2 = null, $scheduler_exists = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $total = null, $total_with_tax = null, $total_with_tax_between = null, $total_with_tax_exists = null, $total_with_tax_gt = null, $total_with_tax_gte = null, $total_with_tax_lt = null, $total_with_tax_lte = null, $total_between = null, $total_exists = null, $total_gt = null, $total_gte = null, $total_lt = null, $total_lte = null, $_order_id = null, $_order_in_date = null, $_order_number = null, $_order_out_date = null, $_order_pdf_base_name = null, $_order_pdf_file_size = null, $_order_pdf_mime_type = null, $_order_status = null, $_order_total_with_tax = null, $_order_total = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        list($response) = $this->getInvoiceCollectionWithHttpInfo($company, $company2, $id_exact, $in_date, $in_date_after, $in_date_before, $in_date_exists, $in_date_start, $in_date_strictly_after, $in_date_strictly_before, $invoice_template, $invoice_template2, $invoice_template_exists, $number, $number_sequence, $number_sequence2, $number_sequence_exists, $number_end, $number_exact, $number_exists, $number_partial, $number_start, $out_date, $out_date_after, $out_date_before, $out_date_exists, $out_date_start, $out_date_strictly_after, $out_date_strictly_before, $pdf, $pdf_base_name, $pdf_base_name_end, $pdf_base_name_exact, $pdf_base_name_exists, $pdf_base_name_partial, $pdf_base_name_start, $pdf_file_size, $pdf_file_size_between, $pdf_file_size_exists, $pdf_file_size_gt, $pdf_file_size_gte, $pdf_file_size_lt, $pdf_file_size_lte, $pdf_mime_type, $pdf_mime_type_end, $pdf_mime_type_exact, $pdf_mime_type_exists, $pdf_mime_type_partial, $pdf_mime_type_start, $scheduler, $scheduler2, $scheduler_exists, $status, $status_end, $status_exact, $status_exists, $status_partial, $status_start, $total, $total_with_tax, $total_with_tax_between, $total_with_tax_exists, $total_with_tax_gt, $total_with_tax_gte, $total_with_tax_lt, $total_with_tax_lte, $total_between, $total_exists, $total_gt, $total_gte, $total_lt, $total_lte, $_order_id, $_order_in_date, $_order_number, $_order_out_date, $_order_pdf_base_name, $_order_pdf_file_size, $_order_pdf_mime_type, $_order_status, $_order_total_with_tax, $_order_total, $_items_per_page, $_page, $_properties, $_timezone);
        return $response;
    }

    /**
     * Operation getInvoiceCollectionWithHttpInfo
     *
     * Retrieves the collection of Invoice resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $in_date (optional)
     * @param  string $in_date_after (optional)
     * @param  string $in_date_before (optional)
     * @param  bool $in_date_exists (optional)
     * @param  string $in_date_start (optional)
     * @param  string $in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before (optional)
     * @param  string $invoice_template (optional)
     * @param  string $invoice_template2 (optional)
     * @param  bool $invoice_template_exists (optional)
     * @param  string $number (optional)
     * @param  string $number_sequence (optional)
     * @param  string $number_sequence2 (optional)
     * @param  bool $number_sequence_exists (optional)
     * @param  string $number_end (optional)
     * @param  string $number_exact (optional)
     * @param  bool $number_exists (optional)
     * @param  string $number_partial (optional)
     * @param  string $number_start (optional)
     * @param  string $out_date (optional)
     * @param  string $out_date_after (optional)
     * @param  string $out_date_before (optional)
     * @param  bool $out_date_exists (optional)
     * @param  string $out_date_start (optional)
     * @param  string $out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before (optional)
     * @param  string $pdf (optional)
     * @param  string $pdf_base_name (optional)
     * @param  string $pdf_base_name_end (optional)
     * @param  string $pdf_base_name_exact (optional)
     * @param  bool $pdf_base_name_exists (optional)
     * @param  string $pdf_base_name_partial (optional)
     * @param  string $pdf_base_name_start (optional)
     * @param  int $pdf_file_size (optional)
     * @param  string $pdf_file_size_between (optional)
     * @param  bool $pdf_file_size_exists (optional)
     * @param  string $pdf_file_size_gt (optional)
     * @param  string $pdf_file_size_gte (optional)
     * @param  string $pdf_file_size_lt (optional)
     * @param  string $pdf_file_size_lte (optional)
     * @param  string $pdf_mime_type (optional)
     * @param  string $pdf_mime_type_end (optional)
     * @param  string $pdf_mime_type_exact (optional)
     * @param  bool $pdf_mime_type_exists (optional)
     * @param  string $pdf_mime_type_partial (optional)
     * @param  string $pdf_mime_type_start (optional)
     * @param  string $scheduler (optional)
     * @param  string $scheduler2 (optional)
     * @param  bool $scheduler_exists (optional)
     * @param  string $status (optional)
     * @param  string $status_end (optional)
     * @param  string $status_exact (optional)
     * @param  bool $status_exists (optional)
     * @param  string $status_partial (optional)
     * @param  string $status_start (optional)
     * @param  string $total (optional)
     * @param  string $total_with_tax (optional)
     * @param  string $total_with_tax_between (optional)
     * @param  bool $total_with_tax_exists (optional)
     * @param  string $total_with_tax_gt (optional)
     * @param  string $total_with_tax_gte (optional)
     * @param  string $total_with_tax_lt (optional)
     * @param  string $total_with_tax_lte (optional)
     * @param  string $total_between (optional)
     * @param  bool $total_exists (optional)
     * @param  string $total_gt (optional)
     * @param  string $total_gte (optional)
     * @param  string $total_lt (optional)
     * @param  string $total_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_in_date (optional)
     * @param  string $_order_number (optional)
     * @param  string $_order_out_date (optional)
     * @param  string $_order_pdf_base_name (optional)
     * @param  string $_order_pdf_file_size (optional)
     * @param  string $_order_pdf_mime_type (optional)
     * @param  string $_order_status (optional)
     * @param  string $_order_total_with_tax (optional)
     * @param  string $_order_total (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceCollectionWithHttpInfo($company = null, $company2 = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_exists = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $number = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $number_end = null, $number_exact = null, $number_exists = null, $number_partial = null, $number_start = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_exists = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $pdf = null, $pdf_base_name = null, $pdf_base_name_end = null, $pdf_base_name_exact = null, $pdf_base_name_exists = null, $pdf_base_name_partial = null, $pdf_base_name_start = null, $pdf_file_size = null, $pdf_file_size_between = null, $pdf_file_size_exists = null, $pdf_file_size_gt = null, $pdf_file_size_gte = null, $pdf_file_size_lt = null, $pdf_file_size_lte = null, $pdf_mime_type = null, $pdf_mime_type_end = null, $pdf_mime_type_exact = null, $pdf_mime_type_exists = null, $pdf_mime_type_partial = null, $pdf_mime_type_start = null, $scheduler = null, $scheduler2 = null, $scheduler_exists = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $total = null, $total_with_tax = null, $total_with_tax_between = null, $total_with_tax_exists = null, $total_with_tax_gt = null, $total_with_tax_gte = null, $total_with_tax_lt = null, $total_with_tax_lte = null, $total_between = null, $total_exists = null, $total_gt = null, $total_gte = null, $total_lt = null, $total_lte = null, $_order_id = null, $_order_in_date = null, $_order_number = null, $_order_out_date = null, $_order_pdf_base_name = null, $_order_pdf_file_size = null, $_order_pdf_mime_type = null, $_order_status = null, $_order_total_with_tax = null, $_order_total = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceCollection[]';
        $request = $this->getInvoiceCollectionRequest($company, $company2, $id_exact, $in_date, $in_date_after, $in_date_before, $in_date_exists, $in_date_start, $in_date_strictly_after, $in_date_strictly_before, $invoice_template, $invoice_template2, $invoice_template_exists, $number, $number_sequence, $number_sequence2, $number_sequence_exists, $number_end, $number_exact, $number_exists, $number_partial, $number_start, $out_date, $out_date_after, $out_date_before, $out_date_exists, $out_date_start, $out_date_strictly_after, $out_date_strictly_before, $pdf, $pdf_base_name, $pdf_base_name_end, $pdf_base_name_exact, $pdf_base_name_exists, $pdf_base_name_partial, $pdf_base_name_start, $pdf_file_size, $pdf_file_size_between, $pdf_file_size_exists, $pdf_file_size_gt, $pdf_file_size_gte, $pdf_file_size_lt, $pdf_file_size_lte, $pdf_mime_type, $pdf_mime_type_end, $pdf_mime_type_exact, $pdf_mime_type_exists, $pdf_mime_type_partial, $pdf_mime_type_start, $scheduler, $scheduler2, $scheduler_exists, $status, $status_end, $status_exact, $status_exists, $status_partial, $status_start, $total, $total_with_tax, $total_with_tax_between, $total_with_tax_exists, $total_with_tax_gt, $total_with_tax_gte, $total_with_tax_lt, $total_with_tax_lte, $total_between, $total_exists, $total_gt, $total_gte, $total_lt, $total_lte, $_order_id, $_order_in_date, $_order_number, $_order_out_date, $_order_pdf_base_name, $_order_pdf_file_size, $_order_pdf_mime_type, $_order_status, $_order_total_with_tax, $_order_total, $_items_per_page, $_page, $_properties, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceCollectionAsync
     *
     * Retrieves the collection of Invoice resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $in_date (optional)
     * @param  string $in_date_after (optional)
     * @param  string $in_date_before (optional)
     * @param  bool $in_date_exists (optional)
     * @param  string $in_date_start (optional)
     * @param  string $in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before (optional)
     * @param  string $invoice_template (optional)
     * @param  string $invoice_template2 (optional)
     * @param  bool $invoice_template_exists (optional)
     * @param  string $number (optional)
     * @param  string $number_sequence (optional)
     * @param  string $number_sequence2 (optional)
     * @param  bool $number_sequence_exists (optional)
     * @param  string $number_end (optional)
     * @param  string $number_exact (optional)
     * @param  bool $number_exists (optional)
     * @param  string $number_partial (optional)
     * @param  string $number_start (optional)
     * @param  string $out_date (optional)
     * @param  string $out_date_after (optional)
     * @param  string $out_date_before (optional)
     * @param  bool $out_date_exists (optional)
     * @param  string $out_date_start (optional)
     * @param  string $out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before (optional)
     * @param  string $pdf (optional)
     * @param  string $pdf_base_name (optional)
     * @param  string $pdf_base_name_end (optional)
     * @param  string $pdf_base_name_exact (optional)
     * @param  bool $pdf_base_name_exists (optional)
     * @param  string $pdf_base_name_partial (optional)
     * @param  string $pdf_base_name_start (optional)
     * @param  int $pdf_file_size (optional)
     * @param  string $pdf_file_size_between (optional)
     * @param  bool $pdf_file_size_exists (optional)
     * @param  string $pdf_file_size_gt (optional)
     * @param  string $pdf_file_size_gte (optional)
     * @param  string $pdf_file_size_lt (optional)
     * @param  string $pdf_file_size_lte (optional)
     * @param  string $pdf_mime_type (optional)
     * @param  string $pdf_mime_type_end (optional)
     * @param  string $pdf_mime_type_exact (optional)
     * @param  bool $pdf_mime_type_exists (optional)
     * @param  string $pdf_mime_type_partial (optional)
     * @param  string $pdf_mime_type_start (optional)
     * @param  string $scheduler (optional)
     * @param  string $scheduler2 (optional)
     * @param  bool $scheduler_exists (optional)
     * @param  string $status (optional)
     * @param  string $status_end (optional)
     * @param  string $status_exact (optional)
     * @param  bool $status_exists (optional)
     * @param  string $status_partial (optional)
     * @param  string $status_start (optional)
     * @param  string $total (optional)
     * @param  string $total_with_tax (optional)
     * @param  string $total_with_tax_between (optional)
     * @param  bool $total_with_tax_exists (optional)
     * @param  string $total_with_tax_gt (optional)
     * @param  string $total_with_tax_gte (optional)
     * @param  string $total_with_tax_lt (optional)
     * @param  string $total_with_tax_lte (optional)
     * @param  string $total_between (optional)
     * @param  bool $total_exists (optional)
     * @param  string $total_gt (optional)
     * @param  string $total_gte (optional)
     * @param  string $total_lt (optional)
     * @param  string $total_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_in_date (optional)
     * @param  string $_order_number (optional)
     * @param  string $_order_out_date (optional)
     * @param  string $_order_pdf_base_name (optional)
     * @param  string $_order_pdf_file_size (optional)
     * @param  string $_order_pdf_mime_type (optional)
     * @param  string $_order_status (optional)
     * @param  string $_order_total_with_tax (optional)
     * @param  string $_order_total (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceCollectionAsync($company = null, $company2 = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_exists = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $number = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $number_end = null, $number_exact = null, $number_exists = null, $number_partial = null, $number_start = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_exists = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $pdf = null, $pdf_base_name = null, $pdf_base_name_end = null, $pdf_base_name_exact = null, $pdf_base_name_exists = null, $pdf_base_name_partial = null, $pdf_base_name_start = null, $pdf_file_size = null, $pdf_file_size_between = null, $pdf_file_size_exists = null, $pdf_file_size_gt = null, $pdf_file_size_gte = null, $pdf_file_size_lt = null, $pdf_file_size_lte = null, $pdf_mime_type = null, $pdf_mime_type_end = null, $pdf_mime_type_exact = null, $pdf_mime_type_exists = null, $pdf_mime_type_partial = null, $pdf_mime_type_start = null, $scheduler = null, $scheduler2 = null, $scheduler_exists = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $total = null, $total_with_tax = null, $total_with_tax_between = null, $total_with_tax_exists = null, $total_with_tax_gt = null, $total_with_tax_gte = null, $total_with_tax_lt = null, $total_with_tax_lte = null, $total_between = null, $total_exists = null, $total_gt = null, $total_gte = null, $total_lt = null, $total_lte = null, $_order_id = null, $_order_in_date = null, $_order_number = null, $_order_out_date = null, $_order_pdf_base_name = null, $_order_pdf_file_size = null, $_order_pdf_mime_type = null, $_order_status = null, $_order_total_with_tax = null, $_order_total = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        return $this->getInvoiceCollectionAsyncWithHttpInfo($company, $company2, $id_exact, $in_date, $in_date_after, $in_date_before, $in_date_exists, $in_date_start, $in_date_strictly_after, $in_date_strictly_before, $invoice_template, $invoice_template2, $invoice_template_exists, $number, $number_sequence, $number_sequence2, $number_sequence_exists, $number_end, $number_exact, $number_exists, $number_partial, $number_start, $out_date, $out_date_after, $out_date_before, $out_date_exists, $out_date_start, $out_date_strictly_after, $out_date_strictly_before, $pdf, $pdf_base_name, $pdf_base_name_end, $pdf_base_name_exact, $pdf_base_name_exists, $pdf_base_name_partial, $pdf_base_name_start, $pdf_file_size, $pdf_file_size_between, $pdf_file_size_exists, $pdf_file_size_gt, $pdf_file_size_gte, $pdf_file_size_lt, $pdf_file_size_lte, $pdf_mime_type, $pdf_mime_type_end, $pdf_mime_type_exact, $pdf_mime_type_exists, $pdf_mime_type_partial, $pdf_mime_type_start, $scheduler, $scheduler2, $scheduler_exists, $status, $status_end, $status_exact, $status_exists, $status_partial, $status_start, $total, $total_with_tax, $total_with_tax_between, $total_with_tax_exists, $total_with_tax_gt, $total_with_tax_gte, $total_with_tax_lt, $total_with_tax_lte, $total_between, $total_exists, $total_gt, $total_gte, $total_lt, $total_lte, $_order_id, $_order_in_date, $_order_number, $_order_out_date, $_order_pdf_base_name, $_order_pdf_file_size, $_order_pdf_mime_type, $_order_status, $_order_total_with_tax, $_order_total, $_items_per_page, $_page, $_properties, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Invoice resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $in_date (optional)
     * @param  string $in_date_after (optional)
     * @param  string $in_date_before (optional)
     * @param  bool $in_date_exists (optional)
     * @param  string $in_date_start (optional)
     * @param  string $in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before (optional)
     * @param  string $invoice_template (optional)
     * @param  string $invoice_template2 (optional)
     * @param  bool $invoice_template_exists (optional)
     * @param  string $number (optional)
     * @param  string $number_sequence (optional)
     * @param  string $number_sequence2 (optional)
     * @param  bool $number_sequence_exists (optional)
     * @param  string $number_end (optional)
     * @param  string $number_exact (optional)
     * @param  bool $number_exists (optional)
     * @param  string $number_partial (optional)
     * @param  string $number_start (optional)
     * @param  string $out_date (optional)
     * @param  string $out_date_after (optional)
     * @param  string $out_date_before (optional)
     * @param  bool $out_date_exists (optional)
     * @param  string $out_date_start (optional)
     * @param  string $out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before (optional)
     * @param  string $pdf (optional)
     * @param  string $pdf_base_name (optional)
     * @param  string $pdf_base_name_end (optional)
     * @param  string $pdf_base_name_exact (optional)
     * @param  bool $pdf_base_name_exists (optional)
     * @param  string $pdf_base_name_partial (optional)
     * @param  string $pdf_base_name_start (optional)
     * @param  int $pdf_file_size (optional)
     * @param  string $pdf_file_size_between (optional)
     * @param  bool $pdf_file_size_exists (optional)
     * @param  string $pdf_file_size_gt (optional)
     * @param  string $pdf_file_size_gte (optional)
     * @param  string $pdf_file_size_lt (optional)
     * @param  string $pdf_file_size_lte (optional)
     * @param  string $pdf_mime_type (optional)
     * @param  string $pdf_mime_type_end (optional)
     * @param  string $pdf_mime_type_exact (optional)
     * @param  bool $pdf_mime_type_exists (optional)
     * @param  string $pdf_mime_type_partial (optional)
     * @param  string $pdf_mime_type_start (optional)
     * @param  string $scheduler (optional)
     * @param  string $scheduler2 (optional)
     * @param  bool $scheduler_exists (optional)
     * @param  string $status (optional)
     * @param  string $status_end (optional)
     * @param  string $status_exact (optional)
     * @param  bool $status_exists (optional)
     * @param  string $status_partial (optional)
     * @param  string $status_start (optional)
     * @param  string $total (optional)
     * @param  string $total_with_tax (optional)
     * @param  string $total_with_tax_between (optional)
     * @param  bool $total_with_tax_exists (optional)
     * @param  string $total_with_tax_gt (optional)
     * @param  string $total_with_tax_gte (optional)
     * @param  string $total_with_tax_lt (optional)
     * @param  string $total_with_tax_lte (optional)
     * @param  string $total_between (optional)
     * @param  bool $total_exists (optional)
     * @param  string $total_gt (optional)
     * @param  string $total_gte (optional)
     * @param  string $total_lt (optional)
     * @param  string $total_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_in_date (optional)
     * @param  string $_order_number (optional)
     * @param  string $_order_out_date (optional)
     * @param  string $_order_pdf_base_name (optional)
     * @param  string $_order_pdf_file_size (optional)
     * @param  string $_order_pdf_mime_type (optional)
     * @param  string $_order_status (optional)
     * @param  string $_order_total_with_tax (optional)
     * @param  string $_order_total (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceCollectionAsyncWithHttpInfo($company = null, $company2 = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_exists = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $number = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $number_end = null, $number_exact = null, $number_exists = null, $number_partial = null, $number_start = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_exists = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $pdf = null, $pdf_base_name = null, $pdf_base_name_end = null, $pdf_base_name_exact = null, $pdf_base_name_exists = null, $pdf_base_name_partial = null, $pdf_base_name_start = null, $pdf_file_size = null, $pdf_file_size_between = null, $pdf_file_size_exists = null, $pdf_file_size_gt = null, $pdf_file_size_gte = null, $pdf_file_size_lt = null, $pdf_file_size_lte = null, $pdf_mime_type = null, $pdf_mime_type_end = null, $pdf_mime_type_exact = null, $pdf_mime_type_exists = null, $pdf_mime_type_partial = null, $pdf_mime_type_start = null, $scheduler = null, $scheduler2 = null, $scheduler_exists = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $total = null, $total_with_tax = null, $total_with_tax_between = null, $total_with_tax_exists = null, $total_with_tax_gt = null, $total_with_tax_gte = null, $total_with_tax_lt = null, $total_with_tax_lte = null, $total_between = null, $total_exists = null, $total_gt = null, $total_gte = null, $total_lt = null, $total_lte = null, $_order_id = null, $_order_in_date = null, $_order_number = null, $_order_out_date = null, $_order_pdf_base_name = null, $_order_pdf_file_size = null, $_order_pdf_mime_type = null, $_order_status = null, $_order_total_with_tax = null, $_order_total = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceCollection[]';
        $request = $this->getInvoiceCollectionRequest($company, $company2, $id_exact, $in_date, $in_date_after, $in_date_before, $in_date_exists, $in_date_start, $in_date_strictly_after, $in_date_strictly_before, $invoice_template, $invoice_template2, $invoice_template_exists, $number, $number_sequence, $number_sequence2, $number_sequence_exists, $number_end, $number_exact, $number_exists, $number_partial, $number_start, $out_date, $out_date_after, $out_date_before, $out_date_exists, $out_date_start, $out_date_strictly_after, $out_date_strictly_before, $pdf, $pdf_base_name, $pdf_base_name_end, $pdf_base_name_exact, $pdf_base_name_exists, $pdf_base_name_partial, $pdf_base_name_start, $pdf_file_size, $pdf_file_size_between, $pdf_file_size_exists, $pdf_file_size_gt, $pdf_file_size_gte, $pdf_file_size_lt, $pdf_file_size_lte, $pdf_mime_type, $pdf_mime_type_end, $pdf_mime_type_exact, $pdf_mime_type_exists, $pdf_mime_type_partial, $pdf_mime_type_start, $scheduler, $scheduler2, $scheduler_exists, $status, $status_end, $status_exact, $status_exists, $status_partial, $status_start, $total, $total_with_tax, $total_with_tax_between, $total_with_tax_exists, $total_with_tax_gt, $total_with_tax_gte, $total_with_tax_lt, $total_with_tax_lte, $total_between, $total_exists, $total_gt, $total_gte, $total_lt, $total_lte, $_order_id, $_order_in_date, $_order_number, $_order_out_date, $_order_pdf_base_name, $_order_pdf_file_size, $_order_pdf_mime_type, $_order_status, $_order_total_with_tax, $_order_total, $_items_per_page, $_page, $_properties, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceCollection'
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $in_date (optional)
     * @param  string $in_date_after (optional)
     * @param  string $in_date_before (optional)
     * @param  bool $in_date_exists (optional)
     * @param  string $in_date_start (optional)
     * @param  string $in_date_strictly_after (optional)
     * @param  string $in_date_strictly_before (optional)
     * @param  string $invoice_template (optional)
     * @param  string $invoice_template2 (optional)
     * @param  bool $invoice_template_exists (optional)
     * @param  string $number (optional)
     * @param  string $number_sequence (optional)
     * @param  string $number_sequence2 (optional)
     * @param  bool $number_sequence_exists (optional)
     * @param  string $number_end (optional)
     * @param  string $number_exact (optional)
     * @param  bool $number_exists (optional)
     * @param  string $number_partial (optional)
     * @param  string $number_start (optional)
     * @param  string $out_date (optional)
     * @param  string $out_date_after (optional)
     * @param  string $out_date_before (optional)
     * @param  bool $out_date_exists (optional)
     * @param  string $out_date_start (optional)
     * @param  string $out_date_strictly_after (optional)
     * @param  string $out_date_strictly_before (optional)
     * @param  string $pdf (optional)
     * @param  string $pdf_base_name (optional)
     * @param  string $pdf_base_name_end (optional)
     * @param  string $pdf_base_name_exact (optional)
     * @param  bool $pdf_base_name_exists (optional)
     * @param  string $pdf_base_name_partial (optional)
     * @param  string $pdf_base_name_start (optional)
     * @param  int $pdf_file_size (optional)
     * @param  string $pdf_file_size_between (optional)
     * @param  bool $pdf_file_size_exists (optional)
     * @param  string $pdf_file_size_gt (optional)
     * @param  string $pdf_file_size_gte (optional)
     * @param  string $pdf_file_size_lt (optional)
     * @param  string $pdf_file_size_lte (optional)
     * @param  string $pdf_mime_type (optional)
     * @param  string $pdf_mime_type_end (optional)
     * @param  string $pdf_mime_type_exact (optional)
     * @param  bool $pdf_mime_type_exists (optional)
     * @param  string $pdf_mime_type_partial (optional)
     * @param  string $pdf_mime_type_start (optional)
     * @param  string $scheduler (optional)
     * @param  string $scheduler2 (optional)
     * @param  bool $scheduler_exists (optional)
     * @param  string $status (optional)
     * @param  string $status_end (optional)
     * @param  string $status_exact (optional)
     * @param  bool $status_exists (optional)
     * @param  string $status_partial (optional)
     * @param  string $status_start (optional)
     * @param  string $total (optional)
     * @param  string $total_with_tax (optional)
     * @param  string $total_with_tax_between (optional)
     * @param  bool $total_with_tax_exists (optional)
     * @param  string $total_with_tax_gt (optional)
     * @param  string $total_with_tax_gte (optional)
     * @param  string $total_with_tax_lt (optional)
     * @param  string $total_with_tax_lte (optional)
     * @param  string $total_between (optional)
     * @param  bool $total_exists (optional)
     * @param  string $total_gt (optional)
     * @param  string $total_gte (optional)
     * @param  string $total_lt (optional)
     * @param  string $total_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_in_date (optional)
     * @param  string $_order_number (optional)
     * @param  string $_order_out_date (optional)
     * @param  string $_order_pdf_base_name (optional)
     * @param  string $_order_pdf_file_size (optional)
     * @param  string $_order_pdf_mime_type (optional)
     * @param  string $_order_status (optional)
     * @param  string $_order_total_with_tax (optional)
     * @param  string $_order_total (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceCollectionRequest($company = null, $company2 = null, $id_exact = null, $in_date = null, $in_date_after = null, $in_date_before = null, $in_date_exists = null, $in_date_start = null, $in_date_strictly_after = null, $in_date_strictly_before = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $number = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $number_end = null, $number_exact = null, $number_exists = null, $number_partial = null, $number_start = null, $out_date = null, $out_date_after = null, $out_date_before = null, $out_date_exists = null, $out_date_start = null, $out_date_strictly_after = null, $out_date_strictly_before = null, $pdf = null, $pdf_base_name = null, $pdf_base_name_end = null, $pdf_base_name_exact = null, $pdf_base_name_exists = null, $pdf_base_name_partial = null, $pdf_base_name_start = null, $pdf_file_size = null, $pdf_file_size_between = null, $pdf_file_size_exists = null, $pdf_file_size_gt = null, $pdf_file_size_gte = null, $pdf_file_size_lt = null, $pdf_file_size_lte = null, $pdf_mime_type = null, $pdf_mime_type_end = null, $pdf_mime_type_exact = null, $pdf_mime_type_exists = null, $pdf_mime_type_partial = null, $pdf_mime_type_start = null, $scheduler = null, $scheduler2 = null, $scheduler_exists = null, $status = null, $status_end = null, $status_exact = null, $status_exists = null, $status_partial = null, $status_start = null, $total = null, $total_with_tax = null, $total_with_tax_between = null, $total_with_tax_exists = null, $total_with_tax_gt = null, $total_with_tax_gte = null, $total_with_tax_lt = null, $total_with_tax_lte = null, $total_between = null, $total_exists = null, $total_gt = null, $total_gte = null, $total_lt = null, $total_lte = null, $_order_id = null, $_order_in_date = null, $_order_number = null, $_order_out_date = null, $_order_pdf_base_name = null, $_order_pdf_file_size = null, $_order_pdf_mime_type = null, $_order_status = null, $_order_total_with_tax = null, $_order_total = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {

        $resourcePath = '/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($in_date !== null) {
            $queryParams['inDate'] = ObjectSerializer::toQueryValue($in_date);
        }
        // query params
        if ($in_date_after !== null) {
            $queryParams['inDate[after]'] = ObjectSerializer::toQueryValue($in_date_after);
        }
        // query params
        if ($in_date_before !== null) {
            $queryParams['inDate[before]'] = ObjectSerializer::toQueryValue($in_date_before);
        }
        // query params
        if ($in_date_exists !== null) {
            $queryParams['inDate[exists]'] = ObjectSerializer::toQueryValue($in_date_exists);
        }
        // query params
        if ($in_date_start !== null) {
            $queryParams['inDate[start]'] = ObjectSerializer::toQueryValue($in_date_start);
        }
        // query params
        if ($in_date_strictly_after !== null) {
            $queryParams['inDate[strictly_after]'] = ObjectSerializer::toQueryValue($in_date_strictly_after);
        }
        // query params
        if ($in_date_strictly_before !== null) {
            $queryParams['inDate[strictly_before]'] = ObjectSerializer::toQueryValue($in_date_strictly_before);
        }
        // query params
        if ($invoice_template !== null) {
            $queryParams['invoiceTemplate'] = ObjectSerializer::toQueryValue($invoice_template);
        }
        // query params
        if ($invoice_template2 !== null) {
            $queryParams['invoiceTemplate[]'] = ObjectSerializer::toQueryValue($invoice_template2);
        }
        // query params
        if ($invoice_template_exists !== null) {
            $queryParams['invoiceTemplate[exists]'] = ObjectSerializer::toQueryValue($invoice_template_exists);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($number_sequence !== null) {
            $queryParams['numberSequence'] = ObjectSerializer::toQueryValue($number_sequence);
        }
        // query params
        if ($number_sequence2 !== null) {
            $queryParams['numberSequence[]'] = ObjectSerializer::toQueryValue($number_sequence2);
        }
        // query params
        if ($number_sequence_exists !== null) {
            $queryParams['numberSequence[exists]'] = ObjectSerializer::toQueryValue($number_sequence_exists);
        }
        // query params
        if ($number_end !== null) {
            $queryParams['number[end]'] = ObjectSerializer::toQueryValue($number_end);
        }
        // query params
        if ($number_exact !== null) {
            $queryParams['number[exact]'] = ObjectSerializer::toQueryValue($number_exact);
        }
        // query params
        if ($number_exists !== null) {
            $queryParams['number[exists]'] = ObjectSerializer::toQueryValue($number_exists);
        }
        // query params
        if ($number_partial !== null) {
            $queryParams['number[partial]'] = ObjectSerializer::toQueryValue($number_partial);
        }
        // query params
        if ($number_start !== null) {
            $queryParams['number[start]'] = ObjectSerializer::toQueryValue($number_start);
        }
        // query params
        if ($out_date !== null) {
            $queryParams['outDate'] = ObjectSerializer::toQueryValue($out_date);
        }
        // query params
        if ($out_date_after !== null) {
            $queryParams['outDate[after]'] = ObjectSerializer::toQueryValue($out_date_after);
        }
        // query params
        if ($out_date_before !== null) {
            $queryParams['outDate[before]'] = ObjectSerializer::toQueryValue($out_date_before);
        }
        // query params
        if ($out_date_exists !== null) {
            $queryParams['outDate[exists]'] = ObjectSerializer::toQueryValue($out_date_exists);
        }
        // query params
        if ($out_date_start !== null) {
            $queryParams['outDate[start]'] = ObjectSerializer::toQueryValue($out_date_start);
        }
        // query params
        if ($out_date_strictly_after !== null) {
            $queryParams['outDate[strictly_after]'] = ObjectSerializer::toQueryValue($out_date_strictly_after);
        }
        // query params
        if ($out_date_strictly_before !== null) {
            $queryParams['outDate[strictly_before]'] = ObjectSerializer::toQueryValue($out_date_strictly_before);
        }
        // query params
        if ($pdf !== null) {
            $queryParams['pdf'] = ObjectSerializer::toQueryValue($pdf);
        }
        // query params
        if ($pdf_base_name !== null) {
            $queryParams['pdf.baseName'] = ObjectSerializer::toQueryValue($pdf_base_name);
        }
        // query params
        if ($pdf_base_name_end !== null) {
            $queryParams['pdf.baseName[end]'] = ObjectSerializer::toQueryValue($pdf_base_name_end);
        }
        // query params
        if ($pdf_base_name_exact !== null) {
            $queryParams['pdf.baseName[exact]'] = ObjectSerializer::toQueryValue($pdf_base_name_exact);
        }
        // query params
        if ($pdf_base_name_exists !== null) {
            $queryParams['pdf.baseName[exists]'] = ObjectSerializer::toQueryValue($pdf_base_name_exists);
        }
        // query params
        if ($pdf_base_name_partial !== null) {
            $queryParams['pdf.baseName[partial]'] = ObjectSerializer::toQueryValue($pdf_base_name_partial);
        }
        // query params
        if ($pdf_base_name_start !== null) {
            $queryParams['pdf.baseName[start]'] = ObjectSerializer::toQueryValue($pdf_base_name_start);
        }
        // query params
        if ($pdf_file_size !== null) {
            $queryParams['pdf.fileSize'] = ObjectSerializer::toQueryValue($pdf_file_size);
        }
        // query params
        if ($pdf_file_size_between !== null) {
            $queryParams['pdf.fileSize[between]'] = ObjectSerializer::toQueryValue($pdf_file_size_between);
        }
        // query params
        if ($pdf_file_size_exists !== null) {
            $queryParams['pdf.fileSize[exists]'] = ObjectSerializer::toQueryValue($pdf_file_size_exists);
        }
        // query params
        if ($pdf_file_size_gt !== null) {
            $queryParams['pdf.fileSize[gt]'] = ObjectSerializer::toQueryValue($pdf_file_size_gt);
        }
        // query params
        if ($pdf_file_size_gte !== null) {
            $queryParams['pdf.fileSize[gte]'] = ObjectSerializer::toQueryValue($pdf_file_size_gte);
        }
        // query params
        if ($pdf_file_size_lt !== null) {
            $queryParams['pdf.fileSize[lt]'] = ObjectSerializer::toQueryValue($pdf_file_size_lt);
        }
        // query params
        if ($pdf_file_size_lte !== null) {
            $queryParams['pdf.fileSize[lte]'] = ObjectSerializer::toQueryValue($pdf_file_size_lte);
        }
        // query params
        if ($pdf_mime_type !== null) {
            $queryParams['pdf.mimeType'] = ObjectSerializer::toQueryValue($pdf_mime_type);
        }
        // query params
        if ($pdf_mime_type_end !== null) {
            $queryParams['pdf.mimeType[end]'] = ObjectSerializer::toQueryValue($pdf_mime_type_end);
        }
        // query params
        if ($pdf_mime_type_exact !== null) {
            $queryParams['pdf.mimeType[exact]'] = ObjectSerializer::toQueryValue($pdf_mime_type_exact);
        }
        // query params
        if ($pdf_mime_type_exists !== null) {
            $queryParams['pdf.mimeType[exists]'] = ObjectSerializer::toQueryValue($pdf_mime_type_exists);
        }
        // query params
        if ($pdf_mime_type_partial !== null) {
            $queryParams['pdf.mimeType[partial]'] = ObjectSerializer::toQueryValue($pdf_mime_type_partial);
        }
        // query params
        if ($pdf_mime_type_start !== null) {
            $queryParams['pdf.mimeType[start]'] = ObjectSerializer::toQueryValue($pdf_mime_type_start);
        }
        // query params
        if ($scheduler !== null) {
            $queryParams['scheduler'] = ObjectSerializer::toQueryValue($scheduler);
        }
        // query params
        if ($scheduler2 !== null) {
            $queryParams['scheduler[]'] = ObjectSerializer::toQueryValue($scheduler2);
        }
        // query params
        if ($scheduler_exists !== null) {
            $queryParams['scheduler[exists]'] = ObjectSerializer::toQueryValue($scheduler_exists);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($status_end !== null) {
            $queryParams['status[end]'] = ObjectSerializer::toQueryValue($status_end);
        }
        // query params
        if ($status_exact !== null) {
            $queryParams['status[exact]'] = ObjectSerializer::toQueryValue($status_exact);
        }
        // query params
        if ($status_exists !== null) {
            $queryParams['status[exists]'] = ObjectSerializer::toQueryValue($status_exists);
        }
        // query params
        if ($status_partial !== null) {
            $queryParams['status[partial]'] = ObjectSerializer::toQueryValue($status_partial);
        }
        // query params
        if ($status_start !== null) {
            $queryParams['status[start]'] = ObjectSerializer::toQueryValue($status_start);
        }
        // query params
        if ($total !== null) {
            $queryParams['total'] = ObjectSerializer::toQueryValue($total);
        }
        // query params
        if ($total_with_tax !== null) {
            $queryParams['totalWithTax'] = ObjectSerializer::toQueryValue($total_with_tax);
        }
        // query params
        if ($total_with_tax_between !== null) {
            $queryParams['totalWithTax[between]'] = ObjectSerializer::toQueryValue($total_with_tax_between);
        }
        // query params
        if ($total_with_tax_exists !== null) {
            $queryParams['totalWithTax[exists]'] = ObjectSerializer::toQueryValue($total_with_tax_exists);
        }
        // query params
        if ($total_with_tax_gt !== null) {
            $queryParams['totalWithTax[gt]'] = ObjectSerializer::toQueryValue($total_with_tax_gt);
        }
        // query params
        if ($total_with_tax_gte !== null) {
            $queryParams['totalWithTax[gte]'] = ObjectSerializer::toQueryValue($total_with_tax_gte);
        }
        // query params
        if ($total_with_tax_lt !== null) {
            $queryParams['totalWithTax[lt]'] = ObjectSerializer::toQueryValue($total_with_tax_lt);
        }
        // query params
        if ($total_with_tax_lte !== null) {
            $queryParams['totalWithTax[lte]'] = ObjectSerializer::toQueryValue($total_with_tax_lte);
        }
        // query params
        if ($total_between !== null) {
            $queryParams['total[between]'] = ObjectSerializer::toQueryValue($total_between);
        }
        // query params
        if ($total_exists !== null) {
            $queryParams['total[exists]'] = ObjectSerializer::toQueryValue($total_exists);
        }
        // query params
        if ($total_gt !== null) {
            $queryParams['total[gt]'] = ObjectSerializer::toQueryValue($total_gt);
        }
        // query params
        if ($total_gte !== null) {
            $queryParams['total[gte]'] = ObjectSerializer::toQueryValue($total_gte);
        }
        // query params
        if ($total_lt !== null) {
            $queryParams['total[lt]'] = ObjectSerializer::toQueryValue($total_lt);
        }
        // query params
        if ($total_lte !== null) {
            $queryParams['total[lte]'] = ObjectSerializer::toQueryValue($total_lte);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_in_date !== null) {
            $queryParams['_order[inDate]'] = ObjectSerializer::toQueryValue($_order_in_date);
        }
        // query params
        if ($_order_number !== null) {
            $queryParams['_order[number]'] = ObjectSerializer::toQueryValue($_order_number);
        }
        // query params
        if ($_order_out_date !== null) {
            $queryParams['_order[outDate]'] = ObjectSerializer::toQueryValue($_order_out_date);
        }
        // query params
        if ($_order_pdf_base_name !== null) {
            $queryParams['_order[pdf.baseName]'] = ObjectSerializer::toQueryValue($_order_pdf_base_name);
        }
        // query params
        if ($_order_pdf_file_size !== null) {
            $queryParams['_order[pdf.fileSize]'] = ObjectSerializer::toQueryValue($_order_pdf_file_size);
        }
        // query params
        if ($_order_pdf_mime_type !== null) {
            $queryParams['_order[pdf.mimeType]'] = ObjectSerializer::toQueryValue($_order_pdf_mime_type);
        }
        // query params
        if ($_order_status !== null) {
            $queryParams['_order[status]'] = ObjectSerializer::toQueryValue($_order_status);
        }
        // query params
        if ($_order_total_with_tax !== null) {
            $queryParams['_order[totalWithTax]'] = ObjectSerializer::toQueryValue($_order_total_with_tax);
        }
        // query params
        if ($_order_total !== null) {
            $queryParams['_order[total]'] = ObjectSerializer::toQueryValue($_order_total);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceItem
     *
     * Retrieves a Invoice resource.
     *
     * @param  string $id id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceDetailed
     */
    public function getInvoiceItem($id, $_timezone = null)
    {
        list($response) = $this->getInvoiceItemWithHttpInfo($id, $_timezone);
        return $response;
    }

    /**
     * Operation getInvoiceItemWithHttpInfo
     *
     * Retrieves a Invoice resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceItemWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceDetailed';
        $request = $this->getInvoiceItemRequest($id, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceItemAsync
     *
     * Retrieves a Invoice resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceItemAsync($id, $_timezone = null)
    {
        return $this->getInvoiceItemAsyncWithHttpInfo($id, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceItemAsyncWithHttpInfo
     *
     * Retrieves a Invoice resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceItemAsyncWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceDetailed';
        $request = $this->getInvoiceItemRequest($id, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceItem'
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceItemRequest($id, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInvoiceItem'
            );
        }

        $resourcePath = '/invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceNumberSequenceCollection
     *
     * Retrieves the collection of InvoiceNumberSequence resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $latest_value latest_value (optional)
     * @param  string $latest_value_end latest_value_end (optional)
     * @param  string $latest_value_exact latest_value_exact (optional)
     * @param  bool $latest_value_exists latest_value_exists (optional)
     * @param  string $latest_value_partial latest_value_partial (optional)
     * @param  string $latest_value_start latest_value_start (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_latest_value _order_latest_value (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceNumberSequenceCollection[]
     */
    public function getInvoiceNumberSequenceCollection($id_exact = null, $latest_value = null, $latest_value_end = null, $latest_value_exact = null, $latest_value_exists = null, $latest_value_partial = null, $latest_value_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_latest_value = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getInvoiceNumberSequenceCollectionWithHttpInfo($id_exact, $latest_value, $latest_value_end, $latest_value_exact, $latest_value_exists, $latest_value_partial, $latest_value_start, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_latest_value, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getInvoiceNumberSequenceCollectionWithHttpInfo
     *
     * Retrieves the collection of InvoiceNumberSequence resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $latest_value (optional)
     * @param  string $latest_value_end (optional)
     * @param  string $latest_value_exact (optional)
     * @param  bool $latest_value_exists (optional)
     * @param  string $latest_value_partial (optional)
     * @param  string $latest_value_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_latest_value (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceNumberSequenceCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceNumberSequenceCollectionWithHttpInfo($id_exact = null, $latest_value = null, $latest_value_end = null, $latest_value_exact = null, $latest_value_exists = null, $latest_value_partial = null, $latest_value_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_latest_value = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceNumberSequenceCollection[]';
        $request = $this->getInvoiceNumberSequenceCollectionRequest($id_exact, $latest_value, $latest_value_end, $latest_value_exact, $latest_value_exists, $latest_value_partial, $latest_value_start, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_latest_value, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceNumberSequenceCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceNumberSequenceCollectionAsync
     *
     * Retrieves the collection of InvoiceNumberSequence resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $latest_value (optional)
     * @param  string $latest_value_end (optional)
     * @param  string $latest_value_exact (optional)
     * @param  bool $latest_value_exists (optional)
     * @param  string $latest_value_partial (optional)
     * @param  string $latest_value_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_latest_value (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceNumberSequenceCollectionAsync($id_exact = null, $latest_value = null, $latest_value_end = null, $latest_value_exact = null, $latest_value_exists = null, $latest_value_partial = null, $latest_value_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_latest_value = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getInvoiceNumberSequenceCollectionAsyncWithHttpInfo($id_exact, $latest_value, $latest_value_end, $latest_value_exact, $latest_value_exists, $latest_value_partial, $latest_value_start, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_latest_value, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceNumberSequenceCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of InvoiceNumberSequence resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $latest_value (optional)
     * @param  string $latest_value_end (optional)
     * @param  string $latest_value_exact (optional)
     * @param  bool $latest_value_exists (optional)
     * @param  string $latest_value_partial (optional)
     * @param  string $latest_value_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_latest_value (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceNumberSequenceCollectionAsyncWithHttpInfo($id_exact = null, $latest_value = null, $latest_value_end = null, $latest_value_exact = null, $latest_value_exists = null, $latest_value_partial = null, $latest_value_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_latest_value = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceNumberSequenceCollection[]';
        $request = $this->getInvoiceNumberSequenceCollectionRequest($id_exact, $latest_value, $latest_value_end, $latest_value_exact, $latest_value_exists, $latest_value_partial, $latest_value_start, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_latest_value, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceNumberSequenceCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $latest_value (optional)
     * @param  string $latest_value_end (optional)
     * @param  string $latest_value_exact (optional)
     * @param  bool $latest_value_exists (optional)
     * @param  string $latest_value_partial (optional)
     * @param  string $latest_value_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_latest_value (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceNumberSequenceCollectionRequest($id_exact = null, $latest_value = null, $latest_value_end = null, $latest_value_exact = null, $latest_value_exists = null, $latest_value_partial = null, $latest_value_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_latest_value = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/invoice_number_sequences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($latest_value !== null) {
            $queryParams['latestValue'] = ObjectSerializer::toQueryValue($latest_value);
        }
        // query params
        if ($latest_value_end !== null) {
            $queryParams['latestValue[end]'] = ObjectSerializer::toQueryValue($latest_value_end);
        }
        // query params
        if ($latest_value_exact !== null) {
            $queryParams['latestValue[exact]'] = ObjectSerializer::toQueryValue($latest_value_exact);
        }
        // query params
        if ($latest_value_exists !== null) {
            $queryParams['latestValue[exists]'] = ObjectSerializer::toQueryValue($latest_value_exists);
        }
        // query params
        if ($latest_value_partial !== null) {
            $queryParams['latestValue[partial]'] = ObjectSerializer::toQueryValue($latest_value_partial);
        }
        // query params
        if ($latest_value_start !== null) {
            $queryParams['latestValue[start]'] = ObjectSerializer::toQueryValue($latest_value_start);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_latest_value !== null) {
            $queryParams['_order[latestValue]'] = ObjectSerializer::toQueryValue($_order_latest_value);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceNumberSequenceItem
     *
     * Retrieves a InvoiceNumberSequence resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceNumberSequenceDetailed
     */
    public function getInvoiceNumberSequenceItem($id)
    {
        list($response) = $this->getInvoiceNumberSequenceItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getInvoiceNumberSequenceItemWithHttpInfo
     *
     * Retrieves a InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceNumberSequenceDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceNumberSequenceItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\InvoiceNumberSequenceDetailed';
        $request = $this->getInvoiceNumberSequenceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceNumberSequenceDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceNumberSequenceItemAsync
     *
     * Retrieves a InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceNumberSequenceItemAsync($id)
    {
        return $this->getInvoiceNumberSequenceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceNumberSequenceItemAsyncWithHttpInfo
     *
     * Retrieves a InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceNumberSequenceItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\InvoiceNumberSequenceDetailed';
        $request = $this->getInvoiceNumberSequenceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceNumberSequenceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceNumberSequenceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInvoiceNumberSequenceItem'
            );
        }

        $resourcePath = '/invoice_number_sequences/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceSchedulerCollection
     *
     * Retrieves the collection of InvoiceScheduler resources.
     *
     * @param  string $brand brand (optional)
     * @param  string $brand2 brand2 (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  int $frequency frequency (optional)
     * @param  string $frequency_between frequency_between (optional)
     * @param  string $frequency_gt frequency_gt (optional)
     * @param  string $frequency_gte frequency_gte (optional)
     * @param  string $frequency_lt frequency_lt (optional)
     * @param  string $frequency_lte frequency_lte (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $invoice_template invoice_template (optional)
     * @param  string $invoice_template2 invoice_template2 (optional)
     * @param  bool $invoice_template_exists invoice_template_exists (optional)
     * @param  string $last_execution last_execution (optional)
     * @param  string $last_execution_after last_execution_after (optional)
     * @param  string $last_execution_before last_execution_before (optional)
     * @param  bool $last_execution_exists last_execution_exists (optional)
     * @param  string $last_execution_start last_execution_start (optional)
     * @param  string $last_execution_strictly_after last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before last_execution_strictly_before (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $next_execution next_execution (optional)
     * @param  string $next_execution_after next_execution_after (optional)
     * @param  string $next_execution_before next_execution_before (optional)
     * @param  bool $next_execution_exists next_execution_exists (optional)
     * @param  string $next_execution_start next_execution_start (optional)
     * @param  string $next_execution_strictly_after next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before next_execution_strictly_before (optional)
     * @param  string $number_sequence number_sequence (optional)
     * @param  string $number_sequence2 number_sequence2 (optional)
     * @param  bool $number_sequence_exists number_sequence_exists (optional)
     * @param  string $unit unit (optional)
     * @param  string $unit_end unit_end (optional)
     * @param  string $unit_exact unit_exact (optional)
     * @param  string $unit_partial unit_partial (optional)
     * @param  string $unit_start unit_start (optional)
     * @param  string $_order_frequency _order_frequency (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_last_execution _order_last_execution (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_next_execution _order_next_execution (optional)
     * @param  string $_order_unit _order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceSchedulerCollection[]
     */
    public function getInvoiceSchedulerCollection($brand = null, $brand2 = null, $company = null, $company2 = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $id_exact = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $last_execution = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $_order_frequency = null, $_order_id = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        list($response) = $this->getInvoiceSchedulerCollectionWithHttpInfo($brand, $brand2, $company, $company2, $frequency, $frequency_between, $frequency_gt, $frequency_gte, $frequency_lt, $frequency_lte, $id_exact, $invoice_template, $invoice_template2, $invoice_template_exists, $last_execution, $last_execution_after, $last_execution_before, $last_execution_exists, $last_execution_start, $last_execution_strictly_after, $last_execution_strictly_before, $name, $name_end, $name_exact, $name_partial, $name_start, $next_execution, $next_execution_after, $next_execution_before, $next_execution_exists, $next_execution_start, $next_execution_strictly_after, $next_execution_strictly_before, $number_sequence, $number_sequence2, $number_sequence_exists, $unit, $unit_end, $unit_exact, $unit_partial, $unit_start, $_order_frequency, $_order_id, $_order_last_execution, $_order_name, $_order_next_execution, $_order_unit, $_items_per_page, $_page, $_properties, $_timezone);
        return $response;
    }

    /**
     * Operation getInvoiceSchedulerCollectionWithHttpInfo
     *
     * Retrieves the collection of InvoiceScheduler resources.
     *
     * @param  string $brand (optional)
     * @param  string $brand2 (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $frequency (optional)
     * @param  string $frequency_between (optional)
     * @param  string $frequency_gt (optional)
     * @param  string $frequency_gte (optional)
     * @param  string $frequency_lt (optional)
     * @param  string $frequency_lte (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_template (optional)
     * @param  string $invoice_template2 (optional)
     * @param  bool $invoice_template_exists (optional)
     * @param  string $last_execution (optional)
     * @param  string $last_execution_after (optional)
     * @param  string $last_execution_before (optional)
     * @param  bool $last_execution_exists (optional)
     * @param  string $last_execution_start (optional)
     * @param  string $last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $next_execution (optional)
     * @param  string $next_execution_after (optional)
     * @param  string $next_execution_before (optional)
     * @param  bool $next_execution_exists (optional)
     * @param  string $next_execution_start (optional)
     * @param  string $next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before (optional)
     * @param  string $number_sequence (optional)
     * @param  string $number_sequence2 (optional)
     * @param  bool $number_sequence_exists (optional)
     * @param  string $unit (optional)
     * @param  string $unit_end (optional)
     * @param  string $unit_exact (optional)
     * @param  string $unit_partial (optional)
     * @param  string $unit_start (optional)
     * @param  string $_order_frequency (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_last_execution (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_next_execution (optional)
     * @param  string $_order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceSchedulerCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceSchedulerCollectionWithHttpInfo($brand = null, $brand2 = null, $company = null, $company2 = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $id_exact = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $last_execution = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $_order_frequency = null, $_order_id = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceSchedulerCollection[]';
        $request = $this->getInvoiceSchedulerCollectionRequest($brand, $brand2, $company, $company2, $frequency, $frequency_between, $frequency_gt, $frequency_gte, $frequency_lt, $frequency_lte, $id_exact, $invoice_template, $invoice_template2, $invoice_template_exists, $last_execution, $last_execution_after, $last_execution_before, $last_execution_exists, $last_execution_start, $last_execution_strictly_after, $last_execution_strictly_before, $name, $name_end, $name_exact, $name_partial, $name_start, $next_execution, $next_execution_after, $next_execution_before, $next_execution_exists, $next_execution_start, $next_execution_strictly_after, $next_execution_strictly_before, $number_sequence, $number_sequence2, $number_sequence_exists, $unit, $unit_end, $unit_exact, $unit_partial, $unit_start, $_order_frequency, $_order_id, $_order_last_execution, $_order_name, $_order_next_execution, $_order_unit, $_items_per_page, $_page, $_properties, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceSchedulerCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceSchedulerCollectionAsync
     *
     * Retrieves the collection of InvoiceScheduler resources.
     *
     * @param  string $brand (optional)
     * @param  string $brand2 (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $frequency (optional)
     * @param  string $frequency_between (optional)
     * @param  string $frequency_gt (optional)
     * @param  string $frequency_gte (optional)
     * @param  string $frequency_lt (optional)
     * @param  string $frequency_lte (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_template (optional)
     * @param  string $invoice_template2 (optional)
     * @param  bool $invoice_template_exists (optional)
     * @param  string $last_execution (optional)
     * @param  string $last_execution_after (optional)
     * @param  string $last_execution_before (optional)
     * @param  bool $last_execution_exists (optional)
     * @param  string $last_execution_start (optional)
     * @param  string $last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $next_execution (optional)
     * @param  string $next_execution_after (optional)
     * @param  string $next_execution_before (optional)
     * @param  bool $next_execution_exists (optional)
     * @param  string $next_execution_start (optional)
     * @param  string $next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before (optional)
     * @param  string $number_sequence (optional)
     * @param  string $number_sequence2 (optional)
     * @param  bool $number_sequence_exists (optional)
     * @param  string $unit (optional)
     * @param  string $unit_end (optional)
     * @param  string $unit_exact (optional)
     * @param  string $unit_partial (optional)
     * @param  string $unit_start (optional)
     * @param  string $_order_frequency (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_last_execution (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_next_execution (optional)
     * @param  string $_order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceSchedulerCollectionAsync($brand = null, $brand2 = null, $company = null, $company2 = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $id_exact = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $last_execution = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $_order_frequency = null, $_order_id = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        return $this->getInvoiceSchedulerCollectionAsyncWithHttpInfo($brand, $brand2, $company, $company2, $frequency, $frequency_between, $frequency_gt, $frequency_gte, $frequency_lt, $frequency_lte, $id_exact, $invoice_template, $invoice_template2, $invoice_template_exists, $last_execution, $last_execution_after, $last_execution_before, $last_execution_exists, $last_execution_start, $last_execution_strictly_after, $last_execution_strictly_before, $name, $name_end, $name_exact, $name_partial, $name_start, $next_execution, $next_execution_after, $next_execution_before, $next_execution_exists, $next_execution_start, $next_execution_strictly_after, $next_execution_strictly_before, $number_sequence, $number_sequence2, $number_sequence_exists, $unit, $unit_end, $unit_exact, $unit_partial, $unit_start, $_order_frequency, $_order_id, $_order_last_execution, $_order_name, $_order_next_execution, $_order_unit, $_items_per_page, $_page, $_properties, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceSchedulerCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of InvoiceScheduler resources.
     *
     * @param  string $brand (optional)
     * @param  string $brand2 (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $frequency (optional)
     * @param  string $frequency_between (optional)
     * @param  string $frequency_gt (optional)
     * @param  string $frequency_gte (optional)
     * @param  string $frequency_lt (optional)
     * @param  string $frequency_lte (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_template (optional)
     * @param  string $invoice_template2 (optional)
     * @param  bool $invoice_template_exists (optional)
     * @param  string $last_execution (optional)
     * @param  string $last_execution_after (optional)
     * @param  string $last_execution_before (optional)
     * @param  bool $last_execution_exists (optional)
     * @param  string $last_execution_start (optional)
     * @param  string $last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $next_execution (optional)
     * @param  string $next_execution_after (optional)
     * @param  string $next_execution_before (optional)
     * @param  bool $next_execution_exists (optional)
     * @param  string $next_execution_start (optional)
     * @param  string $next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before (optional)
     * @param  string $number_sequence (optional)
     * @param  string $number_sequence2 (optional)
     * @param  bool $number_sequence_exists (optional)
     * @param  string $unit (optional)
     * @param  string $unit_end (optional)
     * @param  string $unit_exact (optional)
     * @param  string $unit_partial (optional)
     * @param  string $unit_start (optional)
     * @param  string $_order_frequency (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_last_execution (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_next_execution (optional)
     * @param  string $_order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceSchedulerCollectionAsyncWithHttpInfo($brand = null, $brand2 = null, $company = null, $company2 = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $id_exact = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $last_execution = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $_order_frequency = null, $_order_id = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceSchedulerCollection[]';
        $request = $this->getInvoiceSchedulerCollectionRequest($brand, $brand2, $company, $company2, $frequency, $frequency_between, $frequency_gt, $frequency_gte, $frequency_lt, $frequency_lte, $id_exact, $invoice_template, $invoice_template2, $invoice_template_exists, $last_execution, $last_execution_after, $last_execution_before, $last_execution_exists, $last_execution_start, $last_execution_strictly_after, $last_execution_strictly_before, $name, $name_end, $name_exact, $name_partial, $name_start, $next_execution, $next_execution_after, $next_execution_before, $next_execution_exists, $next_execution_start, $next_execution_strictly_after, $next_execution_strictly_before, $number_sequence, $number_sequence2, $number_sequence_exists, $unit, $unit_end, $unit_exact, $unit_partial, $unit_start, $_order_frequency, $_order_id, $_order_last_execution, $_order_name, $_order_next_execution, $_order_unit, $_items_per_page, $_page, $_properties, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceSchedulerCollection'
     *
     * @param  string $brand (optional)
     * @param  string $brand2 (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $frequency (optional)
     * @param  string $frequency_between (optional)
     * @param  string $frequency_gt (optional)
     * @param  string $frequency_gte (optional)
     * @param  string $frequency_lt (optional)
     * @param  string $frequency_lte (optional)
     * @param  int $id_exact (optional)
     * @param  string $invoice_template (optional)
     * @param  string $invoice_template2 (optional)
     * @param  bool $invoice_template_exists (optional)
     * @param  string $last_execution (optional)
     * @param  string $last_execution_after (optional)
     * @param  string $last_execution_before (optional)
     * @param  bool $last_execution_exists (optional)
     * @param  string $last_execution_start (optional)
     * @param  string $last_execution_strictly_after (optional)
     * @param  string $last_execution_strictly_before (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $next_execution (optional)
     * @param  string $next_execution_after (optional)
     * @param  string $next_execution_before (optional)
     * @param  bool $next_execution_exists (optional)
     * @param  string $next_execution_start (optional)
     * @param  string $next_execution_strictly_after (optional)
     * @param  string $next_execution_strictly_before (optional)
     * @param  string $number_sequence (optional)
     * @param  string $number_sequence2 (optional)
     * @param  bool $number_sequence_exists (optional)
     * @param  string $unit (optional)
     * @param  string $unit_end (optional)
     * @param  string $unit_exact (optional)
     * @param  string $unit_partial (optional)
     * @param  string $unit_start (optional)
     * @param  string $_order_frequency (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_last_execution (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_next_execution (optional)
     * @param  string $_order_unit (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceSchedulerCollectionRequest($brand = null, $brand2 = null, $company = null, $company2 = null, $frequency = null, $frequency_between = null, $frequency_gt = null, $frequency_gte = null, $frequency_lt = null, $frequency_lte = null, $id_exact = null, $invoice_template = null, $invoice_template2 = null, $invoice_template_exists = null, $last_execution = null, $last_execution_after = null, $last_execution_before = null, $last_execution_exists = null, $last_execution_start = null, $last_execution_strictly_after = null, $last_execution_strictly_before = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $next_execution = null, $next_execution_after = null, $next_execution_before = null, $next_execution_exists = null, $next_execution_start = null, $next_execution_strictly_after = null, $next_execution_strictly_before = null, $number_sequence = null, $number_sequence2 = null, $number_sequence_exists = null, $unit = null, $unit_end = null, $unit_exact = null, $unit_partial = null, $unit_start = null, $_order_frequency = null, $_order_id = null, $_order_last_execution = null, $_order_name = null, $_order_next_execution = null, $_order_unit = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {

        $resourcePath = '/invoice_schedulers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($brand !== null) {
            $queryParams['brand'] = ObjectSerializer::toQueryValue($brand);
        }
        // query params
        if ($brand2 !== null) {
            $queryParams['brand[]'] = ObjectSerializer::toQueryValue($brand2);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($frequency !== null) {
            $queryParams['frequency'] = ObjectSerializer::toQueryValue($frequency);
        }
        // query params
        if ($frequency_between !== null) {
            $queryParams['frequency[between]'] = ObjectSerializer::toQueryValue($frequency_between);
        }
        // query params
        if ($frequency_gt !== null) {
            $queryParams['frequency[gt]'] = ObjectSerializer::toQueryValue($frequency_gt);
        }
        // query params
        if ($frequency_gte !== null) {
            $queryParams['frequency[gte]'] = ObjectSerializer::toQueryValue($frequency_gte);
        }
        // query params
        if ($frequency_lt !== null) {
            $queryParams['frequency[lt]'] = ObjectSerializer::toQueryValue($frequency_lt);
        }
        // query params
        if ($frequency_lte !== null) {
            $queryParams['frequency[lte]'] = ObjectSerializer::toQueryValue($frequency_lte);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($invoice_template !== null) {
            $queryParams['invoiceTemplate'] = ObjectSerializer::toQueryValue($invoice_template);
        }
        // query params
        if ($invoice_template2 !== null) {
            $queryParams['invoiceTemplate[]'] = ObjectSerializer::toQueryValue($invoice_template2);
        }
        // query params
        if ($invoice_template_exists !== null) {
            $queryParams['invoiceTemplate[exists]'] = ObjectSerializer::toQueryValue($invoice_template_exists);
        }
        // query params
        if ($last_execution !== null) {
            $queryParams['lastExecution'] = ObjectSerializer::toQueryValue($last_execution);
        }
        // query params
        if ($last_execution_after !== null) {
            $queryParams['lastExecution[after]'] = ObjectSerializer::toQueryValue($last_execution_after);
        }
        // query params
        if ($last_execution_before !== null) {
            $queryParams['lastExecution[before]'] = ObjectSerializer::toQueryValue($last_execution_before);
        }
        // query params
        if ($last_execution_exists !== null) {
            $queryParams['lastExecution[exists]'] = ObjectSerializer::toQueryValue($last_execution_exists);
        }
        // query params
        if ($last_execution_start !== null) {
            $queryParams['lastExecution[start]'] = ObjectSerializer::toQueryValue($last_execution_start);
        }
        // query params
        if ($last_execution_strictly_after !== null) {
            $queryParams['lastExecution[strictly_after]'] = ObjectSerializer::toQueryValue($last_execution_strictly_after);
        }
        // query params
        if ($last_execution_strictly_before !== null) {
            $queryParams['lastExecution[strictly_before]'] = ObjectSerializer::toQueryValue($last_execution_strictly_before);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($next_execution !== null) {
            $queryParams['nextExecution'] = ObjectSerializer::toQueryValue($next_execution);
        }
        // query params
        if ($next_execution_after !== null) {
            $queryParams['nextExecution[after]'] = ObjectSerializer::toQueryValue($next_execution_after);
        }
        // query params
        if ($next_execution_before !== null) {
            $queryParams['nextExecution[before]'] = ObjectSerializer::toQueryValue($next_execution_before);
        }
        // query params
        if ($next_execution_exists !== null) {
            $queryParams['nextExecution[exists]'] = ObjectSerializer::toQueryValue($next_execution_exists);
        }
        // query params
        if ($next_execution_start !== null) {
            $queryParams['nextExecution[start]'] = ObjectSerializer::toQueryValue($next_execution_start);
        }
        // query params
        if ($next_execution_strictly_after !== null) {
            $queryParams['nextExecution[strictly_after]'] = ObjectSerializer::toQueryValue($next_execution_strictly_after);
        }
        // query params
        if ($next_execution_strictly_before !== null) {
            $queryParams['nextExecution[strictly_before]'] = ObjectSerializer::toQueryValue($next_execution_strictly_before);
        }
        // query params
        if ($number_sequence !== null) {
            $queryParams['numberSequence'] = ObjectSerializer::toQueryValue($number_sequence);
        }
        // query params
        if ($number_sequence2 !== null) {
            $queryParams['numberSequence[]'] = ObjectSerializer::toQueryValue($number_sequence2);
        }
        // query params
        if ($number_sequence_exists !== null) {
            $queryParams['numberSequence[exists]'] = ObjectSerializer::toQueryValue($number_sequence_exists);
        }
        // query params
        if ($unit !== null) {
            $queryParams['unit'] = ObjectSerializer::toQueryValue($unit);
        }
        // query params
        if ($unit_end !== null) {
            $queryParams['unit[end]'] = ObjectSerializer::toQueryValue($unit_end);
        }
        // query params
        if ($unit_exact !== null) {
            $queryParams['unit[exact]'] = ObjectSerializer::toQueryValue($unit_exact);
        }
        // query params
        if ($unit_partial !== null) {
            $queryParams['unit[partial]'] = ObjectSerializer::toQueryValue($unit_partial);
        }
        // query params
        if ($unit_start !== null) {
            $queryParams['unit[start]'] = ObjectSerializer::toQueryValue($unit_start);
        }
        // query params
        if ($_order_frequency !== null) {
            $queryParams['_order[frequency]'] = ObjectSerializer::toQueryValue($_order_frequency);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_last_execution !== null) {
            $queryParams['_order[lastExecution]'] = ObjectSerializer::toQueryValue($_order_last_execution);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_next_execution !== null) {
            $queryParams['_order[nextExecution]'] = ObjectSerializer::toQueryValue($_order_next_execution);
        }
        // query params
        if ($_order_unit !== null) {
            $queryParams['_order[unit]'] = ObjectSerializer::toQueryValue($_order_unit);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceSchedulerItem
     *
     * Retrieves a InvoiceScheduler resource.
     *
     * @param  string $id id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceSchedulerDetailed
     */
    public function getInvoiceSchedulerItem($id, $_timezone = null)
    {
        list($response) = $this->getInvoiceSchedulerItemWithHttpInfo($id, $_timezone);
        return $response;
    }

    /**
     * Operation getInvoiceSchedulerItemWithHttpInfo
     *
     * Retrieves a InvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceSchedulerDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceSchedulerItemWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceSchedulerDetailed';
        $request = $this->getInvoiceSchedulerItemRequest($id, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceSchedulerDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceSchedulerItemAsync
     *
     * Retrieves a InvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceSchedulerItemAsync($id, $_timezone = null)
    {
        return $this->getInvoiceSchedulerItemAsyncWithHttpInfo($id, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceSchedulerItemAsyncWithHttpInfo
     *
     * Retrieves a InvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceSchedulerItemAsyncWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceSchedulerDetailed';
        $request = $this->getInvoiceSchedulerItemRequest($id, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceSchedulerItem'
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceSchedulerItemRequest($id, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInvoiceSchedulerItem'
            );
        }

        $resourcePath = '/invoice_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceTemplateCollection
     *
     * Retrieves the collection of InvoiceTemplate resources.
     *
     * @param  bool $global global (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceTemplateCollection[]
     */
    public function getInvoiceTemplateCollection($global = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getInvoiceTemplateCollectionWithHttpInfo($global, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getInvoiceTemplateCollectionWithHttpInfo
     *
     * Retrieves the collection of InvoiceTemplate resources.
     *
     * @param  bool $global (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceTemplateCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceTemplateCollectionWithHttpInfo($global = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceTemplateCollection[]';
        $request = $this->getInvoiceTemplateCollectionRequest($global, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceTemplateCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceTemplateCollectionAsync
     *
     * Retrieves the collection of InvoiceTemplate resources.
     *
     * @param  bool $global (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTemplateCollectionAsync($global = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getInvoiceTemplateCollectionAsyncWithHttpInfo($global, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceTemplateCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of InvoiceTemplate resources.
     *
     * @param  bool $global (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTemplateCollectionAsyncWithHttpInfo($global = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceTemplateCollection[]';
        $request = $this->getInvoiceTemplateCollectionRequest($global, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceTemplateCollection'
     *
     * @param  bool $global (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceTemplateCollectionRequest($global = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/invoice_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($global !== null) {
            $queryParams['global'] = ObjectSerializer::toQueryValue($global);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceTemplateItem
     *
     * Retrieves a InvoiceTemplate resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceTemplateDetailed
     */
    public function getInvoiceTemplateItem($id)
    {
        list($response) = $this->getInvoiceTemplateItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getInvoiceTemplateItemWithHttpInfo
     *
     * Retrieves a InvoiceTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceTemplateDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceTemplateItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\InvoiceTemplateDetailed';
        $request = $this->getInvoiceTemplateItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceTemplateDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceTemplateItemAsync
     *
     * Retrieves a InvoiceTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTemplateItemAsync($id)
    {
        return $this->getInvoiceTemplateItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceTemplateItemAsyncWithHttpInfo
     *
     * Retrieves a InvoiceTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTemplateItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\InvoiceTemplateDetailed';
        $request = $this->getInvoiceTemplateItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceTemplateItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceTemplateItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInvoiceTemplateItem'
            );
        }

        $resourcePath = '/invoice_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLanguageCollection
     *
     * Retrieves the collection of Language resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $iden iden (optional)
     * @param  string $iden_end iden_end (optional)
     * @param  string $iden_exact iden_exact (optional)
     * @param  string $iden_partial iden_partial (optional)
     * @param  string $iden_start iden_start (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_iden _order_iden (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\LanguageCollection[]
     */
    public function getLanguageCollection($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getLanguageCollectionWithHttpInfo($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getLanguageCollectionWithHttpInfo
     *
     * Retrieves the collection of Language resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\LanguageCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getLanguageCollectionWithHttpInfo($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\LanguageCollection[]';
        $request = $this->getLanguageCollectionRequest($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\LanguageCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLanguageCollectionAsync
     *
     * Retrieves the collection of Language resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLanguageCollectionAsync($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getLanguageCollectionAsyncWithHttpInfo($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLanguageCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Language resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLanguageCollectionAsyncWithHttpInfo($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\LanguageCollection[]';
        $request = $this->getLanguageCollectionRequest($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLanguageCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLanguageCollectionRequest($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/languages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($iden !== null) {
            $queryParams['iden'] = ObjectSerializer::toQueryValue($iden);
        }
        // query params
        if ($iden_end !== null) {
            $queryParams['iden[end]'] = ObjectSerializer::toQueryValue($iden_end);
        }
        // query params
        if ($iden_exact !== null) {
            $queryParams['iden[exact]'] = ObjectSerializer::toQueryValue($iden_exact);
        }
        // query params
        if ($iden_partial !== null) {
            $queryParams['iden[partial]'] = ObjectSerializer::toQueryValue($iden_partial);
        }
        // query params
        if ($iden_start !== null) {
            $queryParams['iden[start]'] = ObjectSerializer::toQueryValue($iden_start);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_iden !== null) {
            $queryParams['_order[iden]'] = ObjectSerializer::toQueryValue($_order_iden);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLanguageItem
     *
     * Retrieves a Language resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\LanguageDetailed
     */
    public function getLanguageItem($id)
    {
        list($response) = $this->getLanguageItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getLanguageItemWithHttpInfo
     *
     * Retrieves a Language resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\LanguageDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLanguageItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\LanguageDetailed';
        $request = $this->getLanguageItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\LanguageDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLanguageItemAsync
     *
     * Retrieves a Language resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLanguageItemAsync($id)
    {
        return $this->getLanguageItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLanguageItemAsyncWithHttpInfo
     *
     * Retrieves a Language resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLanguageItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\LanguageDetailed';
        $request = $this->getLanguageItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLanguageItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLanguageItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getLanguageItem'
            );
        }

        $resourcePath = '/languages/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNotificationTemplateCollection
     *
     * Retrieves the collection of NotificationTemplate resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $type type (optional)
     * @param  string $type_end type_end (optional)
     * @param  string $type_exact type_exact (optional)
     * @param  string $type_partial type_partial (optional)
     * @param  string $type_start type_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_type _order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\NotificationTemplateCollection[]
     */
    public function getNotificationTemplateCollection($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_id = null, $_order_name = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getNotificationTemplateCollectionWithHttpInfo($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $type, $type_end, $type_exact, $type_partial, $type_start, $_order_id, $_order_name, $_order_type, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getNotificationTemplateCollectionWithHttpInfo
     *
     * Retrieves the collection of NotificationTemplate resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\NotificationTemplateCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNotificationTemplateCollectionWithHttpInfo($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_id = null, $_order_name = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateCollection[]';
        $request = $this->getNotificationTemplateCollectionRequest($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $type, $type_end, $type_exact, $type_partial, $type_start, $_order_id, $_order_name, $_order_type, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\NotificationTemplateCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNotificationTemplateCollectionAsync
     *
     * Retrieves the collection of NotificationTemplate resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationTemplateCollectionAsync($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_id = null, $_order_name = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getNotificationTemplateCollectionAsyncWithHttpInfo($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $type, $type_end, $type_exact, $type_partial, $type_start, $_order_id, $_order_name, $_order_type, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNotificationTemplateCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of NotificationTemplate resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationTemplateCollectionAsyncWithHttpInfo($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_id = null, $_order_name = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateCollection[]';
        $request = $this->getNotificationTemplateCollectionRequest($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $type, $type_end, $type_exact, $type_partial, $type_start, $_order_id, $_order_name, $_order_type, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNotificationTemplateCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNotificationTemplateCollectionRequest($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_id = null, $_order_name = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/notification_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($type_end !== null) {
            $queryParams['type[end]'] = ObjectSerializer::toQueryValue($type_end);
        }
        // query params
        if ($type_exact !== null) {
            $queryParams['type[exact]'] = ObjectSerializer::toQueryValue($type_exact);
        }
        // query params
        if ($type_partial !== null) {
            $queryParams['type[partial]'] = ObjectSerializer::toQueryValue($type_partial);
        }
        // query params
        if ($type_start !== null) {
            $queryParams['type[start]'] = ObjectSerializer::toQueryValue($type_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_type !== null) {
            $queryParams['_order[type]'] = ObjectSerializer::toQueryValue($_order_type);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNotificationTemplateContentCollection
     *
     * Retrieves the collection of NotificationTemplateContent resources.
     *
     * @param  string $from_address from_address (optional)
     * @param  string $from_address_end from_address_end (optional)
     * @param  string $from_address_exact from_address_exact (optional)
     * @param  bool $from_address_exists from_address_exists (optional)
     * @param  string $from_address_partial from_address_partial (optional)
     * @param  string $from_address_start from_address_start (optional)
     * @param  string $from_name from_name (optional)
     * @param  string $from_name_end from_name_end (optional)
     * @param  string $from_name_exact from_name_exact (optional)
     * @param  bool $from_name_exists from_name_exists (optional)
     * @param  string $from_name_partial from_name_partial (optional)
     * @param  string $from_name_start from_name_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $language language (optional)
     * @param  string $language2 language2 (optional)
     * @param  bool $language_exists language_exists (optional)
     * @param  string $notification_template notification_template (optional)
     * @param  string $notification_template2 notification_template2 (optional)
     * @param  string $_order_from_address _order_from_address (optional)
     * @param  string $_order_from_name _order_from_name (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\NotificationTemplateContentCollection[]
     */
    public function getNotificationTemplateContentCollection($from_address = null, $from_address_end = null, $from_address_exact = null, $from_address_exists = null, $from_address_partial = null, $from_address_start = null, $from_name = null, $from_name_end = null, $from_name_exact = null, $from_name_exists = null, $from_name_partial = null, $from_name_start = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $notification_template = null, $notification_template2 = null, $_order_from_address = null, $_order_from_name = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getNotificationTemplateContentCollectionWithHttpInfo($from_address, $from_address_end, $from_address_exact, $from_address_exists, $from_address_partial, $from_address_start, $from_name, $from_name_end, $from_name_exact, $from_name_exists, $from_name_partial, $from_name_start, $id_exact, $language, $language2, $language_exists, $notification_template, $notification_template2, $_order_from_address, $_order_from_name, $_order_id, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getNotificationTemplateContentCollectionWithHttpInfo
     *
     * Retrieves the collection of NotificationTemplateContent resources.
     *
     * @param  string $from_address (optional)
     * @param  string $from_address_end (optional)
     * @param  string $from_address_exact (optional)
     * @param  bool $from_address_exists (optional)
     * @param  string $from_address_partial (optional)
     * @param  string $from_address_start (optional)
     * @param  string $from_name (optional)
     * @param  string $from_name_end (optional)
     * @param  string $from_name_exact (optional)
     * @param  bool $from_name_exists (optional)
     * @param  string $from_name_partial (optional)
     * @param  string $from_name_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $notification_template (optional)
     * @param  string $notification_template2 (optional)
     * @param  string $_order_from_address (optional)
     * @param  string $_order_from_name (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\NotificationTemplateContentCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNotificationTemplateContentCollectionWithHttpInfo($from_address = null, $from_address_end = null, $from_address_exact = null, $from_address_exists = null, $from_address_partial = null, $from_address_start = null, $from_name = null, $from_name_end = null, $from_name_exact = null, $from_name_exists = null, $from_name_partial = null, $from_name_start = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $notification_template = null, $notification_template2 = null, $_order_from_address = null, $_order_from_name = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateContentCollection[]';
        $request = $this->getNotificationTemplateContentCollectionRequest($from_address, $from_address_end, $from_address_exact, $from_address_exists, $from_address_partial, $from_address_start, $from_name, $from_name_end, $from_name_exact, $from_name_exists, $from_name_partial, $from_name_start, $id_exact, $language, $language2, $language_exists, $notification_template, $notification_template2, $_order_from_address, $_order_from_name, $_order_id, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\NotificationTemplateContentCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNotificationTemplateContentCollectionAsync
     *
     * Retrieves the collection of NotificationTemplateContent resources.
     *
     * @param  string $from_address (optional)
     * @param  string $from_address_end (optional)
     * @param  string $from_address_exact (optional)
     * @param  bool $from_address_exists (optional)
     * @param  string $from_address_partial (optional)
     * @param  string $from_address_start (optional)
     * @param  string $from_name (optional)
     * @param  string $from_name_end (optional)
     * @param  string $from_name_exact (optional)
     * @param  bool $from_name_exists (optional)
     * @param  string $from_name_partial (optional)
     * @param  string $from_name_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $notification_template (optional)
     * @param  string $notification_template2 (optional)
     * @param  string $_order_from_address (optional)
     * @param  string $_order_from_name (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationTemplateContentCollectionAsync($from_address = null, $from_address_end = null, $from_address_exact = null, $from_address_exists = null, $from_address_partial = null, $from_address_start = null, $from_name = null, $from_name_end = null, $from_name_exact = null, $from_name_exists = null, $from_name_partial = null, $from_name_start = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $notification_template = null, $notification_template2 = null, $_order_from_address = null, $_order_from_name = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getNotificationTemplateContentCollectionAsyncWithHttpInfo($from_address, $from_address_end, $from_address_exact, $from_address_exists, $from_address_partial, $from_address_start, $from_name, $from_name_end, $from_name_exact, $from_name_exists, $from_name_partial, $from_name_start, $id_exact, $language, $language2, $language_exists, $notification_template, $notification_template2, $_order_from_address, $_order_from_name, $_order_id, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNotificationTemplateContentCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of NotificationTemplateContent resources.
     *
     * @param  string $from_address (optional)
     * @param  string $from_address_end (optional)
     * @param  string $from_address_exact (optional)
     * @param  bool $from_address_exists (optional)
     * @param  string $from_address_partial (optional)
     * @param  string $from_address_start (optional)
     * @param  string $from_name (optional)
     * @param  string $from_name_end (optional)
     * @param  string $from_name_exact (optional)
     * @param  bool $from_name_exists (optional)
     * @param  string $from_name_partial (optional)
     * @param  string $from_name_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $notification_template (optional)
     * @param  string $notification_template2 (optional)
     * @param  string $_order_from_address (optional)
     * @param  string $_order_from_name (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationTemplateContentCollectionAsyncWithHttpInfo($from_address = null, $from_address_end = null, $from_address_exact = null, $from_address_exists = null, $from_address_partial = null, $from_address_start = null, $from_name = null, $from_name_end = null, $from_name_exact = null, $from_name_exists = null, $from_name_partial = null, $from_name_start = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $notification_template = null, $notification_template2 = null, $_order_from_address = null, $_order_from_name = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateContentCollection[]';
        $request = $this->getNotificationTemplateContentCollectionRequest($from_address, $from_address_end, $from_address_exact, $from_address_exists, $from_address_partial, $from_address_start, $from_name, $from_name_end, $from_name_exact, $from_name_exists, $from_name_partial, $from_name_start, $id_exact, $language, $language2, $language_exists, $notification_template, $notification_template2, $_order_from_address, $_order_from_name, $_order_id, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNotificationTemplateContentCollection'
     *
     * @param  string $from_address (optional)
     * @param  string $from_address_end (optional)
     * @param  string $from_address_exact (optional)
     * @param  bool $from_address_exists (optional)
     * @param  string $from_address_partial (optional)
     * @param  string $from_address_start (optional)
     * @param  string $from_name (optional)
     * @param  string $from_name_end (optional)
     * @param  string $from_name_exact (optional)
     * @param  bool $from_name_exists (optional)
     * @param  string $from_name_partial (optional)
     * @param  string $from_name_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $notification_template (optional)
     * @param  string $notification_template2 (optional)
     * @param  string $_order_from_address (optional)
     * @param  string $_order_from_name (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNotificationTemplateContentCollectionRequest($from_address = null, $from_address_end = null, $from_address_exact = null, $from_address_exists = null, $from_address_partial = null, $from_address_start = null, $from_name = null, $from_name_end = null, $from_name_exact = null, $from_name_exists = null, $from_name_partial = null, $from_name_start = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $notification_template = null, $notification_template2 = null, $_order_from_address = null, $_order_from_name = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/notification_template_contents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_address !== null) {
            $queryParams['fromAddress'] = ObjectSerializer::toQueryValue($from_address);
        }
        // query params
        if ($from_address_end !== null) {
            $queryParams['fromAddress[end]'] = ObjectSerializer::toQueryValue($from_address_end);
        }
        // query params
        if ($from_address_exact !== null) {
            $queryParams['fromAddress[exact]'] = ObjectSerializer::toQueryValue($from_address_exact);
        }
        // query params
        if ($from_address_exists !== null) {
            $queryParams['fromAddress[exists]'] = ObjectSerializer::toQueryValue($from_address_exists);
        }
        // query params
        if ($from_address_partial !== null) {
            $queryParams['fromAddress[partial]'] = ObjectSerializer::toQueryValue($from_address_partial);
        }
        // query params
        if ($from_address_start !== null) {
            $queryParams['fromAddress[start]'] = ObjectSerializer::toQueryValue($from_address_start);
        }
        // query params
        if ($from_name !== null) {
            $queryParams['fromName'] = ObjectSerializer::toQueryValue($from_name);
        }
        // query params
        if ($from_name_end !== null) {
            $queryParams['fromName[end]'] = ObjectSerializer::toQueryValue($from_name_end);
        }
        // query params
        if ($from_name_exact !== null) {
            $queryParams['fromName[exact]'] = ObjectSerializer::toQueryValue($from_name_exact);
        }
        // query params
        if ($from_name_exists !== null) {
            $queryParams['fromName[exists]'] = ObjectSerializer::toQueryValue($from_name_exists);
        }
        // query params
        if ($from_name_partial !== null) {
            $queryParams['fromName[partial]'] = ObjectSerializer::toQueryValue($from_name_partial);
        }
        // query params
        if ($from_name_start !== null) {
            $queryParams['fromName[start]'] = ObjectSerializer::toQueryValue($from_name_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($language2 !== null) {
            $queryParams['language[]'] = ObjectSerializer::toQueryValue($language2);
        }
        // query params
        if ($language_exists !== null) {
            $queryParams['language[exists]'] = ObjectSerializer::toQueryValue($language_exists);
        }
        // query params
        if ($notification_template !== null) {
            $queryParams['notificationTemplate'] = ObjectSerializer::toQueryValue($notification_template);
        }
        // query params
        if ($notification_template2 !== null) {
            $queryParams['notificationTemplate[]'] = ObjectSerializer::toQueryValue($notification_template2);
        }
        // query params
        if ($_order_from_address !== null) {
            $queryParams['_order[fromAddress]'] = ObjectSerializer::toQueryValue($_order_from_address);
        }
        // query params
        if ($_order_from_name !== null) {
            $queryParams['_order[fromName]'] = ObjectSerializer::toQueryValue($_order_from_name);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNotificationTemplateContentItem
     *
     * Retrieves a NotificationTemplateContent resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\NotificationTemplateContentDetailed
     */
    public function getNotificationTemplateContentItem($id)
    {
        list($response) = $this->getNotificationTemplateContentItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getNotificationTemplateContentItemWithHttpInfo
     *
     * Retrieves a NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\NotificationTemplateContentDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNotificationTemplateContentItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateContentDetailed';
        $request = $this->getNotificationTemplateContentItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\NotificationTemplateContentDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNotificationTemplateContentItemAsync
     *
     * Retrieves a NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationTemplateContentItemAsync($id)
    {
        return $this->getNotificationTemplateContentItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNotificationTemplateContentItemAsyncWithHttpInfo
     *
     * Retrieves a NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationTemplateContentItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateContentDetailed';
        $request = $this->getNotificationTemplateContentItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNotificationTemplateContentItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNotificationTemplateContentItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getNotificationTemplateContentItem'
            );
        }

        $resourcePath = '/notification_template_contents/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNotificationTemplateItem
     *
     * Retrieves a NotificationTemplate resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\NotificationTemplateDetailed
     */
    public function getNotificationTemplateItem($id)
    {
        list($response) = $this->getNotificationTemplateItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getNotificationTemplateItemWithHttpInfo
     *
     * Retrieves a NotificationTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\NotificationTemplateDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNotificationTemplateItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateDetailed';
        $request = $this->getNotificationTemplateItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\NotificationTemplateDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNotificationTemplateItemAsync
     *
     * Retrieves a NotificationTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationTemplateItemAsync($id)
    {
        return $this->getNotificationTemplateItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNotificationTemplateItemAsyncWithHttpInfo
     *
     * Retrieves a NotificationTemplate resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationTemplateItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateDetailed';
        $request = $this->getNotificationTemplateItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNotificationTemplateItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNotificationTemplateItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getNotificationTemplateItem'
            );
        }

        $resourcePath = '/notification_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOutgoingRoutingCollection
     *
     * Retrieves the collection of OutgoingRouting resources.
     *
     * @param  string $carrier carrier (optional)
     * @param  string $carrier2 carrier2 (optional)
     * @param  bool $carrier_exists carrier_exists (optional)
     * @param  string $clid_country clid_country (optional)
     * @param  string $clid_country2 clid_country2 (optional)
     * @param  bool $clid_country_exists clid_country_exists (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  bool $company_exists company_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  int $priority priority (optional)
     * @param  string $priority_between priority_between (optional)
     * @param  string $priority_gt priority_gt (optional)
     * @param  string $priority_gte priority_gte (optional)
     * @param  string $priority_lt priority_lt (optional)
     * @param  string $priority_lte priority_lte (optional)
     * @param  string $routing_mode routing_mode (optional)
     * @param  string $routing_mode_end routing_mode_end (optional)
     * @param  string $routing_mode_exact routing_mode_exact (optional)
     * @param  bool $routing_mode_exists routing_mode_exists (optional)
     * @param  string $routing_mode_partial routing_mode_partial (optional)
     * @param  string $routing_mode_start routing_mode_start (optional)
     * @param  string $routing_pattern routing_pattern (optional)
     * @param  string $routing_pattern_group routing_pattern_group (optional)
     * @param  string $routing_pattern_group2 routing_pattern_group2 (optional)
     * @param  bool $routing_pattern_group_exists routing_pattern_group_exists (optional)
     * @param  string $routing_pattern2 routing_pattern2 (optional)
     * @param  bool $routing_pattern_exists routing_pattern_exists (optional)
     * @param  string $routing_tag routing_tag (optional)
     * @param  string $routing_tag2 routing_tag2 (optional)
     * @param  bool $routing_tag_exists routing_tag_exists (optional)
     * @param  string $type type (optional)
     * @param  string $type_end type_end (optional)
     * @param  string $type_exact type_exact (optional)
     * @param  bool $type_exists type_exists (optional)
     * @param  string $type_partial type_partial (optional)
     * @param  string $type_start type_start (optional)
     * @param  int $weight weight (optional)
     * @param  string $weight_between weight_between (optional)
     * @param  string $weight_gt weight_gt (optional)
     * @param  string $weight_gte weight_gte (optional)
     * @param  string $weight_lt weight_lt (optional)
     * @param  string $weight_lte weight_lte (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_priority _order_priority (optional)
     * @param  string $_order_routing_mode _order_routing_mode (optional)
     * @param  string $_order_type _order_type (optional)
     * @param  string $_order_weight _order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\OutgoingRoutingCollection[]
     */
    public function getOutgoingRoutingCollection($carrier = null, $carrier2 = null, $carrier_exists = null, $clid_country = null, $clid_country2 = null, $clid_country_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $routing_mode = null, $routing_mode_end = null, $routing_mode_exact = null, $routing_mode_exists = null, $routing_mode_partial = null, $routing_mode_start = null, $routing_pattern = null, $routing_pattern_group = null, $routing_pattern_group2 = null, $routing_pattern_group_exists = null, $routing_pattern2 = null, $routing_pattern_exists = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $type = null, $type_end = null, $type_exact = null, $type_exists = null, $type_partial = null, $type_start = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_id = null, $_order_priority = null, $_order_routing_mode = null, $_order_type = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getOutgoingRoutingCollectionWithHttpInfo($carrier, $carrier2, $carrier_exists, $clid_country, $clid_country2, $clid_country_exists, $company, $company2, $company_exists, $id_exact, $priority, $priority_between, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $routing_mode, $routing_mode_end, $routing_mode_exact, $routing_mode_exists, $routing_mode_partial, $routing_mode_start, $routing_pattern, $routing_pattern_group, $routing_pattern_group2, $routing_pattern_group_exists, $routing_pattern2, $routing_pattern_exists, $routing_tag, $routing_tag2, $routing_tag_exists, $type, $type_end, $type_exact, $type_exists, $type_partial, $type_start, $weight, $weight_between, $weight_gt, $weight_gte, $weight_lt, $weight_lte, $_order_id, $_order_priority, $_order_routing_mode, $_order_type, $_order_weight, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getOutgoingRoutingCollectionWithHttpInfo
     *
     * Retrieves the collection of OutgoingRouting resources.
     *
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $clid_country (optional)
     * @param  string $clid_country2 (optional)
     * @param  bool $clid_country_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $routing_mode (optional)
     * @param  string $routing_mode_end (optional)
     * @param  string $routing_mode_exact (optional)
     * @param  bool $routing_mode_exists (optional)
     * @param  string $routing_mode_partial (optional)
     * @param  string $routing_mode_start (optional)
     * @param  string $routing_pattern (optional)
     * @param  string $routing_pattern_group (optional)
     * @param  string $routing_pattern_group2 (optional)
     * @param  bool $routing_pattern_group_exists (optional)
     * @param  string $routing_pattern2 (optional)
     * @param  bool $routing_pattern_exists (optional)
     * @param  string $routing_tag (optional)
     * @param  string $routing_tag2 (optional)
     * @param  bool $routing_tag_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  bool $type_exists (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  int $weight (optional)
     * @param  string $weight_between (optional)
     * @param  string $weight_gt (optional)
     * @param  string $weight_gte (optional)
     * @param  string $weight_lt (optional)
     * @param  string $weight_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_priority (optional)
     * @param  string $_order_routing_mode (optional)
     * @param  string $_order_type (optional)
     * @param  string $_order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\OutgoingRoutingCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOutgoingRoutingCollectionWithHttpInfo($carrier = null, $carrier2 = null, $carrier_exists = null, $clid_country = null, $clid_country2 = null, $clid_country_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $routing_mode = null, $routing_mode_end = null, $routing_mode_exact = null, $routing_mode_exists = null, $routing_mode_partial = null, $routing_mode_start = null, $routing_pattern = null, $routing_pattern_group = null, $routing_pattern_group2 = null, $routing_pattern_group_exists = null, $routing_pattern2 = null, $routing_pattern_exists = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $type = null, $type_end = null, $type_exact = null, $type_exists = null, $type_partial = null, $type_start = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_id = null, $_order_priority = null, $_order_routing_mode = null, $_order_type = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\OutgoingRoutingCollection[]';
        $request = $this->getOutgoingRoutingCollectionRequest($carrier, $carrier2, $carrier_exists, $clid_country, $clid_country2, $clid_country_exists, $company, $company2, $company_exists, $id_exact, $priority, $priority_between, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $routing_mode, $routing_mode_end, $routing_mode_exact, $routing_mode_exists, $routing_mode_partial, $routing_mode_start, $routing_pattern, $routing_pattern_group, $routing_pattern_group2, $routing_pattern_group_exists, $routing_pattern2, $routing_pattern_exists, $routing_tag, $routing_tag2, $routing_tag_exists, $type, $type_end, $type_exact, $type_exists, $type_partial, $type_start, $weight, $weight_between, $weight_gt, $weight_gte, $weight_lt, $weight_lte, $_order_id, $_order_priority, $_order_routing_mode, $_order_type, $_order_weight, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\OutgoingRoutingCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOutgoingRoutingCollectionAsync
     *
     * Retrieves the collection of OutgoingRouting resources.
     *
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $clid_country (optional)
     * @param  string $clid_country2 (optional)
     * @param  bool $clid_country_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $routing_mode (optional)
     * @param  string $routing_mode_end (optional)
     * @param  string $routing_mode_exact (optional)
     * @param  bool $routing_mode_exists (optional)
     * @param  string $routing_mode_partial (optional)
     * @param  string $routing_mode_start (optional)
     * @param  string $routing_pattern (optional)
     * @param  string $routing_pattern_group (optional)
     * @param  string $routing_pattern_group2 (optional)
     * @param  bool $routing_pattern_group_exists (optional)
     * @param  string $routing_pattern2 (optional)
     * @param  bool $routing_pattern_exists (optional)
     * @param  string $routing_tag (optional)
     * @param  string $routing_tag2 (optional)
     * @param  bool $routing_tag_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  bool $type_exists (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  int $weight (optional)
     * @param  string $weight_between (optional)
     * @param  string $weight_gt (optional)
     * @param  string $weight_gte (optional)
     * @param  string $weight_lt (optional)
     * @param  string $weight_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_priority (optional)
     * @param  string $_order_routing_mode (optional)
     * @param  string $_order_type (optional)
     * @param  string $_order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOutgoingRoutingCollectionAsync($carrier = null, $carrier2 = null, $carrier_exists = null, $clid_country = null, $clid_country2 = null, $clid_country_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $routing_mode = null, $routing_mode_end = null, $routing_mode_exact = null, $routing_mode_exists = null, $routing_mode_partial = null, $routing_mode_start = null, $routing_pattern = null, $routing_pattern_group = null, $routing_pattern_group2 = null, $routing_pattern_group_exists = null, $routing_pattern2 = null, $routing_pattern_exists = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $type = null, $type_end = null, $type_exact = null, $type_exists = null, $type_partial = null, $type_start = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_id = null, $_order_priority = null, $_order_routing_mode = null, $_order_type = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getOutgoingRoutingCollectionAsyncWithHttpInfo($carrier, $carrier2, $carrier_exists, $clid_country, $clid_country2, $clid_country_exists, $company, $company2, $company_exists, $id_exact, $priority, $priority_between, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $routing_mode, $routing_mode_end, $routing_mode_exact, $routing_mode_exists, $routing_mode_partial, $routing_mode_start, $routing_pattern, $routing_pattern_group, $routing_pattern_group2, $routing_pattern_group_exists, $routing_pattern2, $routing_pattern_exists, $routing_tag, $routing_tag2, $routing_tag_exists, $type, $type_end, $type_exact, $type_exists, $type_partial, $type_start, $weight, $weight_between, $weight_gt, $weight_gte, $weight_lt, $weight_lte, $_order_id, $_order_priority, $_order_routing_mode, $_order_type, $_order_weight, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOutgoingRoutingCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of OutgoingRouting resources.
     *
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $clid_country (optional)
     * @param  string $clid_country2 (optional)
     * @param  bool $clid_country_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $routing_mode (optional)
     * @param  string $routing_mode_end (optional)
     * @param  string $routing_mode_exact (optional)
     * @param  bool $routing_mode_exists (optional)
     * @param  string $routing_mode_partial (optional)
     * @param  string $routing_mode_start (optional)
     * @param  string $routing_pattern (optional)
     * @param  string $routing_pattern_group (optional)
     * @param  string $routing_pattern_group2 (optional)
     * @param  bool $routing_pattern_group_exists (optional)
     * @param  string $routing_pattern2 (optional)
     * @param  bool $routing_pattern_exists (optional)
     * @param  string $routing_tag (optional)
     * @param  string $routing_tag2 (optional)
     * @param  bool $routing_tag_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  bool $type_exists (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  int $weight (optional)
     * @param  string $weight_between (optional)
     * @param  string $weight_gt (optional)
     * @param  string $weight_gte (optional)
     * @param  string $weight_lt (optional)
     * @param  string $weight_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_priority (optional)
     * @param  string $_order_routing_mode (optional)
     * @param  string $_order_type (optional)
     * @param  string $_order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOutgoingRoutingCollectionAsyncWithHttpInfo($carrier = null, $carrier2 = null, $carrier_exists = null, $clid_country = null, $clid_country2 = null, $clid_country_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $routing_mode = null, $routing_mode_end = null, $routing_mode_exact = null, $routing_mode_exists = null, $routing_mode_partial = null, $routing_mode_start = null, $routing_pattern = null, $routing_pattern_group = null, $routing_pattern_group2 = null, $routing_pattern_group_exists = null, $routing_pattern2 = null, $routing_pattern_exists = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $type = null, $type_end = null, $type_exact = null, $type_exists = null, $type_partial = null, $type_start = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_id = null, $_order_priority = null, $_order_routing_mode = null, $_order_type = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\OutgoingRoutingCollection[]';
        $request = $this->getOutgoingRoutingCollectionRequest($carrier, $carrier2, $carrier_exists, $clid_country, $clid_country2, $clid_country_exists, $company, $company2, $company_exists, $id_exact, $priority, $priority_between, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $routing_mode, $routing_mode_end, $routing_mode_exact, $routing_mode_exists, $routing_mode_partial, $routing_mode_start, $routing_pattern, $routing_pattern_group, $routing_pattern_group2, $routing_pattern_group_exists, $routing_pattern2, $routing_pattern_exists, $routing_tag, $routing_tag2, $routing_tag_exists, $type, $type_end, $type_exact, $type_exists, $type_partial, $type_start, $weight, $weight_between, $weight_gt, $weight_gte, $weight_lt, $weight_lte, $_order_id, $_order_priority, $_order_routing_mode, $_order_type, $_order_weight, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOutgoingRoutingCollection'
     *
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $clid_country (optional)
     * @param  string $clid_country2 (optional)
     * @param  bool $clid_country_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $routing_mode (optional)
     * @param  string $routing_mode_end (optional)
     * @param  string $routing_mode_exact (optional)
     * @param  bool $routing_mode_exists (optional)
     * @param  string $routing_mode_partial (optional)
     * @param  string $routing_mode_start (optional)
     * @param  string $routing_pattern (optional)
     * @param  string $routing_pattern_group (optional)
     * @param  string $routing_pattern_group2 (optional)
     * @param  bool $routing_pattern_group_exists (optional)
     * @param  string $routing_pattern2 (optional)
     * @param  bool $routing_pattern_exists (optional)
     * @param  string $routing_tag (optional)
     * @param  string $routing_tag2 (optional)
     * @param  bool $routing_tag_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  bool $type_exists (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  int $weight (optional)
     * @param  string $weight_between (optional)
     * @param  string $weight_gt (optional)
     * @param  string $weight_gte (optional)
     * @param  string $weight_lt (optional)
     * @param  string $weight_lte (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_priority (optional)
     * @param  string $_order_routing_mode (optional)
     * @param  string $_order_type (optional)
     * @param  string $_order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOutgoingRoutingCollectionRequest($carrier = null, $carrier2 = null, $carrier_exists = null, $clid_country = null, $clid_country2 = null, $clid_country_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $priority = null, $priority_between = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $routing_mode = null, $routing_mode_end = null, $routing_mode_exact = null, $routing_mode_exists = null, $routing_mode_partial = null, $routing_mode_start = null, $routing_pattern = null, $routing_pattern_group = null, $routing_pattern_group2 = null, $routing_pattern_group_exists = null, $routing_pattern2 = null, $routing_pattern_exists = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $type = null, $type_end = null, $type_exact = null, $type_exists = null, $type_partial = null, $type_start = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_id = null, $_order_priority = null, $_order_routing_mode = null, $_order_type = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/outgoing_routings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($carrier !== null) {
            $queryParams['carrier'] = ObjectSerializer::toQueryValue($carrier);
        }
        // query params
        if ($carrier2 !== null) {
            $queryParams['carrier[]'] = ObjectSerializer::toQueryValue($carrier2);
        }
        // query params
        if ($carrier_exists !== null) {
            $queryParams['carrier[exists]'] = ObjectSerializer::toQueryValue($carrier_exists);
        }
        // query params
        if ($clid_country !== null) {
            $queryParams['clidCountry'] = ObjectSerializer::toQueryValue($clid_country);
        }
        // query params
        if ($clid_country2 !== null) {
            $queryParams['clidCountry[]'] = ObjectSerializer::toQueryValue($clid_country2);
        }
        // query params
        if ($clid_country_exists !== null) {
            $queryParams['clidCountry[exists]'] = ObjectSerializer::toQueryValue($clid_country_exists);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($company_exists !== null) {
            $queryParams['company[exists]'] = ObjectSerializer::toQueryValue($company_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority);
        }
        // query params
        if ($priority_between !== null) {
            $queryParams['priority[between]'] = ObjectSerializer::toQueryValue($priority_between);
        }
        // query params
        if ($priority_gt !== null) {
            $queryParams['priority[gt]'] = ObjectSerializer::toQueryValue($priority_gt);
        }
        // query params
        if ($priority_gte !== null) {
            $queryParams['priority[gte]'] = ObjectSerializer::toQueryValue($priority_gte);
        }
        // query params
        if ($priority_lt !== null) {
            $queryParams['priority[lt]'] = ObjectSerializer::toQueryValue($priority_lt);
        }
        // query params
        if ($priority_lte !== null) {
            $queryParams['priority[lte]'] = ObjectSerializer::toQueryValue($priority_lte);
        }
        // query params
        if ($routing_mode !== null) {
            $queryParams['routingMode'] = ObjectSerializer::toQueryValue($routing_mode);
        }
        // query params
        if ($routing_mode_end !== null) {
            $queryParams['routingMode[end]'] = ObjectSerializer::toQueryValue($routing_mode_end);
        }
        // query params
        if ($routing_mode_exact !== null) {
            $queryParams['routingMode[exact]'] = ObjectSerializer::toQueryValue($routing_mode_exact);
        }
        // query params
        if ($routing_mode_exists !== null) {
            $queryParams['routingMode[exists]'] = ObjectSerializer::toQueryValue($routing_mode_exists);
        }
        // query params
        if ($routing_mode_partial !== null) {
            $queryParams['routingMode[partial]'] = ObjectSerializer::toQueryValue($routing_mode_partial);
        }
        // query params
        if ($routing_mode_start !== null) {
            $queryParams['routingMode[start]'] = ObjectSerializer::toQueryValue($routing_mode_start);
        }
        // query params
        if ($routing_pattern !== null) {
            $queryParams['routingPattern'] = ObjectSerializer::toQueryValue($routing_pattern);
        }
        // query params
        if ($routing_pattern_group !== null) {
            $queryParams['routingPatternGroup'] = ObjectSerializer::toQueryValue($routing_pattern_group);
        }
        // query params
        if ($routing_pattern_group2 !== null) {
            $queryParams['routingPatternGroup[]'] = ObjectSerializer::toQueryValue($routing_pattern_group2);
        }
        // query params
        if ($routing_pattern_group_exists !== null) {
            $queryParams['routingPatternGroup[exists]'] = ObjectSerializer::toQueryValue($routing_pattern_group_exists);
        }
        // query params
        if ($routing_pattern2 !== null) {
            $queryParams['routingPattern[]'] = ObjectSerializer::toQueryValue($routing_pattern2);
        }
        // query params
        if ($routing_pattern_exists !== null) {
            $queryParams['routingPattern[exists]'] = ObjectSerializer::toQueryValue($routing_pattern_exists);
        }
        // query params
        if ($routing_tag !== null) {
            $queryParams['routingTag'] = ObjectSerializer::toQueryValue($routing_tag);
        }
        // query params
        if ($routing_tag2 !== null) {
            $queryParams['routingTag[]'] = ObjectSerializer::toQueryValue($routing_tag2);
        }
        // query params
        if ($routing_tag_exists !== null) {
            $queryParams['routingTag[exists]'] = ObjectSerializer::toQueryValue($routing_tag_exists);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($type_end !== null) {
            $queryParams['type[end]'] = ObjectSerializer::toQueryValue($type_end);
        }
        // query params
        if ($type_exact !== null) {
            $queryParams['type[exact]'] = ObjectSerializer::toQueryValue($type_exact);
        }
        // query params
        if ($type_exists !== null) {
            $queryParams['type[exists]'] = ObjectSerializer::toQueryValue($type_exists);
        }
        // query params
        if ($type_partial !== null) {
            $queryParams['type[partial]'] = ObjectSerializer::toQueryValue($type_partial);
        }
        // query params
        if ($type_start !== null) {
            $queryParams['type[start]'] = ObjectSerializer::toQueryValue($type_start);
        }
        // query params
        if ($weight !== null) {
            $queryParams['weight'] = ObjectSerializer::toQueryValue($weight);
        }
        // query params
        if ($weight_between !== null) {
            $queryParams['weight[between]'] = ObjectSerializer::toQueryValue($weight_between);
        }
        // query params
        if ($weight_gt !== null) {
            $queryParams['weight[gt]'] = ObjectSerializer::toQueryValue($weight_gt);
        }
        // query params
        if ($weight_gte !== null) {
            $queryParams['weight[gte]'] = ObjectSerializer::toQueryValue($weight_gte);
        }
        // query params
        if ($weight_lt !== null) {
            $queryParams['weight[lt]'] = ObjectSerializer::toQueryValue($weight_lt);
        }
        // query params
        if ($weight_lte !== null) {
            $queryParams['weight[lte]'] = ObjectSerializer::toQueryValue($weight_lte);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_priority !== null) {
            $queryParams['_order[priority]'] = ObjectSerializer::toQueryValue($_order_priority);
        }
        // query params
        if ($_order_routing_mode !== null) {
            $queryParams['_order[routingMode]'] = ObjectSerializer::toQueryValue($_order_routing_mode);
        }
        // query params
        if ($_order_type !== null) {
            $queryParams['_order[type]'] = ObjectSerializer::toQueryValue($_order_type);
        }
        // query params
        if ($_order_weight !== null) {
            $queryParams['_order[weight]'] = ObjectSerializer::toQueryValue($_order_weight);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOutgoingRoutingItem
     *
     * Retrieves a OutgoingRouting resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\OutgoingRoutingDetailed
     */
    public function getOutgoingRoutingItem($id)
    {
        list($response) = $this->getOutgoingRoutingItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getOutgoingRoutingItemWithHttpInfo
     *
     * Retrieves a OutgoingRouting resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\OutgoingRoutingDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOutgoingRoutingItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\OutgoingRoutingDetailed';
        $request = $this->getOutgoingRoutingItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\OutgoingRoutingDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOutgoingRoutingItemAsync
     *
     * Retrieves a OutgoingRouting resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOutgoingRoutingItemAsync($id)
    {
        return $this->getOutgoingRoutingItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOutgoingRoutingItemAsyncWithHttpInfo
     *
     * Retrieves a OutgoingRouting resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOutgoingRoutingItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\OutgoingRoutingDetailed';
        $request = $this->getOutgoingRoutingItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOutgoingRoutingItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOutgoingRoutingItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOutgoingRoutingItem'
            );
        }

        $resourcePath = '/outgoing_routings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProxyTrunkCollection
     *
     * Retrieves the collection of ProxyTrunk resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $ip ip (optional)
     * @param  string $ip_end ip_end (optional)
     * @param  string $ip_exact ip_exact (optional)
     * @param  string $ip_partial ip_partial (optional)
     * @param  string $ip_start ip_start (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  bool $name_exists name_exists (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_ip _order_ip (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ProxyTrunkCollection[]
     */
    public function getProxyTrunkCollection($id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_partial = null, $ip_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_ip = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getProxyTrunkCollectionWithHttpInfo($id_exact, $ip, $ip_end, $ip_exact, $ip_partial, $ip_start, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $_order_id, $_order_ip, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getProxyTrunkCollectionWithHttpInfo
     *
     * Retrieves the collection of ProxyTrunk resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ProxyTrunkCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getProxyTrunkCollectionWithHttpInfo($id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_partial = null, $ip_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_ip = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\ProxyTrunkCollection[]';
        $request = $this->getProxyTrunkCollectionRequest($id_exact, $ip, $ip_end, $ip_exact, $ip_partial, $ip_start, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $_order_id, $_order_ip, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ProxyTrunkCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProxyTrunkCollectionAsync
     *
     * Retrieves the collection of ProxyTrunk resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProxyTrunkCollectionAsync($id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_partial = null, $ip_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_ip = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getProxyTrunkCollectionAsyncWithHttpInfo($id_exact, $ip, $ip_end, $ip_exact, $ip_partial, $ip_start, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $_order_id, $_order_ip, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProxyTrunkCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of ProxyTrunk resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProxyTrunkCollectionAsyncWithHttpInfo($id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_partial = null, $ip_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_ip = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\ProxyTrunkCollection[]';
        $request = $this->getProxyTrunkCollectionRequest($id_exact, $ip, $ip_end, $ip_exact, $ip_partial, $ip_start, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $_order_id, $_order_ip, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProxyTrunkCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $ip (optional)
     * @param  string $ip_end (optional)
     * @param  string $ip_exact (optional)
     * @param  string $ip_partial (optional)
     * @param  string $ip_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_ip (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProxyTrunkCollectionRequest($id_exact = null, $ip = null, $ip_end = null, $ip_exact = null, $ip_partial = null, $ip_start = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_ip = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/proxy_trunks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }
        // query params
        if ($ip_end !== null) {
            $queryParams['ip[end]'] = ObjectSerializer::toQueryValue($ip_end);
        }
        // query params
        if ($ip_exact !== null) {
            $queryParams['ip[exact]'] = ObjectSerializer::toQueryValue($ip_exact);
        }
        // query params
        if ($ip_partial !== null) {
            $queryParams['ip[partial]'] = ObjectSerializer::toQueryValue($ip_partial);
        }
        // query params
        if ($ip_start !== null) {
            $queryParams['ip[start]'] = ObjectSerializer::toQueryValue($ip_start);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_exists !== null) {
            $queryParams['name[exists]'] = ObjectSerializer::toQueryValue($name_exists);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_ip !== null) {
            $queryParams['_order[ip]'] = ObjectSerializer::toQueryValue($_order_ip);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProxyTrunkItem
     *
     * Retrieves a ProxyTrunk resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ProxyTrunkDetailed
     */
    public function getProxyTrunkItem($id)
    {
        list($response) = $this->getProxyTrunkItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getProxyTrunkItemWithHttpInfo
     *
     * Retrieves a ProxyTrunk resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ProxyTrunkDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProxyTrunkItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\ProxyTrunkDetailed';
        $request = $this->getProxyTrunkItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ProxyTrunkDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProxyTrunkItemAsync
     *
     * Retrieves a ProxyTrunk resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProxyTrunkItemAsync($id)
    {
        return $this->getProxyTrunkItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProxyTrunkItemAsyncWithHttpInfo
     *
     * Retrieves a ProxyTrunk resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProxyTrunkItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\ProxyTrunkDetailed';
        $request = $this->getProxyTrunkItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProxyTrunkItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProxyTrunkItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProxyTrunkItem'
            );
        }

        $resourcePath = '/proxy_trunks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicEntityCollection
     *
     * Retrieves the collection of PublicEntity resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $iden iden (optional)
     * @param  string $iden_end iden_end (optional)
     * @param  string $iden_exact iden_exact (optional)
     * @param  string $iden_partial iden_partial (optional)
     * @param  string $iden_start iden_start (optional)
     * @param  string $name name (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  bool $name_ca_exists name_ca_exists (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  bool $name_en_exists name_en_exists (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  bool $name_es_exists name_es_exists (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  bool $name_it_exists name_it_exists (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_iden _order_iden (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\PublicEntityCollection[]
     */
    public function getPublicEntityCollection($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getPublicEntityCollectionWithHttpInfo($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getPublicEntityCollectionWithHttpInfo
     *
     * Retrieves the collection of PublicEntity resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\PublicEntityCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicEntityCollectionWithHttpInfo($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\PublicEntityCollection[]';
        $request = $this->getPublicEntityCollectionRequest($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\PublicEntityCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicEntityCollectionAsync
     *
     * Retrieves the collection of PublicEntity resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicEntityCollectionAsync($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getPublicEntityCollectionAsyncWithHttpInfo($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicEntityCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of PublicEntity resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicEntityCollectionAsyncWithHttpInfo($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\PublicEntityCollection[]';
        $request = $this->getPublicEntityCollectionRequest($id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_exists, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_exists, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_exists, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_exists, $name_it_partial, $name_it_start, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicEntityCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  bool $name_ca_exists (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  bool $name_en_exists (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  bool $name_es_exists (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  bool $name_it_exists (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicEntityCollectionRequest($id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_exists = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_exists = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_exists = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_exists = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/public_entities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($iden !== null) {
            $queryParams['iden'] = ObjectSerializer::toQueryValue($iden);
        }
        // query params
        if ($iden_end !== null) {
            $queryParams['iden[end]'] = ObjectSerializer::toQueryValue($iden_end);
        }
        // query params
        if ($iden_exact !== null) {
            $queryParams['iden[exact]'] = ObjectSerializer::toQueryValue($iden_exact);
        }
        // query params
        if ($iden_partial !== null) {
            $queryParams['iden[partial]'] = ObjectSerializer::toQueryValue($iden_partial);
        }
        // query params
        if ($iden_start !== null) {
            $queryParams['iden[start]'] = ObjectSerializer::toQueryValue($iden_start);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_exists !== null) {
            $queryParams['name.ca[exists]'] = ObjectSerializer::toQueryValue($name_ca_exists);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_exists !== null) {
            $queryParams['name.en[exists]'] = ObjectSerializer::toQueryValue($name_en_exists);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_exists !== null) {
            $queryParams['name.es[exists]'] = ObjectSerializer::toQueryValue($name_es_exists);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_exists !== null) {
            $queryParams['name.it[exists]'] = ObjectSerializer::toQueryValue($name_it_exists);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_iden !== null) {
            $queryParams['_order[iden]'] = ObjectSerializer::toQueryValue($_order_iden);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicEntityItem
     *
     * Retrieves a PublicEntity resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\PublicEntityDetailed
     */
    public function getPublicEntityItem($id)
    {
        list($response) = $this->getPublicEntityItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getPublicEntityItemWithHttpInfo
     *
     * Retrieves a PublicEntity resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\PublicEntityDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicEntityItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\PublicEntityDetailed';
        $request = $this->getPublicEntityItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\PublicEntityDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicEntityItemAsync
     *
     * Retrieves a PublicEntity resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicEntityItemAsync($id)
    {
        return $this->getPublicEntityItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicEntityItemAsyncWithHttpInfo
     *
     * Retrieves a PublicEntity resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicEntityItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\PublicEntityDetailed';
        $request = $this->getPublicEntityItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicEntityItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicEntityItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getPublicEntityItem'
            );
        }

        $resourcePath = '/public_entities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRatingPlanCollection
     *
     * Retrieves the collection of RatingPlan resources.
     *
     * @param  string $destination_rate_group destination_rate_group (optional)
     * @param  string $destination_rate_group2 destination_rate_group2 (optional)
     * @param  bool $friday friday (optional)
     * @param  bool $friday_exists friday_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  bool $monday monday (optional)
     * @param  bool $monday_exists monday_exists (optional)
     * @param  string $rating_plan_group rating_plan_group (optional)
     * @param  string $rating_plan_group2 rating_plan_group2 (optional)
     * @param  bool $saturday saturday (optional)
     * @param  bool $saturday_exists saturday_exists (optional)
     * @param  bool $sunday sunday (optional)
     * @param  bool $sunday_exists sunday_exists (optional)
     * @param  bool $thursday thursday (optional)
     * @param  bool $thursday_exists thursday_exists (optional)
     * @param  string $time_in time_in (optional)
     * @param  string $time_in_after time_in_after (optional)
     * @param  string $time_in_before time_in_before (optional)
     * @param  string $time_in_start time_in_start (optional)
     * @param  string $time_in_strictly_after time_in_strictly_after (optional)
     * @param  string $time_in_strictly_before time_in_strictly_before (optional)
     * @param  string $timing_type timing_type (optional)
     * @param  string $timing_type_end timing_type_end (optional)
     * @param  string $timing_type_exact timing_type_exact (optional)
     * @param  bool $timing_type_exists timing_type_exists (optional)
     * @param  string $timing_type_partial timing_type_partial (optional)
     * @param  string $timing_type_start timing_type_start (optional)
     * @param  bool $tuesday tuesday (optional)
     * @param  bool $tuesday_exists tuesday_exists (optional)
     * @param  bool $wednesday wednesday (optional)
     * @param  bool $wednesday_exists wednesday_exists (optional)
     * @param  string $weight weight (optional)
     * @param  string $weight_between weight_between (optional)
     * @param  string $weight_gt weight_gt (optional)
     * @param  string $weight_gte weight_gte (optional)
     * @param  string $weight_lt weight_lt (optional)
     * @param  string $weight_lte weight_lte (optional)
     * @param  string $_order_friday _order_friday (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_monday _order_monday (optional)
     * @param  string $_order_saturday _order_saturday (optional)
     * @param  string $_order_sunday _order_sunday (optional)
     * @param  string $_order_thursday _order_thursday (optional)
     * @param  string $_order_time_in _order_time_in (optional)
     * @param  string $_order_timing_type _order_timing_type (optional)
     * @param  string $_order_tuesday _order_tuesday (optional)
     * @param  string $_order_wednesday _order_wednesday (optional)
     * @param  string $_order_weight _order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingPlanCollection[]
     */
    public function getRatingPlanCollection($destination_rate_group = null, $destination_rate_group2 = null, $friday = null, $friday_exists = null, $id_exact = null, $monday = null, $monday_exists = null, $rating_plan_group = null, $rating_plan_group2 = null, $saturday = null, $saturday_exists = null, $sunday = null, $sunday_exists = null, $thursday = null, $thursday_exists = null, $time_in = null, $time_in_after = null, $time_in_before = null, $time_in_start = null, $time_in_strictly_after = null, $time_in_strictly_before = null, $timing_type = null, $timing_type_end = null, $timing_type_exact = null, $timing_type_exists = null, $timing_type_partial = null, $timing_type_start = null, $tuesday = null, $tuesday_exists = null, $wednesday = null, $wednesday_exists = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_friday = null, $_order_id = null, $_order_monday = null, $_order_saturday = null, $_order_sunday = null, $_order_thursday = null, $_order_time_in = null, $_order_timing_type = null, $_order_tuesday = null, $_order_wednesday = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getRatingPlanCollectionWithHttpInfo($destination_rate_group, $destination_rate_group2, $friday, $friday_exists, $id_exact, $monday, $monday_exists, $rating_plan_group, $rating_plan_group2, $saturday, $saturday_exists, $sunday, $sunday_exists, $thursday, $thursday_exists, $time_in, $time_in_after, $time_in_before, $time_in_start, $time_in_strictly_after, $time_in_strictly_before, $timing_type, $timing_type_end, $timing_type_exact, $timing_type_exists, $timing_type_partial, $timing_type_start, $tuesday, $tuesday_exists, $wednesday, $wednesday_exists, $weight, $weight_between, $weight_gt, $weight_gte, $weight_lt, $weight_lte, $_order_friday, $_order_id, $_order_monday, $_order_saturday, $_order_sunday, $_order_thursday, $_order_time_in, $_order_timing_type, $_order_tuesday, $_order_wednesday, $_order_weight, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getRatingPlanCollectionWithHttpInfo
     *
     * Retrieves the collection of RatingPlan resources.
     *
     * @param  string $destination_rate_group (optional)
     * @param  string $destination_rate_group2 (optional)
     * @param  bool $friday (optional)
     * @param  bool $friday_exists (optional)
     * @param  int $id_exact (optional)
     * @param  bool $monday (optional)
     * @param  bool $monday_exists (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  bool $saturday (optional)
     * @param  bool $saturday_exists (optional)
     * @param  bool $sunday (optional)
     * @param  bool $sunday_exists (optional)
     * @param  bool $thursday (optional)
     * @param  bool $thursday_exists (optional)
     * @param  string $time_in (optional)
     * @param  string $time_in_after (optional)
     * @param  string $time_in_before (optional)
     * @param  string $time_in_start (optional)
     * @param  string $time_in_strictly_after (optional)
     * @param  string $time_in_strictly_before (optional)
     * @param  string $timing_type (optional)
     * @param  string $timing_type_end (optional)
     * @param  string $timing_type_exact (optional)
     * @param  bool $timing_type_exists (optional)
     * @param  string $timing_type_partial (optional)
     * @param  string $timing_type_start (optional)
     * @param  bool $tuesday (optional)
     * @param  bool $tuesday_exists (optional)
     * @param  bool $wednesday (optional)
     * @param  bool $wednesday_exists (optional)
     * @param  string $weight (optional)
     * @param  string $weight_between (optional)
     * @param  string $weight_gt (optional)
     * @param  string $weight_gte (optional)
     * @param  string $weight_lt (optional)
     * @param  string $weight_lte (optional)
     * @param  string $_order_friday (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_monday (optional)
     * @param  string $_order_saturday (optional)
     * @param  string $_order_sunday (optional)
     * @param  string $_order_thursday (optional)
     * @param  string $_order_time_in (optional)
     * @param  string $_order_timing_type (optional)
     * @param  string $_order_tuesday (optional)
     * @param  string $_order_wednesday (optional)
     * @param  string $_order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingPlanCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRatingPlanCollectionWithHttpInfo($destination_rate_group = null, $destination_rate_group2 = null, $friday = null, $friday_exists = null, $id_exact = null, $monday = null, $monday_exists = null, $rating_plan_group = null, $rating_plan_group2 = null, $saturday = null, $saturday_exists = null, $sunday = null, $sunday_exists = null, $thursday = null, $thursday_exists = null, $time_in = null, $time_in_after = null, $time_in_before = null, $time_in_start = null, $time_in_strictly_after = null, $time_in_strictly_before = null, $timing_type = null, $timing_type_end = null, $timing_type_exact = null, $timing_type_exists = null, $timing_type_partial = null, $timing_type_start = null, $tuesday = null, $tuesday_exists = null, $wednesday = null, $wednesday_exists = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_friday = null, $_order_id = null, $_order_monday = null, $_order_saturday = null, $_order_sunday = null, $_order_thursday = null, $_order_time_in = null, $_order_timing_type = null, $_order_tuesday = null, $_order_wednesday = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanCollection[]';
        $request = $this->getRatingPlanCollectionRequest($destination_rate_group, $destination_rate_group2, $friday, $friday_exists, $id_exact, $monday, $monday_exists, $rating_plan_group, $rating_plan_group2, $saturday, $saturday_exists, $sunday, $sunday_exists, $thursday, $thursday_exists, $time_in, $time_in_after, $time_in_before, $time_in_start, $time_in_strictly_after, $time_in_strictly_before, $timing_type, $timing_type_end, $timing_type_exact, $timing_type_exists, $timing_type_partial, $timing_type_start, $tuesday, $tuesday_exists, $wednesday, $wednesday_exists, $weight, $weight_between, $weight_gt, $weight_gte, $weight_lt, $weight_lte, $_order_friday, $_order_id, $_order_monday, $_order_saturday, $_order_sunday, $_order_thursday, $_order_time_in, $_order_timing_type, $_order_tuesday, $_order_wednesday, $_order_weight, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingPlanCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRatingPlanCollectionAsync
     *
     * Retrieves the collection of RatingPlan resources.
     *
     * @param  string $destination_rate_group (optional)
     * @param  string $destination_rate_group2 (optional)
     * @param  bool $friday (optional)
     * @param  bool $friday_exists (optional)
     * @param  int $id_exact (optional)
     * @param  bool $monday (optional)
     * @param  bool $monday_exists (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  bool $saturday (optional)
     * @param  bool $saturday_exists (optional)
     * @param  bool $sunday (optional)
     * @param  bool $sunday_exists (optional)
     * @param  bool $thursday (optional)
     * @param  bool $thursday_exists (optional)
     * @param  string $time_in (optional)
     * @param  string $time_in_after (optional)
     * @param  string $time_in_before (optional)
     * @param  string $time_in_start (optional)
     * @param  string $time_in_strictly_after (optional)
     * @param  string $time_in_strictly_before (optional)
     * @param  string $timing_type (optional)
     * @param  string $timing_type_end (optional)
     * @param  string $timing_type_exact (optional)
     * @param  bool $timing_type_exists (optional)
     * @param  string $timing_type_partial (optional)
     * @param  string $timing_type_start (optional)
     * @param  bool $tuesday (optional)
     * @param  bool $tuesday_exists (optional)
     * @param  bool $wednesday (optional)
     * @param  bool $wednesday_exists (optional)
     * @param  string $weight (optional)
     * @param  string $weight_between (optional)
     * @param  string $weight_gt (optional)
     * @param  string $weight_gte (optional)
     * @param  string $weight_lt (optional)
     * @param  string $weight_lte (optional)
     * @param  string $_order_friday (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_monday (optional)
     * @param  string $_order_saturday (optional)
     * @param  string $_order_sunday (optional)
     * @param  string $_order_thursday (optional)
     * @param  string $_order_time_in (optional)
     * @param  string $_order_timing_type (optional)
     * @param  string $_order_tuesday (optional)
     * @param  string $_order_wednesday (optional)
     * @param  string $_order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingPlanCollectionAsync($destination_rate_group = null, $destination_rate_group2 = null, $friday = null, $friday_exists = null, $id_exact = null, $monday = null, $monday_exists = null, $rating_plan_group = null, $rating_plan_group2 = null, $saturday = null, $saturday_exists = null, $sunday = null, $sunday_exists = null, $thursday = null, $thursday_exists = null, $time_in = null, $time_in_after = null, $time_in_before = null, $time_in_start = null, $time_in_strictly_after = null, $time_in_strictly_before = null, $timing_type = null, $timing_type_end = null, $timing_type_exact = null, $timing_type_exists = null, $timing_type_partial = null, $timing_type_start = null, $tuesday = null, $tuesday_exists = null, $wednesday = null, $wednesday_exists = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_friday = null, $_order_id = null, $_order_monday = null, $_order_saturday = null, $_order_sunday = null, $_order_thursday = null, $_order_time_in = null, $_order_timing_type = null, $_order_tuesday = null, $_order_wednesday = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getRatingPlanCollectionAsyncWithHttpInfo($destination_rate_group, $destination_rate_group2, $friday, $friday_exists, $id_exact, $monday, $monday_exists, $rating_plan_group, $rating_plan_group2, $saturday, $saturday_exists, $sunday, $sunday_exists, $thursday, $thursday_exists, $time_in, $time_in_after, $time_in_before, $time_in_start, $time_in_strictly_after, $time_in_strictly_before, $timing_type, $timing_type_end, $timing_type_exact, $timing_type_exists, $timing_type_partial, $timing_type_start, $tuesday, $tuesday_exists, $wednesday, $wednesday_exists, $weight, $weight_between, $weight_gt, $weight_gte, $weight_lt, $weight_lte, $_order_friday, $_order_id, $_order_monday, $_order_saturday, $_order_sunday, $_order_thursday, $_order_time_in, $_order_timing_type, $_order_tuesday, $_order_wednesday, $_order_weight, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRatingPlanCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RatingPlan resources.
     *
     * @param  string $destination_rate_group (optional)
     * @param  string $destination_rate_group2 (optional)
     * @param  bool $friday (optional)
     * @param  bool $friday_exists (optional)
     * @param  int $id_exact (optional)
     * @param  bool $monday (optional)
     * @param  bool $monday_exists (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  bool $saturday (optional)
     * @param  bool $saturday_exists (optional)
     * @param  bool $sunday (optional)
     * @param  bool $sunday_exists (optional)
     * @param  bool $thursday (optional)
     * @param  bool $thursday_exists (optional)
     * @param  string $time_in (optional)
     * @param  string $time_in_after (optional)
     * @param  string $time_in_before (optional)
     * @param  string $time_in_start (optional)
     * @param  string $time_in_strictly_after (optional)
     * @param  string $time_in_strictly_before (optional)
     * @param  string $timing_type (optional)
     * @param  string $timing_type_end (optional)
     * @param  string $timing_type_exact (optional)
     * @param  bool $timing_type_exists (optional)
     * @param  string $timing_type_partial (optional)
     * @param  string $timing_type_start (optional)
     * @param  bool $tuesday (optional)
     * @param  bool $tuesday_exists (optional)
     * @param  bool $wednesday (optional)
     * @param  bool $wednesday_exists (optional)
     * @param  string $weight (optional)
     * @param  string $weight_between (optional)
     * @param  string $weight_gt (optional)
     * @param  string $weight_gte (optional)
     * @param  string $weight_lt (optional)
     * @param  string $weight_lte (optional)
     * @param  string $_order_friday (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_monday (optional)
     * @param  string $_order_saturday (optional)
     * @param  string $_order_sunday (optional)
     * @param  string $_order_thursday (optional)
     * @param  string $_order_time_in (optional)
     * @param  string $_order_timing_type (optional)
     * @param  string $_order_tuesday (optional)
     * @param  string $_order_wednesday (optional)
     * @param  string $_order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingPlanCollectionAsyncWithHttpInfo($destination_rate_group = null, $destination_rate_group2 = null, $friday = null, $friday_exists = null, $id_exact = null, $monday = null, $monday_exists = null, $rating_plan_group = null, $rating_plan_group2 = null, $saturday = null, $saturday_exists = null, $sunday = null, $sunday_exists = null, $thursday = null, $thursday_exists = null, $time_in = null, $time_in_after = null, $time_in_before = null, $time_in_start = null, $time_in_strictly_after = null, $time_in_strictly_before = null, $timing_type = null, $timing_type_end = null, $timing_type_exact = null, $timing_type_exists = null, $timing_type_partial = null, $timing_type_start = null, $tuesday = null, $tuesday_exists = null, $wednesday = null, $wednesday_exists = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_friday = null, $_order_id = null, $_order_monday = null, $_order_saturday = null, $_order_sunday = null, $_order_thursday = null, $_order_time_in = null, $_order_timing_type = null, $_order_tuesday = null, $_order_wednesday = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanCollection[]';
        $request = $this->getRatingPlanCollectionRequest($destination_rate_group, $destination_rate_group2, $friday, $friday_exists, $id_exact, $monday, $monday_exists, $rating_plan_group, $rating_plan_group2, $saturday, $saturday_exists, $sunday, $sunday_exists, $thursday, $thursday_exists, $time_in, $time_in_after, $time_in_before, $time_in_start, $time_in_strictly_after, $time_in_strictly_before, $timing_type, $timing_type_end, $timing_type_exact, $timing_type_exists, $timing_type_partial, $timing_type_start, $tuesday, $tuesday_exists, $wednesday, $wednesday_exists, $weight, $weight_between, $weight_gt, $weight_gte, $weight_lt, $weight_lte, $_order_friday, $_order_id, $_order_monday, $_order_saturday, $_order_sunday, $_order_thursday, $_order_time_in, $_order_timing_type, $_order_tuesday, $_order_wednesday, $_order_weight, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRatingPlanCollection'
     *
     * @param  string $destination_rate_group (optional)
     * @param  string $destination_rate_group2 (optional)
     * @param  bool $friday (optional)
     * @param  bool $friday_exists (optional)
     * @param  int $id_exact (optional)
     * @param  bool $monday (optional)
     * @param  bool $monday_exists (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  bool $saturday (optional)
     * @param  bool $saturday_exists (optional)
     * @param  bool $sunday (optional)
     * @param  bool $sunday_exists (optional)
     * @param  bool $thursday (optional)
     * @param  bool $thursday_exists (optional)
     * @param  string $time_in (optional)
     * @param  string $time_in_after (optional)
     * @param  string $time_in_before (optional)
     * @param  string $time_in_start (optional)
     * @param  string $time_in_strictly_after (optional)
     * @param  string $time_in_strictly_before (optional)
     * @param  string $timing_type (optional)
     * @param  string $timing_type_end (optional)
     * @param  string $timing_type_exact (optional)
     * @param  bool $timing_type_exists (optional)
     * @param  string $timing_type_partial (optional)
     * @param  string $timing_type_start (optional)
     * @param  bool $tuesday (optional)
     * @param  bool $tuesday_exists (optional)
     * @param  bool $wednesday (optional)
     * @param  bool $wednesday_exists (optional)
     * @param  string $weight (optional)
     * @param  string $weight_between (optional)
     * @param  string $weight_gt (optional)
     * @param  string $weight_gte (optional)
     * @param  string $weight_lt (optional)
     * @param  string $weight_lte (optional)
     * @param  string $_order_friday (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_monday (optional)
     * @param  string $_order_saturday (optional)
     * @param  string $_order_sunday (optional)
     * @param  string $_order_thursday (optional)
     * @param  string $_order_time_in (optional)
     * @param  string $_order_timing_type (optional)
     * @param  string $_order_tuesday (optional)
     * @param  string $_order_wednesday (optional)
     * @param  string $_order_weight (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRatingPlanCollectionRequest($destination_rate_group = null, $destination_rate_group2 = null, $friday = null, $friday_exists = null, $id_exact = null, $monday = null, $monday_exists = null, $rating_plan_group = null, $rating_plan_group2 = null, $saturday = null, $saturday_exists = null, $sunday = null, $sunday_exists = null, $thursday = null, $thursday_exists = null, $time_in = null, $time_in_after = null, $time_in_before = null, $time_in_start = null, $time_in_strictly_after = null, $time_in_strictly_before = null, $timing_type = null, $timing_type_end = null, $timing_type_exact = null, $timing_type_exists = null, $timing_type_partial = null, $timing_type_start = null, $tuesday = null, $tuesday_exists = null, $wednesday = null, $wednesday_exists = null, $weight = null, $weight_between = null, $weight_gt = null, $weight_gte = null, $weight_lt = null, $weight_lte = null, $_order_friday = null, $_order_id = null, $_order_monday = null, $_order_saturday = null, $_order_sunday = null, $_order_thursday = null, $_order_time_in = null, $_order_timing_type = null, $_order_tuesday = null, $_order_wednesday = null, $_order_weight = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/rating_plans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($destination_rate_group !== null) {
            $queryParams['destinationRateGroup'] = ObjectSerializer::toQueryValue($destination_rate_group);
        }
        // query params
        if ($destination_rate_group2 !== null) {
            $queryParams['destinationRateGroup[]'] = ObjectSerializer::toQueryValue($destination_rate_group2);
        }
        // query params
        if ($friday !== null) {
            $queryParams['friday'] = ObjectSerializer::toQueryValue($friday);
        }
        // query params
        if ($friday_exists !== null) {
            $queryParams['friday[exists]'] = ObjectSerializer::toQueryValue($friday_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($monday !== null) {
            $queryParams['monday'] = ObjectSerializer::toQueryValue($monday);
        }
        // query params
        if ($monday_exists !== null) {
            $queryParams['monday[exists]'] = ObjectSerializer::toQueryValue($monday_exists);
        }
        // query params
        if ($rating_plan_group !== null) {
            $queryParams['ratingPlanGroup'] = ObjectSerializer::toQueryValue($rating_plan_group);
        }
        // query params
        if ($rating_plan_group2 !== null) {
            $queryParams['ratingPlanGroup[]'] = ObjectSerializer::toQueryValue($rating_plan_group2);
        }
        // query params
        if ($saturday !== null) {
            $queryParams['saturday'] = ObjectSerializer::toQueryValue($saturday);
        }
        // query params
        if ($saturday_exists !== null) {
            $queryParams['saturday[exists]'] = ObjectSerializer::toQueryValue($saturday_exists);
        }
        // query params
        if ($sunday !== null) {
            $queryParams['sunday'] = ObjectSerializer::toQueryValue($sunday);
        }
        // query params
        if ($sunday_exists !== null) {
            $queryParams['sunday[exists]'] = ObjectSerializer::toQueryValue($sunday_exists);
        }
        // query params
        if ($thursday !== null) {
            $queryParams['thursday'] = ObjectSerializer::toQueryValue($thursday);
        }
        // query params
        if ($thursday_exists !== null) {
            $queryParams['thursday[exists]'] = ObjectSerializer::toQueryValue($thursday_exists);
        }
        // query params
        if ($time_in !== null) {
            $queryParams['timeIn'] = ObjectSerializer::toQueryValue($time_in);
        }
        // query params
        if ($time_in_after !== null) {
            $queryParams['timeIn[after]'] = ObjectSerializer::toQueryValue($time_in_after);
        }
        // query params
        if ($time_in_before !== null) {
            $queryParams['timeIn[before]'] = ObjectSerializer::toQueryValue($time_in_before);
        }
        // query params
        if ($time_in_start !== null) {
            $queryParams['timeIn[start]'] = ObjectSerializer::toQueryValue($time_in_start);
        }
        // query params
        if ($time_in_strictly_after !== null) {
            $queryParams['timeIn[strictly_after]'] = ObjectSerializer::toQueryValue($time_in_strictly_after);
        }
        // query params
        if ($time_in_strictly_before !== null) {
            $queryParams['timeIn[strictly_before]'] = ObjectSerializer::toQueryValue($time_in_strictly_before);
        }
        // query params
        if ($timing_type !== null) {
            $queryParams['timingType'] = ObjectSerializer::toQueryValue($timing_type);
        }
        // query params
        if ($timing_type_end !== null) {
            $queryParams['timingType[end]'] = ObjectSerializer::toQueryValue($timing_type_end);
        }
        // query params
        if ($timing_type_exact !== null) {
            $queryParams['timingType[exact]'] = ObjectSerializer::toQueryValue($timing_type_exact);
        }
        // query params
        if ($timing_type_exists !== null) {
            $queryParams['timingType[exists]'] = ObjectSerializer::toQueryValue($timing_type_exists);
        }
        // query params
        if ($timing_type_partial !== null) {
            $queryParams['timingType[partial]'] = ObjectSerializer::toQueryValue($timing_type_partial);
        }
        // query params
        if ($timing_type_start !== null) {
            $queryParams['timingType[start]'] = ObjectSerializer::toQueryValue($timing_type_start);
        }
        // query params
        if ($tuesday !== null) {
            $queryParams['tuesday'] = ObjectSerializer::toQueryValue($tuesday);
        }
        // query params
        if ($tuesday_exists !== null) {
            $queryParams['tuesday[exists]'] = ObjectSerializer::toQueryValue($tuesday_exists);
        }
        // query params
        if ($wednesday !== null) {
            $queryParams['wednesday'] = ObjectSerializer::toQueryValue($wednesday);
        }
        // query params
        if ($wednesday_exists !== null) {
            $queryParams['wednesday[exists]'] = ObjectSerializer::toQueryValue($wednesday_exists);
        }
        // query params
        if ($weight !== null) {
            $queryParams['weight'] = ObjectSerializer::toQueryValue($weight);
        }
        // query params
        if ($weight_between !== null) {
            $queryParams['weight[between]'] = ObjectSerializer::toQueryValue($weight_between);
        }
        // query params
        if ($weight_gt !== null) {
            $queryParams['weight[gt]'] = ObjectSerializer::toQueryValue($weight_gt);
        }
        // query params
        if ($weight_gte !== null) {
            $queryParams['weight[gte]'] = ObjectSerializer::toQueryValue($weight_gte);
        }
        // query params
        if ($weight_lt !== null) {
            $queryParams['weight[lt]'] = ObjectSerializer::toQueryValue($weight_lt);
        }
        // query params
        if ($weight_lte !== null) {
            $queryParams['weight[lte]'] = ObjectSerializer::toQueryValue($weight_lte);
        }
        // query params
        if ($_order_friday !== null) {
            $queryParams['_order[friday]'] = ObjectSerializer::toQueryValue($_order_friday);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_monday !== null) {
            $queryParams['_order[monday]'] = ObjectSerializer::toQueryValue($_order_monday);
        }
        // query params
        if ($_order_saturday !== null) {
            $queryParams['_order[saturday]'] = ObjectSerializer::toQueryValue($_order_saturday);
        }
        // query params
        if ($_order_sunday !== null) {
            $queryParams['_order[sunday]'] = ObjectSerializer::toQueryValue($_order_sunday);
        }
        // query params
        if ($_order_thursday !== null) {
            $queryParams['_order[thursday]'] = ObjectSerializer::toQueryValue($_order_thursday);
        }
        // query params
        if ($_order_time_in !== null) {
            $queryParams['_order[timeIn]'] = ObjectSerializer::toQueryValue($_order_time_in);
        }
        // query params
        if ($_order_timing_type !== null) {
            $queryParams['_order[timingType]'] = ObjectSerializer::toQueryValue($_order_timing_type);
        }
        // query params
        if ($_order_tuesday !== null) {
            $queryParams['_order[tuesday]'] = ObjectSerializer::toQueryValue($_order_tuesday);
        }
        // query params
        if ($_order_wednesday !== null) {
            $queryParams['_order[wednesday]'] = ObjectSerializer::toQueryValue($_order_wednesday);
        }
        // query params
        if ($_order_weight !== null) {
            $queryParams['_order[weight]'] = ObjectSerializer::toQueryValue($_order_weight);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRatingPlanGroupCollection
     *
     * Retrieves the collection of RatingPlanGroup resources.
     *
     * @param  string $currency currency (optional)
     * @param  string $currency2 currency2 (optional)
     * @param  bool $currency_exists currency_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingPlanGroupCollection[]
     */
    public function getRatingPlanGroupCollection($currency = null, $currency2 = null, $currency_exists = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getRatingPlanGroupCollectionWithHttpInfo($currency, $currency2, $currency_exists, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getRatingPlanGroupCollectionWithHttpInfo
     *
     * Retrieves the collection of RatingPlanGroup resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingPlanGroupCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRatingPlanGroupCollectionWithHttpInfo($currency = null, $currency2 = null, $currency_exists = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanGroupCollection[]';
        $request = $this->getRatingPlanGroupCollectionRequest($currency, $currency2, $currency_exists, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingPlanGroupCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRatingPlanGroupCollectionAsync
     *
     * Retrieves the collection of RatingPlanGroup resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingPlanGroupCollectionAsync($currency = null, $currency2 = null, $currency_exists = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getRatingPlanGroupCollectionAsyncWithHttpInfo($currency, $currency2, $currency_exists, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRatingPlanGroupCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RatingPlanGroup resources.
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingPlanGroupCollectionAsyncWithHttpInfo($currency = null, $currency2 = null, $currency_exists = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanGroupCollection[]';
        $request = $this->getRatingPlanGroupCollectionRequest($currency, $currency2, $currency_exists, $id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRatingPlanGroupCollection'
     *
     * @param  string $currency (optional)
     * @param  string $currency2 (optional)
     * @param  bool $currency_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRatingPlanGroupCollectionRequest($currency = null, $currency2 = null, $currency_exists = null, $id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/rating_plan_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency);
        }
        // query params
        if ($currency2 !== null) {
            $queryParams['currency[]'] = ObjectSerializer::toQueryValue($currency2);
        }
        // query params
        if ($currency_exists !== null) {
            $queryParams['currency[exists]'] = ObjectSerializer::toQueryValue($currency_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRatingPlanGroupItem
     *
     * Retrieves a RatingPlanGroup resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingPlanGroupDetailed
     */
    public function getRatingPlanGroupItem($id)
    {
        list($response) = $this->getRatingPlanGroupItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRatingPlanGroupItemWithHttpInfo
     *
     * Retrieves a RatingPlanGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingPlanGroupDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRatingPlanGroupItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanGroupDetailed';
        $request = $this->getRatingPlanGroupItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingPlanGroupDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRatingPlanGroupItemAsync
     *
     * Retrieves a RatingPlanGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingPlanGroupItemAsync($id)
    {
        return $this->getRatingPlanGroupItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRatingPlanGroupItemAsyncWithHttpInfo
     *
     * Retrieves a RatingPlanGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingPlanGroupItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanGroupDetailed';
        $request = $this->getRatingPlanGroupItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRatingPlanGroupItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRatingPlanGroupItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRatingPlanGroupItem'
            );
        }

        $resourcePath = '/rating_plan_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRatingPlanItem
     *
     * Retrieves a RatingPlan resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingPlanDetailed
     */
    public function getRatingPlanItem($id)
    {
        list($response) = $this->getRatingPlanItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRatingPlanItemWithHttpInfo
     *
     * Retrieves a RatingPlan resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingPlanDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRatingPlanItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanDetailed';
        $request = $this->getRatingPlanItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingPlanDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRatingPlanItemAsync
     *
     * Retrieves a RatingPlan resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingPlanItemAsync($id)
    {
        return $this->getRatingPlanItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRatingPlanItemAsyncWithHttpInfo
     *
     * Retrieves a RatingPlan resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingPlanItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanDetailed';
        $request = $this->getRatingPlanItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRatingPlanItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRatingPlanItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRatingPlanItem'
            );
        }

        $resourcePath = '/rating_plans/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRatingProfileCollection
     *
     * Retrieves the collection of RatingProfile resources.
     *
     * @param  string $activation_time activation_time (optional)
     * @param  string $activation_time_after activation_time_after (optional)
     * @param  string $activation_time_before activation_time_before (optional)
     * @param  string $activation_time_start activation_time_start (optional)
     * @param  string $activation_time_strictly_after activation_time_strictly_after (optional)
     * @param  string $activation_time_strictly_before activation_time_strictly_before (optional)
     * @param  string $carrier carrier (optional)
     * @param  string $carrier2 carrier2 (optional)
     * @param  bool $carrier_exists carrier_exists (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  bool $company_exists company_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $rating_plan_group rating_plan_group (optional)
     * @param  string $rating_plan_group2 rating_plan_group2 (optional)
     * @param  string $routing_tag routing_tag (optional)
     * @param  string $routing_tag2 routing_tag2 (optional)
     * @param  bool $routing_tag_exists routing_tag_exists (optional)
     * @param  string $_order_activation_time _order_activation_time (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingProfileCollection[]
     */
    public function getRatingProfileCollection($activation_time = null, $activation_time_after = null, $activation_time_before = null, $activation_time_start = null, $activation_time_strictly_after = null, $activation_time_strictly_before = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $rating_plan_group = null, $rating_plan_group2 = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $_order_activation_time = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        list($response) = $this->getRatingProfileCollectionWithHttpInfo($activation_time, $activation_time_after, $activation_time_before, $activation_time_start, $activation_time_strictly_after, $activation_time_strictly_before, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $id_exact, $rating_plan_group, $rating_plan_group2, $routing_tag, $routing_tag2, $routing_tag_exists, $_order_activation_time, $_order_id, $_items_per_page, $_page, $_properties, $_timezone);
        return $response;
    }

    /**
     * Operation getRatingProfileCollectionWithHttpInfo
     *
     * Retrieves the collection of RatingProfile resources.
     *
     * @param  string $activation_time (optional)
     * @param  string $activation_time_after (optional)
     * @param  string $activation_time_before (optional)
     * @param  string $activation_time_start (optional)
     * @param  string $activation_time_strictly_after (optional)
     * @param  string $activation_time_strictly_before (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  string $routing_tag (optional)
     * @param  string $routing_tag2 (optional)
     * @param  bool $routing_tag_exists (optional)
     * @param  string $_order_activation_time (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingProfileCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRatingProfileCollectionWithHttpInfo($activation_time = null, $activation_time_after = null, $activation_time_before = null, $activation_time_start = null, $activation_time_strictly_after = null, $activation_time_strictly_before = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $rating_plan_group = null, $rating_plan_group2 = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $_order_activation_time = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\RatingProfileCollection[]';
        $request = $this->getRatingProfileCollectionRequest($activation_time, $activation_time_after, $activation_time_before, $activation_time_start, $activation_time_strictly_after, $activation_time_strictly_before, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $id_exact, $rating_plan_group, $rating_plan_group2, $routing_tag, $routing_tag2, $routing_tag_exists, $_order_activation_time, $_order_id, $_items_per_page, $_page, $_properties, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingProfileCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRatingProfileCollectionAsync
     *
     * Retrieves the collection of RatingProfile resources.
     *
     * @param  string $activation_time (optional)
     * @param  string $activation_time_after (optional)
     * @param  string $activation_time_before (optional)
     * @param  string $activation_time_start (optional)
     * @param  string $activation_time_strictly_after (optional)
     * @param  string $activation_time_strictly_before (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  string $routing_tag (optional)
     * @param  string $routing_tag2 (optional)
     * @param  bool $routing_tag_exists (optional)
     * @param  string $_order_activation_time (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingProfileCollectionAsync($activation_time = null, $activation_time_after = null, $activation_time_before = null, $activation_time_start = null, $activation_time_strictly_after = null, $activation_time_strictly_before = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $rating_plan_group = null, $rating_plan_group2 = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $_order_activation_time = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        return $this->getRatingProfileCollectionAsyncWithHttpInfo($activation_time, $activation_time_after, $activation_time_before, $activation_time_start, $activation_time_strictly_after, $activation_time_strictly_before, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $id_exact, $rating_plan_group, $rating_plan_group2, $routing_tag, $routing_tag2, $routing_tag_exists, $_order_activation_time, $_order_id, $_items_per_page, $_page, $_properties, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRatingProfileCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RatingProfile resources.
     *
     * @param  string $activation_time (optional)
     * @param  string $activation_time_after (optional)
     * @param  string $activation_time_before (optional)
     * @param  string $activation_time_start (optional)
     * @param  string $activation_time_strictly_after (optional)
     * @param  string $activation_time_strictly_before (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  string $routing_tag (optional)
     * @param  string $routing_tag2 (optional)
     * @param  bool $routing_tag_exists (optional)
     * @param  string $_order_activation_time (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingProfileCollectionAsyncWithHttpInfo($activation_time = null, $activation_time_after = null, $activation_time_before = null, $activation_time_start = null, $activation_time_strictly_after = null, $activation_time_strictly_before = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $rating_plan_group = null, $rating_plan_group2 = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $_order_activation_time = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\RatingProfileCollection[]';
        $request = $this->getRatingProfileCollectionRequest($activation_time, $activation_time_after, $activation_time_before, $activation_time_start, $activation_time_strictly_after, $activation_time_strictly_before, $carrier, $carrier2, $carrier_exists, $company, $company2, $company_exists, $id_exact, $rating_plan_group, $rating_plan_group2, $routing_tag, $routing_tag2, $routing_tag_exists, $_order_activation_time, $_order_id, $_items_per_page, $_page, $_properties, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRatingProfileCollection'
     *
     * @param  string $activation_time (optional)
     * @param  string $activation_time_after (optional)
     * @param  string $activation_time_before (optional)
     * @param  string $activation_time_start (optional)
     * @param  string $activation_time_strictly_after (optional)
     * @param  string $activation_time_strictly_before (optional)
     * @param  string $carrier (optional)
     * @param  string $carrier2 (optional)
     * @param  bool $carrier_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  bool $company_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $rating_plan_group (optional)
     * @param  string $rating_plan_group2 (optional)
     * @param  string $routing_tag (optional)
     * @param  string $routing_tag2 (optional)
     * @param  bool $routing_tag_exists (optional)
     * @param  string $_order_activation_time (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRatingProfileCollectionRequest($activation_time = null, $activation_time_after = null, $activation_time_before = null, $activation_time_start = null, $activation_time_strictly_after = null, $activation_time_strictly_before = null, $carrier = null, $carrier2 = null, $carrier_exists = null, $company = null, $company2 = null, $company_exists = null, $id_exact = null, $rating_plan_group = null, $rating_plan_group2 = null, $routing_tag = null, $routing_tag2 = null, $routing_tag_exists = null, $_order_activation_time = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null, $_timezone = null)
    {

        $resourcePath = '/rating_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($activation_time !== null) {
            $queryParams['activationTime'] = ObjectSerializer::toQueryValue($activation_time);
        }
        // query params
        if ($activation_time_after !== null) {
            $queryParams['activationTime[after]'] = ObjectSerializer::toQueryValue($activation_time_after);
        }
        // query params
        if ($activation_time_before !== null) {
            $queryParams['activationTime[before]'] = ObjectSerializer::toQueryValue($activation_time_before);
        }
        // query params
        if ($activation_time_start !== null) {
            $queryParams['activationTime[start]'] = ObjectSerializer::toQueryValue($activation_time_start);
        }
        // query params
        if ($activation_time_strictly_after !== null) {
            $queryParams['activationTime[strictly_after]'] = ObjectSerializer::toQueryValue($activation_time_strictly_after);
        }
        // query params
        if ($activation_time_strictly_before !== null) {
            $queryParams['activationTime[strictly_before]'] = ObjectSerializer::toQueryValue($activation_time_strictly_before);
        }
        // query params
        if ($carrier !== null) {
            $queryParams['carrier'] = ObjectSerializer::toQueryValue($carrier);
        }
        // query params
        if ($carrier2 !== null) {
            $queryParams['carrier[]'] = ObjectSerializer::toQueryValue($carrier2);
        }
        // query params
        if ($carrier_exists !== null) {
            $queryParams['carrier[exists]'] = ObjectSerializer::toQueryValue($carrier_exists);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($company_exists !== null) {
            $queryParams['company[exists]'] = ObjectSerializer::toQueryValue($company_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($rating_plan_group !== null) {
            $queryParams['ratingPlanGroup'] = ObjectSerializer::toQueryValue($rating_plan_group);
        }
        // query params
        if ($rating_plan_group2 !== null) {
            $queryParams['ratingPlanGroup[]'] = ObjectSerializer::toQueryValue($rating_plan_group2);
        }
        // query params
        if ($routing_tag !== null) {
            $queryParams['routingTag'] = ObjectSerializer::toQueryValue($routing_tag);
        }
        // query params
        if ($routing_tag2 !== null) {
            $queryParams['routingTag[]'] = ObjectSerializer::toQueryValue($routing_tag2);
        }
        // query params
        if ($routing_tag_exists !== null) {
            $queryParams['routingTag[exists]'] = ObjectSerializer::toQueryValue($routing_tag_exists);
        }
        // query params
        if ($_order_activation_time !== null) {
            $queryParams['_order[activationTime]'] = ObjectSerializer::toQueryValue($_order_activation_time);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRatingProfileItem
     *
     * Retrieves a RatingProfile resource.
     *
     * @param  string $id id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingProfileDetailed
     */
    public function getRatingProfileItem($id, $_timezone = null)
    {
        list($response) = $this->getRatingProfileItemWithHttpInfo($id, $_timezone);
        return $response;
    }

    /**
     * Operation getRatingProfileItemWithHttpInfo
     *
     * Retrieves a RatingProfile resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingProfileDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRatingProfileItemWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\RatingProfileDetailed';
        $request = $this->getRatingProfileItemRequest($id, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingProfileDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRatingProfileItemAsync
     *
     * Retrieves a RatingProfile resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingProfileItemAsync($id, $_timezone = null)
    {
        return $this->getRatingProfileItemAsyncWithHttpInfo($id, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRatingProfileItemAsyncWithHttpInfo
     *
     * Retrieves a RatingProfile resource.
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatingProfileItemAsyncWithHttpInfo($id, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\RatingProfileDetailed';
        $request = $this->getRatingProfileItemRequest($id, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRatingProfileItem'
     *
     * @param  string $id (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRatingProfileItemRequest($id, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRatingProfileItem'
            );
        }

        $resourcePath = '/rating_profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getResidentialDeviceCollection
     *
     * Retrieves the collection of ResidentialDevice resources.
     *
     * @param  string $auth_needed auth_needed (optional)
     * @param  string $auth_needed_end auth_needed_end (optional)
     * @param  string $auth_needed_exact auth_needed_exact (optional)
     * @param  string $auth_needed_partial auth_needed_partial (optional)
     * @param  string $auth_needed_start auth_needed_start (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $language language (optional)
     * @param  string $language2 language2 (optional)
     * @param  bool $language_exists language_exists (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $transport transport (optional)
     * @param  string $transport_end transport_end (optional)
     * @param  string $transport_exact transport_exact (optional)
     * @param  bool $transport_exists transport_exists (optional)
     * @param  string $transport_partial transport_partial (optional)
     * @param  string $transport_start transport_start (optional)
     * @param  string $_order_auth_needed _order_auth_needed (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_transport _order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ResidentialDeviceCollection[]
     */
    public function getResidentialDeviceCollection($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_auth_needed = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getResidentialDeviceCollectionWithHttpInfo($auth_needed, $auth_needed_end, $auth_needed_exact, $auth_needed_partial, $auth_needed_start, $company, $company2, $id_exact, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $transport, $transport_end, $transport_exact, $transport_exists, $transport_partial, $transport_start, $_order_auth_needed, $_order_id, $_order_name, $_order_transport, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getResidentialDeviceCollectionWithHttpInfo
     *
     * Retrieves the collection of ResidentialDevice resources.
     *
     * @param  string $auth_needed (optional)
     * @param  string $auth_needed_end (optional)
     * @param  string $auth_needed_exact (optional)
     * @param  string $auth_needed_partial (optional)
     * @param  string $auth_needed_start (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $transport (optional)
     * @param  string $transport_end (optional)
     * @param  string $transport_exact (optional)
     * @param  bool $transport_exists (optional)
     * @param  string $transport_partial (optional)
     * @param  string $transport_start (optional)
     * @param  string $_order_auth_needed (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ResidentialDeviceCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getResidentialDeviceCollectionWithHttpInfo($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_auth_needed = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDeviceCollection[]';
        $request = $this->getResidentialDeviceCollectionRequest($auth_needed, $auth_needed_end, $auth_needed_exact, $auth_needed_partial, $auth_needed_start, $company, $company2, $id_exact, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $transport, $transport_end, $transport_exact, $transport_exists, $transport_partial, $transport_start, $_order_auth_needed, $_order_id, $_order_name, $_order_transport, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ResidentialDeviceCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getResidentialDeviceCollectionAsync
     *
     * Retrieves the collection of ResidentialDevice resources.
     *
     * @param  string $auth_needed (optional)
     * @param  string $auth_needed_end (optional)
     * @param  string $auth_needed_exact (optional)
     * @param  string $auth_needed_partial (optional)
     * @param  string $auth_needed_start (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $transport (optional)
     * @param  string $transport_end (optional)
     * @param  string $transport_exact (optional)
     * @param  bool $transport_exists (optional)
     * @param  string $transport_partial (optional)
     * @param  string $transport_start (optional)
     * @param  string $_order_auth_needed (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getResidentialDeviceCollectionAsync($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_auth_needed = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getResidentialDeviceCollectionAsyncWithHttpInfo($auth_needed, $auth_needed_end, $auth_needed_exact, $auth_needed_partial, $auth_needed_start, $company, $company2, $id_exact, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $transport, $transport_end, $transport_exact, $transport_exists, $transport_partial, $transport_start, $_order_auth_needed, $_order_id, $_order_name, $_order_transport, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getResidentialDeviceCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of ResidentialDevice resources.
     *
     * @param  string $auth_needed (optional)
     * @param  string $auth_needed_end (optional)
     * @param  string $auth_needed_exact (optional)
     * @param  string $auth_needed_partial (optional)
     * @param  string $auth_needed_start (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $transport (optional)
     * @param  string $transport_end (optional)
     * @param  string $transport_exact (optional)
     * @param  bool $transport_exists (optional)
     * @param  string $transport_partial (optional)
     * @param  string $transport_start (optional)
     * @param  string $_order_auth_needed (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getResidentialDeviceCollectionAsyncWithHttpInfo($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_auth_needed = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDeviceCollection[]';
        $request = $this->getResidentialDeviceCollectionRequest($auth_needed, $auth_needed_end, $auth_needed_exact, $auth_needed_partial, $auth_needed_start, $company, $company2, $id_exact, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $transport, $transport_end, $transport_exact, $transport_exists, $transport_partial, $transport_start, $_order_auth_needed, $_order_id, $_order_name, $_order_transport, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getResidentialDeviceCollection'
     *
     * @param  string $auth_needed (optional)
     * @param  string $auth_needed_end (optional)
     * @param  string $auth_needed_exact (optional)
     * @param  string $auth_needed_partial (optional)
     * @param  string $auth_needed_start (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $transport (optional)
     * @param  string $transport_end (optional)
     * @param  string $transport_exact (optional)
     * @param  bool $transport_exists (optional)
     * @param  string $transport_partial (optional)
     * @param  string $transport_start (optional)
     * @param  string $_order_auth_needed (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getResidentialDeviceCollectionRequest($auth_needed = null, $auth_needed_end = null, $auth_needed_exact = null, $auth_needed_partial = null, $auth_needed_start = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_auth_needed = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/residential_devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($auth_needed !== null) {
            $queryParams['authNeeded'] = ObjectSerializer::toQueryValue($auth_needed);
        }
        // query params
        if ($auth_needed_end !== null) {
            $queryParams['authNeeded[end]'] = ObjectSerializer::toQueryValue($auth_needed_end);
        }
        // query params
        if ($auth_needed_exact !== null) {
            $queryParams['authNeeded[exact]'] = ObjectSerializer::toQueryValue($auth_needed_exact);
        }
        // query params
        if ($auth_needed_partial !== null) {
            $queryParams['authNeeded[partial]'] = ObjectSerializer::toQueryValue($auth_needed_partial);
        }
        // query params
        if ($auth_needed_start !== null) {
            $queryParams['authNeeded[start]'] = ObjectSerializer::toQueryValue($auth_needed_start);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($language2 !== null) {
            $queryParams['language[]'] = ObjectSerializer::toQueryValue($language2);
        }
        // query params
        if ($language_exists !== null) {
            $queryParams['language[exists]'] = ObjectSerializer::toQueryValue($language_exists);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($transport !== null) {
            $queryParams['transport'] = ObjectSerializer::toQueryValue($transport);
        }
        // query params
        if ($transport_end !== null) {
            $queryParams['transport[end]'] = ObjectSerializer::toQueryValue($transport_end);
        }
        // query params
        if ($transport_exact !== null) {
            $queryParams['transport[exact]'] = ObjectSerializer::toQueryValue($transport_exact);
        }
        // query params
        if ($transport_exists !== null) {
            $queryParams['transport[exists]'] = ObjectSerializer::toQueryValue($transport_exists);
        }
        // query params
        if ($transport_partial !== null) {
            $queryParams['transport[partial]'] = ObjectSerializer::toQueryValue($transport_partial);
        }
        // query params
        if ($transport_start !== null) {
            $queryParams['transport[start]'] = ObjectSerializer::toQueryValue($transport_start);
        }
        // query params
        if ($_order_auth_needed !== null) {
            $queryParams['_order[authNeeded]'] = ObjectSerializer::toQueryValue($_order_auth_needed);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_transport !== null) {
            $queryParams['_order[transport]'] = ObjectSerializer::toQueryValue($_order_transport);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getResidentialDeviceItem
     *
     * Retrieves a ResidentialDevice resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ResidentialDeviceDetailed
     */
    public function getResidentialDeviceItem($id)
    {
        list($response) = $this->getResidentialDeviceItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getResidentialDeviceItemWithHttpInfo
     *
     * Retrieves a ResidentialDevice resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ResidentialDeviceDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getResidentialDeviceItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDeviceDetailed';
        $request = $this->getResidentialDeviceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ResidentialDeviceDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getResidentialDeviceItemAsync
     *
     * Retrieves a ResidentialDevice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getResidentialDeviceItemAsync($id)
    {
        return $this->getResidentialDeviceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getResidentialDeviceItemAsyncWithHttpInfo
     *
     * Retrieves a ResidentialDevice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getResidentialDeviceItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDeviceDetailed';
        $request = $this->getResidentialDeviceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getResidentialDeviceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getResidentialDeviceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getResidentialDeviceItem'
            );
        }

        $resourcePath = '/residential_devices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRetailAccountCollection
     *
     * Retrieves the collection of RetailAccount resources.
     *
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $transport transport (optional)
     * @param  string $transport_end transport_end (optional)
     * @param  string $transport_exact transport_exact (optional)
     * @param  bool $transport_exists transport_exists (optional)
     * @param  string $transport_partial transport_partial (optional)
     * @param  string $transport_start transport_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_transport _order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RetailAccountCollection[]
     */
    public function getRetailAccountCollection($company = null, $company2 = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getRetailAccountCollectionWithHttpInfo($company, $company2, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $transport, $transport_end, $transport_exact, $transport_exists, $transport_partial, $transport_start, $_order_id, $_order_name, $_order_transport, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getRetailAccountCollectionWithHttpInfo
     *
     * Retrieves the collection of RetailAccount resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $transport (optional)
     * @param  string $transport_end (optional)
     * @param  string $transport_exact (optional)
     * @param  bool $transport_exists (optional)
     * @param  string $transport_partial (optional)
     * @param  string $transport_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RetailAccountCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRetailAccountCollectionWithHttpInfo($company = null, $company2 = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\RetailAccountCollection[]';
        $request = $this->getRetailAccountCollectionRequest($company, $company2, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $transport, $transport_end, $transport_exact, $transport_exists, $transport_partial, $transport_start, $_order_id, $_order_name, $_order_transport, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RetailAccountCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRetailAccountCollectionAsync
     *
     * Retrieves the collection of RetailAccount resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $transport (optional)
     * @param  string $transport_end (optional)
     * @param  string $transport_exact (optional)
     * @param  bool $transport_exists (optional)
     * @param  string $transport_partial (optional)
     * @param  string $transport_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRetailAccountCollectionAsync($company = null, $company2 = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getRetailAccountCollectionAsyncWithHttpInfo($company, $company2, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $transport, $transport_end, $transport_exact, $transport_exists, $transport_partial, $transport_start, $_order_id, $_order_name, $_order_transport, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRetailAccountCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RetailAccount resources.
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $transport (optional)
     * @param  string $transport_end (optional)
     * @param  string $transport_exact (optional)
     * @param  bool $transport_exists (optional)
     * @param  string $transport_partial (optional)
     * @param  string $transport_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRetailAccountCollectionAsyncWithHttpInfo($company = null, $company2 = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\RetailAccountCollection[]';
        $request = $this->getRetailAccountCollectionRequest($company, $company2, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $transport, $transport_end, $transport_exact, $transport_exists, $transport_partial, $transport_start, $_order_id, $_order_name, $_order_transport, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRetailAccountCollection'
     *
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $transport (optional)
     * @param  string $transport_end (optional)
     * @param  string $transport_exact (optional)
     * @param  bool $transport_exists (optional)
     * @param  string $transport_partial (optional)
     * @param  string $transport_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_transport (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRetailAccountCollectionRequest($company = null, $company2 = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $transport = null, $transport_end = null, $transport_exact = null, $transport_exists = null, $transport_partial = null, $transport_start = null, $_order_id = null, $_order_name = null, $_order_transport = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/retail_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($transport !== null) {
            $queryParams['transport'] = ObjectSerializer::toQueryValue($transport);
        }
        // query params
        if ($transport_end !== null) {
            $queryParams['transport[end]'] = ObjectSerializer::toQueryValue($transport_end);
        }
        // query params
        if ($transport_exact !== null) {
            $queryParams['transport[exact]'] = ObjectSerializer::toQueryValue($transport_exact);
        }
        // query params
        if ($transport_exists !== null) {
            $queryParams['transport[exists]'] = ObjectSerializer::toQueryValue($transport_exists);
        }
        // query params
        if ($transport_partial !== null) {
            $queryParams['transport[partial]'] = ObjectSerializer::toQueryValue($transport_partial);
        }
        // query params
        if ($transport_start !== null) {
            $queryParams['transport[start]'] = ObjectSerializer::toQueryValue($transport_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_transport !== null) {
            $queryParams['_order[transport]'] = ObjectSerializer::toQueryValue($_order_transport);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRetailAccountItem
     *
     * Retrieves a RetailAccount resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RetailAccountDetailed
     */
    public function getRetailAccountItem($id)
    {
        list($response) = $this->getRetailAccountItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRetailAccountItemWithHttpInfo
     *
     * Retrieves a RetailAccount resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RetailAccountDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRetailAccountItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RetailAccountDetailed';
        $request = $this->getRetailAccountItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RetailAccountDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRetailAccountItemAsync
     *
     * Retrieves a RetailAccount resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRetailAccountItemAsync($id)
    {
        return $this->getRetailAccountItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRetailAccountItemAsyncWithHttpInfo
     *
     * Retrieves a RetailAccount resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRetailAccountItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RetailAccountDetailed';
        $request = $this->getRetailAccountItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRetailAccountItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRetailAccountItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRetailAccountItem'
            );
        }

        $resourcePath = '/retail_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutingPatternCollection
     *
     * Retrieves the collection of RoutingPattern resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $prefix prefix (optional)
     * @param  string $prefix_end prefix_end (optional)
     * @param  string $prefix_exact prefix_exact (optional)
     * @param  string $prefix_partial prefix_partial (optional)
     * @param  string $prefix_start prefix_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  string $_order_prefix _order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternCollection[]
     */
    public function getRoutingPatternCollection($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getRoutingPatternCollectionWithHttpInfo($id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $prefix, $prefix_end, $prefix_exact, $prefix_partial, $prefix_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_prefix, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getRoutingPatternCollectionWithHttpInfo
     *
     * Retrieves the collection of RoutingPattern resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $prefix (optional)
     * @param  string $prefix_end (optional)
     * @param  string $prefix_exact (optional)
     * @param  string $prefix_partial (optional)
     * @param  string $prefix_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutingPatternCollectionWithHttpInfo($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternCollection[]';
        $request = $this->getRoutingPatternCollectionRequest($id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $prefix, $prefix_end, $prefix_exact, $prefix_partial, $prefix_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_prefix, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutingPatternCollectionAsync
     *
     * Retrieves the collection of RoutingPattern resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $prefix (optional)
     * @param  string $prefix_end (optional)
     * @param  string $prefix_exact (optional)
     * @param  string $prefix_partial (optional)
     * @param  string $prefix_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternCollectionAsync($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getRoutingPatternCollectionAsyncWithHttpInfo($id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $prefix, $prefix_end, $prefix_exact, $prefix_partial, $prefix_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_prefix, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutingPatternCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RoutingPattern resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $prefix (optional)
     * @param  string $prefix_end (optional)
     * @param  string $prefix_exact (optional)
     * @param  string $prefix_partial (optional)
     * @param  string $prefix_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternCollectionAsyncWithHttpInfo($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternCollection[]';
        $request = $this->getRoutingPatternCollectionRequest($id_exact, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $prefix, $prefix_end, $prefix_exact, $prefix_partial, $prefix_start, $_order_id, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_prefix, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutingPatternCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $prefix (optional)
     * @param  string $prefix_end (optional)
     * @param  string $prefix_exact (optional)
     * @param  string $prefix_partial (optional)
     * @param  string $prefix_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutingPatternCollectionRequest($id_exact = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $prefix = null, $prefix_end = null, $prefix_exact = null, $prefix_partial = null, $prefix_start = null, $_order_id = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/routing_patterns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($prefix !== null) {
            $queryParams['prefix'] = ObjectSerializer::toQueryValue($prefix);
        }
        // query params
        if ($prefix_end !== null) {
            $queryParams['prefix[end]'] = ObjectSerializer::toQueryValue($prefix_end);
        }
        // query params
        if ($prefix_exact !== null) {
            $queryParams['prefix[exact]'] = ObjectSerializer::toQueryValue($prefix_exact);
        }
        // query params
        if ($prefix_partial !== null) {
            $queryParams['prefix[partial]'] = ObjectSerializer::toQueryValue($prefix_partial);
        }
        // query params
        if ($prefix_start !== null) {
            $queryParams['prefix[start]'] = ObjectSerializer::toQueryValue($prefix_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_order_prefix !== null) {
            $queryParams['_order[prefix]'] = ObjectSerializer::toQueryValue($_order_prefix);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutingPatternGroupCollection
     *
     * Retrieves the collection of RoutingPatternGroup resources.
     *
     * @param  string $description description (optional)
     * @param  string $description_end description_end (optional)
     * @param  string $description_exact description_exact (optional)
     * @param  bool $description_exists description_exists (optional)
     * @param  string $description_partial description_partial (optional)
     * @param  string $description_start description_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $_order_description _order_description (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternGroupCollection[]
     */
    public function getRoutingPatternGroupCollection($description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getRoutingPatternGroupCollectionWithHttpInfo($description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_description, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getRoutingPatternGroupCollectionWithHttpInfo
     *
     * Retrieves the collection of RoutingPatternGroup resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternGroupCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutingPatternGroupCollectionWithHttpInfo($description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupCollection[]';
        $request = $this->getRoutingPatternGroupCollectionRequest($description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_description, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternGroupCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutingPatternGroupCollectionAsync
     *
     * Retrieves the collection of RoutingPatternGroup resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternGroupCollectionAsync($description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getRoutingPatternGroupCollectionAsyncWithHttpInfo($description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_description, $_order_id, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutingPatternGroupCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RoutingPatternGroup resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternGroupCollectionAsyncWithHttpInfo($description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupCollection[]';
        $request = $this->getRoutingPatternGroupCollectionRequest($description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_description, $_order_id, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutingPatternGroupCollection'
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutingPatternGroupCollectionRequest($description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_description = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/routing_pattern_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($description_end !== null) {
            $queryParams['description[end]'] = ObjectSerializer::toQueryValue($description_end);
        }
        // query params
        if ($description_exact !== null) {
            $queryParams['description[exact]'] = ObjectSerializer::toQueryValue($description_exact);
        }
        // query params
        if ($description_exists !== null) {
            $queryParams['description[exists]'] = ObjectSerializer::toQueryValue($description_exists);
        }
        // query params
        if ($description_partial !== null) {
            $queryParams['description[partial]'] = ObjectSerializer::toQueryValue($description_partial);
        }
        // query params
        if ($description_start !== null) {
            $queryParams['description[start]'] = ObjectSerializer::toQueryValue($description_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($_order_description !== null) {
            $queryParams['_order[description]'] = ObjectSerializer::toQueryValue($_order_description);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutingPatternGroupItem
     *
     * Retrieves a RoutingPatternGroup resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternGroupDetailed
     */
    public function getRoutingPatternGroupItem($id)
    {
        list($response) = $this->getRoutingPatternGroupItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRoutingPatternGroupItemWithHttpInfo
     *
     * Retrieves a RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternGroupDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutingPatternGroupItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupDetailed';
        $request = $this->getRoutingPatternGroupItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternGroupDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutingPatternGroupItemAsync
     *
     * Retrieves a RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternGroupItemAsync($id)
    {
        return $this->getRoutingPatternGroupItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutingPatternGroupItemAsyncWithHttpInfo
     *
     * Retrieves a RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternGroupItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupDetailed';
        $request = $this->getRoutingPatternGroupItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutingPatternGroupItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutingPatternGroupItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoutingPatternGroupItem'
            );
        }

        $resourcePath = '/routing_pattern_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutingPatternGroupsRelPatternCollection
     *
     * Retrieves the collection of RoutingPatternGroupsRelPattern resources.
     *
     * @param  string $description_ca description_ca (optional)
     * @param  string $description_en description_en (optional)
     * @param  string $description_es description_es (optional)
     * @param  string $description_it description_it (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $routing_pattern routing_pattern (optional)
     * @param  string $routing_pattern_prefix routing_pattern_prefix (optional)
     * @param  string $routing_pattern_group routing_pattern_group (optional)
     * @param  string $routing_pattern_group_description routing_pattern_group_description (optional)
     * @param  string $routing_pattern_group_name routing_pattern_group_name (optional)
     * @param  string $routing_pattern_group2 routing_pattern_group2 (optional)
     * @param  string $routing_pattern2 routing_pattern2 (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailedCollection[]
     */
    public function getRoutingPatternGroupsRelPatternCollection($description_ca = null, $description_en = null, $description_es = null, $description_it = null, $id_exact = null, $name_ca = null, $name_en = null, $name_es = null, $name_it = null, $routing_pattern = null, $routing_pattern_prefix = null, $routing_pattern_group = null, $routing_pattern_group_description = null, $routing_pattern_group_name = null, $routing_pattern_group2 = null, $routing_pattern2 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getRoutingPatternGroupsRelPatternCollectionWithHttpInfo($description_ca, $description_en, $description_es, $description_it, $id_exact, $name_ca, $name_en, $name_es, $name_it, $routing_pattern, $routing_pattern_prefix, $routing_pattern_group, $routing_pattern_group_description, $routing_pattern_group_name, $routing_pattern_group2, $routing_pattern2, $_order_id, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getRoutingPatternGroupsRelPatternCollectionWithHttpInfo
     *
     * Retrieves the collection of RoutingPatternGroupsRelPattern resources.
     *
     * @param  string $description_ca (optional)
     * @param  string $description_en (optional)
     * @param  string $description_es (optional)
     * @param  string $description_it (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_en (optional)
     * @param  string $name_es (optional)
     * @param  string $name_it (optional)
     * @param  string $routing_pattern (optional)
     * @param  string $routing_pattern_prefix (optional)
     * @param  string $routing_pattern_group (optional)
     * @param  string $routing_pattern_group_description (optional)
     * @param  string $routing_pattern_group_name (optional)
     * @param  string $routing_pattern_group2 (optional)
     * @param  string $routing_pattern2 (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailedCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutingPatternGroupsRelPatternCollectionWithHttpInfo($description_ca = null, $description_en = null, $description_es = null, $description_it = null, $id_exact = null, $name_ca = null, $name_en = null, $name_es = null, $name_it = null, $routing_pattern = null, $routing_pattern_prefix = null, $routing_pattern_group = null, $routing_pattern_group_description = null, $routing_pattern_group_name = null, $routing_pattern_group2 = null, $routing_pattern2 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailedCollection[]';
        $request = $this->getRoutingPatternGroupsRelPatternCollectionRequest($description_ca, $description_en, $description_es, $description_it, $id_exact, $name_ca, $name_en, $name_es, $name_it, $routing_pattern, $routing_pattern_prefix, $routing_pattern_group, $routing_pattern_group_description, $routing_pattern_group_name, $routing_pattern_group2, $routing_pattern2, $_order_id, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailedCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutingPatternGroupsRelPatternCollectionAsync
     *
     * Retrieves the collection of RoutingPatternGroupsRelPattern resources.
     *
     * @param  string $description_ca (optional)
     * @param  string $description_en (optional)
     * @param  string $description_es (optional)
     * @param  string $description_it (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_en (optional)
     * @param  string $name_es (optional)
     * @param  string $name_it (optional)
     * @param  string $routing_pattern (optional)
     * @param  string $routing_pattern_prefix (optional)
     * @param  string $routing_pattern_group (optional)
     * @param  string $routing_pattern_group_description (optional)
     * @param  string $routing_pattern_group_name (optional)
     * @param  string $routing_pattern_group2 (optional)
     * @param  string $routing_pattern2 (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternGroupsRelPatternCollectionAsync($description_ca = null, $description_en = null, $description_es = null, $description_it = null, $id_exact = null, $name_ca = null, $name_en = null, $name_es = null, $name_it = null, $routing_pattern = null, $routing_pattern_prefix = null, $routing_pattern_group = null, $routing_pattern_group_description = null, $routing_pattern_group_name = null, $routing_pattern_group2 = null, $routing_pattern2 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getRoutingPatternGroupsRelPatternCollectionAsyncWithHttpInfo($description_ca, $description_en, $description_es, $description_it, $id_exact, $name_ca, $name_en, $name_es, $name_it, $routing_pattern, $routing_pattern_prefix, $routing_pattern_group, $routing_pattern_group_description, $routing_pattern_group_name, $routing_pattern_group2, $routing_pattern2, $_order_id, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutingPatternGroupsRelPatternCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RoutingPatternGroupsRelPattern resources.
     *
     * @param  string $description_ca (optional)
     * @param  string $description_en (optional)
     * @param  string $description_es (optional)
     * @param  string $description_it (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_en (optional)
     * @param  string $name_es (optional)
     * @param  string $name_it (optional)
     * @param  string $routing_pattern (optional)
     * @param  string $routing_pattern_prefix (optional)
     * @param  string $routing_pattern_group (optional)
     * @param  string $routing_pattern_group_description (optional)
     * @param  string $routing_pattern_group_name (optional)
     * @param  string $routing_pattern_group2 (optional)
     * @param  string $routing_pattern2 (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternGroupsRelPatternCollectionAsyncWithHttpInfo($description_ca = null, $description_en = null, $description_es = null, $description_it = null, $id_exact = null, $name_ca = null, $name_en = null, $name_es = null, $name_it = null, $routing_pattern = null, $routing_pattern_prefix = null, $routing_pattern_group = null, $routing_pattern_group_description = null, $routing_pattern_group_name = null, $routing_pattern_group2 = null, $routing_pattern2 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailedCollection[]';
        $request = $this->getRoutingPatternGroupsRelPatternCollectionRequest($description_ca, $description_en, $description_es, $description_it, $id_exact, $name_ca, $name_en, $name_es, $name_it, $routing_pattern, $routing_pattern_prefix, $routing_pattern_group, $routing_pattern_group_description, $routing_pattern_group_name, $routing_pattern_group2, $routing_pattern2, $_order_id, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutingPatternGroupsRelPatternCollection'
     *
     * @param  string $description_ca (optional)
     * @param  string $description_en (optional)
     * @param  string $description_es (optional)
     * @param  string $description_it (optional)
     * @param  int $id_exact (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_en (optional)
     * @param  string $name_es (optional)
     * @param  string $name_it (optional)
     * @param  string $routing_pattern (optional)
     * @param  string $routing_pattern_prefix (optional)
     * @param  string $routing_pattern_group (optional)
     * @param  string $routing_pattern_group_description (optional)
     * @param  string $routing_pattern_group_name (optional)
     * @param  string $routing_pattern_group2 (optional)
     * @param  string $routing_pattern2 (optional)
     * @param  string $_order_id (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutingPatternGroupsRelPatternCollectionRequest($description_ca = null, $description_en = null, $description_es = null, $description_it = null, $id_exact = null, $name_ca = null, $name_en = null, $name_es = null, $name_it = null, $routing_pattern = null, $routing_pattern_prefix = null, $routing_pattern_group = null, $routing_pattern_group_description = null, $routing_pattern_group_name = null, $routing_pattern_group2 = null, $routing_pattern2 = null, $_order_id = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/routing_pattern_groups_rel_patterns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description_ca !== null) {
            $queryParams['description.ca'] = ObjectSerializer::toQueryValue($description_ca);
        }
        // query params
        if ($description_en !== null) {
            $queryParams['description.en'] = ObjectSerializer::toQueryValue($description_en);
        }
        // query params
        if ($description_es !== null) {
            $queryParams['description.es'] = ObjectSerializer::toQueryValue($description_es);
        }
        // query params
        if ($description_it !== null) {
            $queryParams['description.it'] = ObjectSerializer::toQueryValue($description_it);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($routing_pattern !== null) {
            $queryParams['routingPattern'] = ObjectSerializer::toQueryValue($routing_pattern);
        }
        // query params
        if ($routing_pattern_prefix !== null) {
            $queryParams['routingPattern.prefix'] = ObjectSerializer::toQueryValue($routing_pattern_prefix);
        }
        // query params
        if ($routing_pattern_group !== null) {
            $queryParams['routingPatternGroup'] = ObjectSerializer::toQueryValue($routing_pattern_group);
        }
        // query params
        if ($routing_pattern_group_description !== null) {
            $queryParams['routingPatternGroup.description'] = ObjectSerializer::toQueryValue($routing_pattern_group_description);
        }
        // query params
        if ($routing_pattern_group_name !== null) {
            $queryParams['routingPatternGroup.name'] = ObjectSerializer::toQueryValue($routing_pattern_group_name);
        }
        // query params
        if ($routing_pattern_group2 !== null) {
            $queryParams['routingPatternGroup[]'] = ObjectSerializer::toQueryValue($routing_pattern_group2);
        }
        // query params
        if ($routing_pattern2 !== null) {
            $queryParams['routingPattern[]'] = ObjectSerializer::toQueryValue($routing_pattern2);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutingPatternGroupsRelPatternItem
     *
     * Retrieves a RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailed
     */
    public function getRoutingPatternGroupsRelPatternItem($id)
    {
        list($response) = $this->getRoutingPatternGroupsRelPatternItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRoutingPatternGroupsRelPatternItemWithHttpInfo
     *
     * Retrieves a RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutingPatternGroupsRelPatternItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailed';
        $request = $this->getRoutingPatternGroupsRelPatternItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutingPatternGroupsRelPatternItemAsync
     *
     * Retrieves a RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternGroupsRelPatternItemAsync($id)
    {
        return $this->getRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo
     *
     * Retrieves a RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupsRelPatternDetailed';
        $request = $this->getRoutingPatternGroupsRelPatternItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutingPatternGroupsRelPatternItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutingPatternGroupsRelPatternItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoutingPatternGroupsRelPatternItem'
            );
        }

        $resourcePath = '/routing_pattern_groups_rel_patterns/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutingPatternItem
     *
     * Retrieves a RoutingPattern resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternDetailed
     */
    public function getRoutingPatternItem($id)
    {
        list($response) = $this->getRoutingPatternItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRoutingPatternItemWithHttpInfo
     *
     * Retrieves a RoutingPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutingPatternItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternDetailed';
        $request = $this->getRoutingPatternItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutingPatternItemAsync
     *
     * Retrieves a RoutingPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternItemAsync($id)
    {
        return $this->getRoutingPatternItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutingPatternItemAsyncWithHttpInfo
     *
     * Retrieves a RoutingPattern resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingPatternItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternDetailed';
        $request = $this->getRoutingPatternItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutingPatternItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutingPatternItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoutingPatternItem'
            );
        }

        $resourcePath = '/routing_patterns/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutingTagCollection
     *
     * Retrieves the collection of RoutingTag resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $tag tag (optional)
     * @param  string $tag_end tag_end (optional)
     * @param  string $tag_exact tag_exact (optional)
     * @param  string $tag_partial tag_partial (optional)
     * @param  string $tag_start tag_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_tag _order_tag (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingTagCollection[]
     */
    public function getRoutingTagCollection($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $tag = null, $tag_end = null, $tag_exact = null, $tag_partial = null, $tag_start = null, $_order_id = null, $_order_name = null, $_order_tag = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getRoutingTagCollectionWithHttpInfo($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $tag, $tag_end, $tag_exact, $tag_partial, $tag_start, $_order_id, $_order_name, $_order_tag, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getRoutingTagCollectionWithHttpInfo
     *
     * Retrieves the collection of RoutingTag resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $tag (optional)
     * @param  string $tag_end (optional)
     * @param  string $tag_exact (optional)
     * @param  string $tag_partial (optional)
     * @param  string $tag_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_tag (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingTagCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutingTagCollectionWithHttpInfo($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $tag = null, $tag_end = null, $tag_exact = null, $tag_partial = null, $tag_start = null, $_order_id = null, $_order_name = null, $_order_tag = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingTagCollection[]';
        $request = $this->getRoutingTagCollectionRequest($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $tag, $tag_end, $tag_exact, $tag_partial, $tag_start, $_order_id, $_order_name, $_order_tag, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingTagCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutingTagCollectionAsync
     *
     * Retrieves the collection of RoutingTag resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $tag (optional)
     * @param  string $tag_end (optional)
     * @param  string $tag_exact (optional)
     * @param  string $tag_partial (optional)
     * @param  string $tag_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_tag (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingTagCollectionAsync($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $tag = null, $tag_end = null, $tag_exact = null, $tag_partial = null, $tag_start = null, $_order_id = null, $_order_name = null, $_order_tag = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getRoutingTagCollectionAsyncWithHttpInfo($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $tag, $tag_end, $tag_exact, $tag_partial, $tag_start, $_order_id, $_order_name, $_order_tag, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutingTagCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RoutingTag resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $tag (optional)
     * @param  string $tag_end (optional)
     * @param  string $tag_exact (optional)
     * @param  string $tag_partial (optional)
     * @param  string $tag_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_tag (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingTagCollectionAsyncWithHttpInfo($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $tag = null, $tag_end = null, $tag_exact = null, $tag_partial = null, $tag_start = null, $_order_id = null, $_order_name = null, $_order_tag = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingTagCollection[]';
        $request = $this->getRoutingTagCollectionRequest($id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $tag, $tag_end, $tag_exact, $tag_partial, $tag_start, $_order_id, $_order_name, $_order_tag, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutingTagCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $tag (optional)
     * @param  string $tag_end (optional)
     * @param  string $tag_exact (optional)
     * @param  string $tag_partial (optional)
     * @param  string $tag_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_tag (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutingTagCollectionRequest($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $tag = null, $tag_end = null, $tag_exact = null, $tag_partial = null, $tag_start = null, $_order_id = null, $_order_name = null, $_order_tag = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/routing_tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag);
        }
        // query params
        if ($tag_end !== null) {
            $queryParams['tag[end]'] = ObjectSerializer::toQueryValue($tag_end);
        }
        // query params
        if ($tag_exact !== null) {
            $queryParams['tag[exact]'] = ObjectSerializer::toQueryValue($tag_exact);
        }
        // query params
        if ($tag_partial !== null) {
            $queryParams['tag[partial]'] = ObjectSerializer::toQueryValue($tag_partial);
        }
        // query params
        if ($tag_start !== null) {
            $queryParams['tag[start]'] = ObjectSerializer::toQueryValue($tag_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_tag !== null) {
            $queryParams['_order[tag]'] = ObjectSerializer::toQueryValue($_order_tag);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutingTagItem
     *
     * Retrieves a RoutingTag resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingTagDetailed
     */
    public function getRoutingTagItem($id)
    {
        list($response) = $this->getRoutingTagItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRoutingTagItemWithHttpInfo
     *
     * Retrieves a RoutingTag resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingTagDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutingTagItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RoutingTagDetailed';
        $request = $this->getRoutingTagItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingTagDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutingTagItemAsync
     *
     * Retrieves a RoutingTag resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingTagItemAsync($id)
    {
        return $this->getRoutingTagItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutingTagItemAsyncWithHttpInfo
     *
     * Retrieves a RoutingTag resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutingTagItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\RoutingTagDetailed';
        $request = $this->getRoutingTagItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutingTagItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutingTagItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoutingTagItem'
            );
        }

        $resourcePath = '/routing_tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getServiceCollection
     *
     * Retrieves the collection of Service resources.
     *
     * @param  string $default_code default_code (optional)
     * @param  string $default_code_end default_code_end (optional)
     * @param  string $default_code_exact default_code_exact (optional)
     * @param  string $default_code_partial default_code_partial (optional)
     * @param  string $default_code_start default_code_start (optional)
     * @param  bool $extra_args extra_args (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $iden iden (optional)
     * @param  string $iden_end iden_end (optional)
     * @param  string $iden_exact iden_exact (optional)
     * @param  string $iden_partial iden_partial (optional)
     * @param  string $iden_start iden_start (optional)
     * @param  string $name name (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  string $_order_default_code _order_default_code (optional)
     * @param  string $_order_extra_args _order_extra_args (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_iden _order_iden (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ServiceCollection[]
     */
    public function getServiceCollection($default_code = null, $default_code_end = null, $default_code_exact = null, $default_code_partial = null, $default_code_start = null, $extra_args = null, $id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_default_code = null, $_order_extra_args = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getServiceCollectionWithHttpInfo($default_code, $default_code_end, $default_code_exact, $default_code_partial, $default_code_start, $extra_args, $id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_default_code, $_order_extra_args, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getServiceCollectionWithHttpInfo
     *
     * Retrieves the collection of Service resources.
     *
     * @param  string $default_code (optional)
     * @param  string $default_code_end (optional)
     * @param  string $default_code_exact (optional)
     * @param  string $default_code_partial (optional)
     * @param  string $default_code_start (optional)
     * @param  bool $extra_args (optional)
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_default_code (optional)
     * @param  string $_order_extra_args (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ServiceCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getServiceCollectionWithHttpInfo($default_code = null, $default_code_end = null, $default_code_exact = null, $default_code_partial = null, $default_code_start = null, $extra_args = null, $id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_default_code = null, $_order_extra_args = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\ServiceCollection[]';
        $request = $this->getServiceCollectionRequest($default_code, $default_code_end, $default_code_exact, $default_code_partial, $default_code_start, $extra_args, $id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_default_code, $_order_extra_args, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ServiceCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getServiceCollectionAsync
     *
     * Retrieves the collection of Service resources.
     *
     * @param  string $default_code (optional)
     * @param  string $default_code_end (optional)
     * @param  string $default_code_exact (optional)
     * @param  string $default_code_partial (optional)
     * @param  string $default_code_start (optional)
     * @param  bool $extra_args (optional)
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_default_code (optional)
     * @param  string $_order_extra_args (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getServiceCollectionAsync($default_code = null, $default_code_end = null, $default_code_exact = null, $default_code_partial = null, $default_code_start = null, $extra_args = null, $id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_default_code = null, $_order_extra_args = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getServiceCollectionAsyncWithHttpInfo($default_code, $default_code_end, $default_code_exact, $default_code_partial, $default_code_start, $extra_args, $id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_default_code, $_order_extra_args, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getServiceCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Service resources.
     *
     * @param  string $default_code (optional)
     * @param  string $default_code_end (optional)
     * @param  string $default_code_exact (optional)
     * @param  string $default_code_partial (optional)
     * @param  string $default_code_start (optional)
     * @param  bool $extra_args (optional)
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_default_code (optional)
     * @param  string $_order_extra_args (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getServiceCollectionAsyncWithHttpInfo($default_code = null, $default_code_end = null, $default_code_exact = null, $default_code_partial = null, $default_code_start = null, $extra_args = null, $id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_default_code = null, $_order_extra_args = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\ServiceCollection[]';
        $request = $this->getServiceCollectionRequest($default_code, $default_code_end, $default_code_exact, $default_code_partial, $default_code_start, $extra_args, $id_exact, $iden, $iden_end, $iden_exact, $iden_partial, $iden_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $_order_default_code, $_order_extra_args, $_order_id, $_order_iden, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getServiceCollection'
     *
     * @param  string $default_code (optional)
     * @param  string $default_code_end (optional)
     * @param  string $default_code_exact (optional)
     * @param  string $default_code_partial (optional)
     * @param  string $default_code_start (optional)
     * @param  bool $extra_args (optional)
     * @param  int $id_exact (optional)
     * @param  string $iden (optional)
     * @param  string $iden_end (optional)
     * @param  string $iden_exact (optional)
     * @param  string $iden_partial (optional)
     * @param  string $iden_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  string $_order_default_code (optional)
     * @param  string $_order_extra_args (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_iden (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getServiceCollectionRequest($default_code = null, $default_code_end = null, $default_code_exact = null, $default_code_partial = null, $default_code_start = null, $extra_args = null, $id_exact = null, $iden = null, $iden_end = null, $iden_exact = null, $iden_partial = null, $iden_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $_order_default_code = null, $_order_extra_args = null, $_order_id = null, $_order_iden = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_code !== null) {
            $queryParams['defaultCode'] = ObjectSerializer::toQueryValue($default_code);
        }
        // query params
        if ($default_code_end !== null) {
            $queryParams['defaultCode[end]'] = ObjectSerializer::toQueryValue($default_code_end);
        }
        // query params
        if ($default_code_exact !== null) {
            $queryParams['defaultCode[exact]'] = ObjectSerializer::toQueryValue($default_code_exact);
        }
        // query params
        if ($default_code_partial !== null) {
            $queryParams['defaultCode[partial]'] = ObjectSerializer::toQueryValue($default_code_partial);
        }
        // query params
        if ($default_code_start !== null) {
            $queryParams['defaultCode[start]'] = ObjectSerializer::toQueryValue($default_code_start);
        }
        // query params
        if ($extra_args !== null) {
            $queryParams['extraArgs'] = ObjectSerializer::toQueryValue($extra_args);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($iden !== null) {
            $queryParams['iden'] = ObjectSerializer::toQueryValue($iden);
        }
        // query params
        if ($iden_end !== null) {
            $queryParams['iden[end]'] = ObjectSerializer::toQueryValue($iden_end);
        }
        // query params
        if ($iden_exact !== null) {
            $queryParams['iden[exact]'] = ObjectSerializer::toQueryValue($iden_exact);
        }
        // query params
        if ($iden_partial !== null) {
            $queryParams['iden[partial]'] = ObjectSerializer::toQueryValue($iden_partial);
        }
        // query params
        if ($iden_start !== null) {
            $queryParams['iden[start]'] = ObjectSerializer::toQueryValue($iden_start);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($_order_default_code !== null) {
            $queryParams['_order[defaultCode]'] = ObjectSerializer::toQueryValue($_order_default_code);
        }
        // query params
        if ($_order_extra_args !== null) {
            $queryParams['_order[extraArgs]'] = ObjectSerializer::toQueryValue($_order_extra_args);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_iden !== null) {
            $queryParams['_order[iden]'] = ObjectSerializer::toQueryValue($_order_iden);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getServiceItem
     *
     * Retrieves a Service resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ServiceDetailed
     */
    public function getServiceItem($id)
    {
        list($response) = $this->getServiceItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getServiceItemWithHttpInfo
     *
     * Retrieves a Service resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ServiceDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getServiceItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\ServiceDetailed';
        $request = $this->getServiceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ServiceDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getServiceItemAsync
     *
     * Retrieves a Service resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getServiceItemAsync($id)
    {
        return $this->getServiceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getServiceItemAsyncWithHttpInfo
     *
     * Retrieves a Service resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getServiceItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\ServiceDetailed';
        $request = $this->getServiceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getServiceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getServiceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getServiceItem'
            );
        }

        $resourcePath = '/services/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpecialNumberCollection
     *
     * Retrieves the collection of SpecialNumber resources.
     *
     * @param  string $country country (optional)
     * @param  string $country2 country2 (optional)
     * @param  int $disable_cdr disable_cdr (optional)
     * @param  string $disable_cdr_between disable_cdr_between (optional)
     * @param  string $disable_cdr_gt disable_cdr_gt (optional)
     * @param  string $disable_cdr_gte disable_cdr_gte (optional)
     * @param  string $disable_cdr_lt disable_cdr_lt (optional)
     * @param  string $disable_cdr_lte disable_cdr_lte (optional)
     * @param  bool $global global (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $number number (optional)
     * @param  string $number_end number_end (optional)
     * @param  string $number_exact number_exact (optional)
     * @param  string $number_partial number_partial (optional)
     * @param  string $number_start number_start (optional)
     * @param  string $_order_disable_cdr _order_disable_cdr (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_number _order_number (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\SpecialNumberCollection[]
     */
    public function getSpecialNumberCollection($country = null, $country2 = null, $disable_cdr = null, $disable_cdr_between = null, $disable_cdr_gt = null, $disable_cdr_gte = null, $disable_cdr_lt = null, $disable_cdr_lte = null, $global = null, $id_exact = null, $number = null, $number_end = null, $number_exact = null, $number_partial = null, $number_start = null, $_order_disable_cdr = null, $_order_id = null, $_order_number = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getSpecialNumberCollectionWithHttpInfo($country, $country2, $disable_cdr, $disable_cdr_between, $disable_cdr_gt, $disable_cdr_gte, $disable_cdr_lt, $disable_cdr_lte, $global, $id_exact, $number, $number_end, $number_exact, $number_partial, $number_start, $_order_disable_cdr, $_order_id, $_order_number, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getSpecialNumberCollectionWithHttpInfo
     *
     * Retrieves the collection of SpecialNumber resources.
     *
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  int $disable_cdr (optional)
     * @param  string $disable_cdr_between (optional)
     * @param  string $disable_cdr_gt (optional)
     * @param  string $disable_cdr_gte (optional)
     * @param  string $disable_cdr_lt (optional)
     * @param  string $disable_cdr_lte (optional)
     * @param  bool $global (optional)
     * @param  int $id_exact (optional)
     * @param  string $number (optional)
     * @param  string $number_end (optional)
     * @param  string $number_exact (optional)
     * @param  string $number_partial (optional)
     * @param  string $number_start (optional)
     * @param  string $_order_disable_cdr (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_number (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\SpecialNumberCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpecialNumberCollectionWithHttpInfo($country = null, $country2 = null, $disable_cdr = null, $disable_cdr_between = null, $disable_cdr_gt = null, $disable_cdr_gte = null, $disable_cdr_lt = null, $disable_cdr_lte = null, $global = null, $id_exact = null, $number = null, $number_end = null, $number_exact = null, $number_partial = null, $number_start = null, $_order_disable_cdr = null, $_order_id = null, $_order_number = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\SpecialNumberCollection[]';
        $request = $this->getSpecialNumberCollectionRequest($country, $country2, $disable_cdr, $disable_cdr_between, $disable_cdr_gt, $disable_cdr_gte, $disable_cdr_lt, $disable_cdr_lte, $global, $id_exact, $number, $number_end, $number_exact, $number_partial, $number_start, $_order_disable_cdr, $_order_id, $_order_number, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\SpecialNumberCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSpecialNumberCollectionAsync
     *
     * Retrieves the collection of SpecialNumber resources.
     *
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  int $disable_cdr (optional)
     * @param  string $disable_cdr_between (optional)
     * @param  string $disable_cdr_gt (optional)
     * @param  string $disable_cdr_gte (optional)
     * @param  string $disable_cdr_lt (optional)
     * @param  string $disable_cdr_lte (optional)
     * @param  bool $global (optional)
     * @param  int $id_exact (optional)
     * @param  string $number (optional)
     * @param  string $number_end (optional)
     * @param  string $number_exact (optional)
     * @param  string $number_partial (optional)
     * @param  string $number_start (optional)
     * @param  string $_order_disable_cdr (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_number (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpecialNumberCollectionAsync($country = null, $country2 = null, $disable_cdr = null, $disable_cdr_between = null, $disable_cdr_gt = null, $disable_cdr_gte = null, $disable_cdr_lt = null, $disable_cdr_lte = null, $global = null, $id_exact = null, $number = null, $number_end = null, $number_exact = null, $number_partial = null, $number_start = null, $_order_disable_cdr = null, $_order_id = null, $_order_number = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getSpecialNumberCollectionAsyncWithHttpInfo($country, $country2, $disable_cdr, $disable_cdr_between, $disable_cdr_gt, $disable_cdr_gte, $disable_cdr_lt, $disable_cdr_lte, $global, $id_exact, $number, $number_end, $number_exact, $number_partial, $number_start, $_order_disable_cdr, $_order_id, $_order_number, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpecialNumberCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of SpecialNumber resources.
     *
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  int $disable_cdr (optional)
     * @param  string $disable_cdr_between (optional)
     * @param  string $disable_cdr_gt (optional)
     * @param  string $disable_cdr_gte (optional)
     * @param  string $disable_cdr_lt (optional)
     * @param  string $disable_cdr_lte (optional)
     * @param  bool $global (optional)
     * @param  int $id_exact (optional)
     * @param  string $number (optional)
     * @param  string $number_end (optional)
     * @param  string $number_exact (optional)
     * @param  string $number_partial (optional)
     * @param  string $number_start (optional)
     * @param  string $_order_disable_cdr (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_number (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpecialNumberCollectionAsyncWithHttpInfo($country = null, $country2 = null, $disable_cdr = null, $disable_cdr_between = null, $disable_cdr_gt = null, $disable_cdr_gte = null, $disable_cdr_lt = null, $disable_cdr_lte = null, $global = null, $id_exact = null, $number = null, $number_end = null, $number_exact = null, $number_partial = null, $number_start = null, $_order_disable_cdr = null, $_order_id = null, $_order_number = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\SpecialNumberCollection[]';
        $request = $this->getSpecialNumberCollectionRequest($country, $country2, $disable_cdr, $disable_cdr_between, $disable_cdr_gt, $disable_cdr_gte, $disable_cdr_lt, $disable_cdr_lte, $global, $id_exact, $number, $number_end, $number_exact, $number_partial, $number_start, $_order_disable_cdr, $_order_id, $_order_number, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpecialNumberCollection'
     *
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  int $disable_cdr (optional)
     * @param  string $disable_cdr_between (optional)
     * @param  string $disable_cdr_gt (optional)
     * @param  string $disable_cdr_gte (optional)
     * @param  string $disable_cdr_lt (optional)
     * @param  string $disable_cdr_lte (optional)
     * @param  bool $global (optional)
     * @param  int $id_exact (optional)
     * @param  string $number (optional)
     * @param  string $number_end (optional)
     * @param  string $number_exact (optional)
     * @param  string $number_partial (optional)
     * @param  string $number_start (optional)
     * @param  string $_order_disable_cdr (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_number (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSpecialNumberCollectionRequest($country = null, $country2 = null, $disable_cdr = null, $disable_cdr_between = null, $disable_cdr_gt = null, $disable_cdr_gte = null, $disable_cdr_lt = null, $disable_cdr_lte = null, $global = null, $id_exact = null, $number = null, $number_end = null, $number_exact = null, $number_partial = null, $number_start = null, $_order_disable_cdr = null, $_order_id = null, $_order_number = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/special_numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($country !== null) {
            $queryParams['country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($country2 !== null) {
            $queryParams['country[]'] = ObjectSerializer::toQueryValue($country2);
        }
        // query params
        if ($disable_cdr !== null) {
            $queryParams['disableCDR'] = ObjectSerializer::toQueryValue($disable_cdr);
        }
        // query params
        if ($disable_cdr_between !== null) {
            $queryParams['disableCDR[between]'] = ObjectSerializer::toQueryValue($disable_cdr_between);
        }
        // query params
        if ($disable_cdr_gt !== null) {
            $queryParams['disableCDR[gt]'] = ObjectSerializer::toQueryValue($disable_cdr_gt);
        }
        // query params
        if ($disable_cdr_gte !== null) {
            $queryParams['disableCDR[gte]'] = ObjectSerializer::toQueryValue($disable_cdr_gte);
        }
        // query params
        if ($disable_cdr_lt !== null) {
            $queryParams['disableCDR[lt]'] = ObjectSerializer::toQueryValue($disable_cdr_lt);
        }
        // query params
        if ($disable_cdr_lte !== null) {
            $queryParams['disableCDR[lte]'] = ObjectSerializer::toQueryValue($disable_cdr_lte);
        }
        // query params
        if ($global !== null) {
            $queryParams['global'] = ObjectSerializer::toQueryValue($global);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($number_end !== null) {
            $queryParams['number[end]'] = ObjectSerializer::toQueryValue($number_end);
        }
        // query params
        if ($number_exact !== null) {
            $queryParams['number[exact]'] = ObjectSerializer::toQueryValue($number_exact);
        }
        // query params
        if ($number_partial !== null) {
            $queryParams['number[partial]'] = ObjectSerializer::toQueryValue($number_partial);
        }
        // query params
        if ($number_start !== null) {
            $queryParams['number[start]'] = ObjectSerializer::toQueryValue($number_start);
        }
        // query params
        if ($_order_disable_cdr !== null) {
            $queryParams['_order[disableCDR]'] = ObjectSerializer::toQueryValue($_order_disable_cdr);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_number !== null) {
            $queryParams['_order[number]'] = ObjectSerializer::toQueryValue($_order_number);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpecialNumberItem
     *
     * Retrieves a SpecialNumber resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\SpecialNumberDetailed
     */
    public function getSpecialNumberItem($id)
    {
        list($response) = $this->getSpecialNumberItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getSpecialNumberItemWithHttpInfo
     *
     * Retrieves a SpecialNumber resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\SpecialNumberDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpecialNumberItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\SpecialNumberDetailed';
        $request = $this->getSpecialNumberItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\SpecialNumberDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSpecialNumberItemAsync
     *
     * Retrieves a SpecialNumber resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpecialNumberItemAsync($id)
    {
        return $this->getSpecialNumberItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpecialNumberItemAsyncWithHttpInfo
     *
     * Retrieves a SpecialNumber resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpecialNumberItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\SpecialNumberDetailed';
        $request = $this->getSpecialNumberItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpecialNumberItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSpecialNumberItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSpecialNumberItem'
            );
        }

        $resourcePath = '/special_numbers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatusCollectionFriendCollection
     *
     * Retrieves the collection of Friend resources.
     *
     * @param  string $company company (optional)
     * @param  float $company_balance company_balance (optional)
     * @param  string $company_billing_method company_billing_method (optional)
     * @param  int $company_call_csv_notification_template company_call_csv_notification_template (optional)
     * @param  int $company_country company_country (optional)
     * @param  string $company_country_name company_country_name (optional)
     * @param  int $company_currency company_currency (optional)
     * @param  int $company_default_timezone company_default_timezone (optional)
     * @param  string $company_domain_users company_domain_users (optional)
     * @param  string $company_externallyextraopts company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter company_ipfilter (optional)
     * @param  int $company_language company_language (optional)
     * @param  int $company_max_calls company_max_calls (optional)
     * @param  int $company_max_daily_usage company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email company_max_daily_usage_email (optional)
     * @param  string $company_name company_name (optional)
     * @param  string $company_nif company_nif (optional)
     * @param  int $company_on_demand_record company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi company_outgoing_ddi (optional)
     * @param  string $company_postal_address company_postal_address (optional)
     * @param  string $company_postal_code company_postal_code (optional)
     * @param  string $company_province company_province (optional)
     * @param  bool $company_show_invoices company_show_invoices (optional)
     * @param  string $company_town company_town (optional)
     * @param  int $company_transformation_rule_set company_transformation_rule_set (optional)
     * @param  string $company_type company_type (optional)
     * @param  int $company_voicemail_notification_template company_voicemail_notification_template (optional)
     * @param  string $company2 company2 (optional)
     * @param  string $domain_name domain_name (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $inter_company inter_company (optional)
     * @param  string $inter_company2 inter_company2 (optional)
     * @param  bool $inter_company_exists inter_company_exists (optional)
     * @param  string $language language (optional)
     * @param  string $language2 language2 (optional)
     * @param  bool $language_exists language_exists (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FriendStatus[]
     */
    public function getStatusCollectionFriendCollection($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getStatusCollectionFriendCollectionWithHttpInfo($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $inter_company, $inter_company2, $inter_company_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getStatusCollectionFriendCollectionWithHttpInfo
     *
     * Retrieves the collection of Friend resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $inter_company (optional)
     * @param  string $inter_company2 (optional)
     * @param  bool $inter_company_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FriendStatus[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusCollectionFriendCollectionWithHttpInfo($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\FriendStatus[]';
        $request = $this->getStatusCollectionFriendCollectionRequest($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $inter_company, $inter_company2, $inter_company_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FriendStatus[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusCollectionFriendCollectionAsync
     *
     * Retrieves the collection of Friend resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $inter_company (optional)
     * @param  string $inter_company2 (optional)
     * @param  bool $inter_company_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusCollectionFriendCollectionAsync($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getStatusCollectionFriendCollectionAsyncWithHttpInfo($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $inter_company, $inter_company2, $inter_company_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusCollectionFriendCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Friend resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $inter_company (optional)
     * @param  string $inter_company2 (optional)
     * @param  bool $inter_company_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusCollectionFriendCollectionAsyncWithHttpInfo($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\FriendStatus[]';
        $request = $this->getStatusCollectionFriendCollectionRequest($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $inter_company, $inter_company2, $inter_company_exists, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatusCollectionFriendCollection'
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $inter_company (optional)
     * @param  string $inter_company2 (optional)
     * @param  bool $inter_company_exists (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusCollectionFriendCollectionRequest($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $inter_company = null, $inter_company2 = null, $inter_company_exists = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/friends/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company_balance !== null) {
            $queryParams['company.balance'] = ObjectSerializer::toQueryValue($company_balance);
        }
        // query params
        if ($company_billing_method !== null) {
            $queryParams['company.billingMethod'] = ObjectSerializer::toQueryValue($company_billing_method);
        }
        // query params
        if ($company_call_csv_notification_template !== null) {
            $queryParams['company.callCsvNotificationTemplate'] = ObjectSerializer::toQueryValue($company_call_csv_notification_template);
        }
        // query params
        if ($company_country !== null) {
            $queryParams['company.country'] = ObjectSerializer::toQueryValue($company_country);
        }
        // query params
        if ($company_country_name !== null) {
            $queryParams['company.countryName'] = ObjectSerializer::toQueryValue($company_country_name);
        }
        // query params
        if ($company_currency !== null) {
            $queryParams['company.currency'] = ObjectSerializer::toQueryValue($company_currency);
        }
        // query params
        if ($company_default_timezone !== null) {
            $queryParams['company.defaultTimezone'] = ObjectSerializer::toQueryValue($company_default_timezone);
        }
        // query params
        if ($company_domain_users !== null) {
            $queryParams['company.domainUsers'] = ObjectSerializer::toQueryValue($company_domain_users);
        }
        // query params
        if ($company_externallyextraopts !== null) {
            $queryParams['company.externallyextraopts'] = ObjectSerializer::toQueryValue($company_externallyextraopts);
        }
        // query params
        if ($company_fax_notification_template !== null) {
            $queryParams['company.faxNotificationTemplate'] = ObjectSerializer::toQueryValue($company_fax_notification_template);
        }
        // query params
        if ($company_invoice_notification_template !== null) {
            $queryParams['company.invoiceNotificationTemplate'] = ObjectSerializer::toQueryValue($company_invoice_notification_template);
        }
        // query params
        if ($company_ipfilter !== null) {
            $queryParams['company.ipfilter'] = ObjectSerializer::toQueryValue($company_ipfilter);
        }
        // query params
        if ($company_language !== null) {
            $queryParams['company.language'] = ObjectSerializer::toQueryValue($company_language);
        }
        // query params
        if ($company_max_calls !== null) {
            $queryParams['company.maxCalls'] = ObjectSerializer::toQueryValue($company_max_calls);
        }
        // query params
        if ($company_max_daily_usage !== null) {
            $queryParams['company.maxDailyUsage'] = ObjectSerializer::toQueryValue($company_max_daily_usage);
        }
        // query params
        if ($company_max_daily_usage_email !== null) {
            $queryParams['company.maxDailyUsageEmail'] = ObjectSerializer::toQueryValue($company_max_daily_usage_email);
        }
        // query params
        if ($company_name !== null) {
            $queryParams['company.name'] = ObjectSerializer::toQueryValue($company_name);
        }
        // query params
        if ($company_nif !== null) {
            $queryParams['company.nif'] = ObjectSerializer::toQueryValue($company_nif);
        }
        // query params
        if ($company_on_demand_record !== null) {
            $queryParams['company.onDemandRecord'] = ObjectSerializer::toQueryValue($company_on_demand_record);
        }
        // query params
        if ($company_on_demand_record_code !== null) {
            $queryParams['company.onDemandRecordCode'] = ObjectSerializer::toQueryValue($company_on_demand_record_code);
        }
        // query params
        if ($company_outgoing_ddi !== null) {
            $queryParams['company.outgoingDdi'] = ObjectSerializer::toQueryValue($company_outgoing_ddi);
        }
        // query params
        if ($company_postal_address !== null) {
            $queryParams['company.postalAddress'] = ObjectSerializer::toQueryValue($company_postal_address);
        }
        // query params
        if ($company_postal_code !== null) {
            $queryParams['company.postalCode'] = ObjectSerializer::toQueryValue($company_postal_code);
        }
        // query params
        if ($company_province !== null) {
            $queryParams['company.province'] = ObjectSerializer::toQueryValue($company_province);
        }
        // query params
        if ($company_show_invoices !== null) {
            $queryParams['company.showInvoices'] = ObjectSerializer::toQueryValue($company_show_invoices);
        }
        // query params
        if ($company_town !== null) {
            $queryParams['company.town'] = ObjectSerializer::toQueryValue($company_town);
        }
        // query params
        if ($company_transformation_rule_set !== null) {
            $queryParams['company.transformationRuleSet'] = ObjectSerializer::toQueryValue($company_transformation_rule_set);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['company.type'] = ObjectSerializer::toQueryValue($company_type);
        }
        // query params
        if ($company_voicemail_notification_template !== null) {
            $queryParams['company.voicemailNotificationTemplate'] = ObjectSerializer::toQueryValue($company_voicemail_notification_template);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($inter_company !== null) {
            $queryParams['interCompany'] = ObjectSerializer::toQueryValue($inter_company);
        }
        // query params
        if ($inter_company2 !== null) {
            $queryParams['interCompany[]'] = ObjectSerializer::toQueryValue($inter_company2);
        }
        // query params
        if ($inter_company_exists !== null) {
            $queryParams['interCompany[exists]'] = ObjectSerializer::toQueryValue($inter_company_exists);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($language2 !== null) {
            $queryParams['language[]'] = ObjectSerializer::toQueryValue($language2);
        }
        // query params
        if ($language_exists !== null) {
            $queryParams['language[exists]'] = ObjectSerializer::toQueryValue($language_exists);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json', 'text/csv', 'application/xml', 'text/xml', 'text/html', 'application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json', 'text/csv', 'application/xml', 'text/xml', 'text/html', 'application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatusCollectionResidentialDeviceCollection
     *
     * Retrieves the collection of ResidentialDevice resources.
     *
     * @param  string $company company (optional)
     * @param  float $company_balance company_balance (optional)
     * @param  string $company_billing_method company_billing_method (optional)
     * @param  int $company_call_csv_notification_template company_call_csv_notification_template (optional)
     * @param  int $company_country company_country (optional)
     * @param  string $company_country_name company_country_name (optional)
     * @param  int $company_currency company_currency (optional)
     * @param  int $company_default_timezone company_default_timezone (optional)
     * @param  string $company_domain_users company_domain_users (optional)
     * @param  string $company_externallyextraopts company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter company_ipfilter (optional)
     * @param  int $company_language company_language (optional)
     * @param  int $company_max_calls company_max_calls (optional)
     * @param  int $company_max_daily_usage company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email company_max_daily_usage_email (optional)
     * @param  string $company_name company_name (optional)
     * @param  string $company_nif company_nif (optional)
     * @param  int $company_on_demand_record company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi company_outgoing_ddi (optional)
     * @param  string $company_postal_address company_postal_address (optional)
     * @param  string $company_postal_code company_postal_code (optional)
     * @param  string $company_province company_province (optional)
     * @param  bool $company_show_invoices company_show_invoices (optional)
     * @param  string $company_town company_town (optional)
     * @param  int $company_transformation_rule_set company_transformation_rule_set (optional)
     * @param  string $company_type company_type (optional)
     * @param  int $company_voicemail_notification_template company_voicemail_notification_template (optional)
     * @param  string $company2 company2 (optional)
     * @param  string $domain_name domain_name (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $language language (optional)
     * @param  string $language2 language2 (optional)
     * @param  bool $language_exists language_exists (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ResidentialDeviceStatus[]
     */
    public function getStatusCollectionResidentialDeviceCollection($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getStatusCollectionResidentialDeviceCollectionWithHttpInfo($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getStatusCollectionResidentialDeviceCollectionWithHttpInfo
     *
     * Retrieves the collection of ResidentialDevice resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ResidentialDeviceStatus[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusCollectionResidentialDeviceCollectionWithHttpInfo($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDeviceStatus[]';
        $request = $this->getStatusCollectionResidentialDeviceCollectionRequest($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ResidentialDeviceStatus[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusCollectionResidentialDeviceCollectionAsync
     *
     * Retrieves the collection of ResidentialDevice resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusCollectionResidentialDeviceCollectionAsync($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getStatusCollectionResidentialDeviceCollectionAsyncWithHttpInfo($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusCollectionResidentialDeviceCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of ResidentialDevice resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusCollectionResidentialDeviceCollectionAsyncWithHttpInfo($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDeviceStatus[]';
        $request = $this->getStatusCollectionResidentialDeviceCollectionRequest($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $language, $language2, $language_exists, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatusCollectionResidentialDeviceCollection'
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusCollectionResidentialDeviceCollectionRequest($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/residential_devices/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company_balance !== null) {
            $queryParams['company.balance'] = ObjectSerializer::toQueryValue($company_balance);
        }
        // query params
        if ($company_billing_method !== null) {
            $queryParams['company.billingMethod'] = ObjectSerializer::toQueryValue($company_billing_method);
        }
        // query params
        if ($company_call_csv_notification_template !== null) {
            $queryParams['company.callCsvNotificationTemplate'] = ObjectSerializer::toQueryValue($company_call_csv_notification_template);
        }
        // query params
        if ($company_country !== null) {
            $queryParams['company.country'] = ObjectSerializer::toQueryValue($company_country);
        }
        // query params
        if ($company_country_name !== null) {
            $queryParams['company.countryName'] = ObjectSerializer::toQueryValue($company_country_name);
        }
        // query params
        if ($company_currency !== null) {
            $queryParams['company.currency'] = ObjectSerializer::toQueryValue($company_currency);
        }
        // query params
        if ($company_default_timezone !== null) {
            $queryParams['company.defaultTimezone'] = ObjectSerializer::toQueryValue($company_default_timezone);
        }
        // query params
        if ($company_domain_users !== null) {
            $queryParams['company.domainUsers'] = ObjectSerializer::toQueryValue($company_domain_users);
        }
        // query params
        if ($company_externallyextraopts !== null) {
            $queryParams['company.externallyextraopts'] = ObjectSerializer::toQueryValue($company_externallyextraopts);
        }
        // query params
        if ($company_fax_notification_template !== null) {
            $queryParams['company.faxNotificationTemplate'] = ObjectSerializer::toQueryValue($company_fax_notification_template);
        }
        // query params
        if ($company_invoice_notification_template !== null) {
            $queryParams['company.invoiceNotificationTemplate'] = ObjectSerializer::toQueryValue($company_invoice_notification_template);
        }
        // query params
        if ($company_ipfilter !== null) {
            $queryParams['company.ipfilter'] = ObjectSerializer::toQueryValue($company_ipfilter);
        }
        // query params
        if ($company_language !== null) {
            $queryParams['company.language'] = ObjectSerializer::toQueryValue($company_language);
        }
        // query params
        if ($company_max_calls !== null) {
            $queryParams['company.maxCalls'] = ObjectSerializer::toQueryValue($company_max_calls);
        }
        // query params
        if ($company_max_daily_usage !== null) {
            $queryParams['company.maxDailyUsage'] = ObjectSerializer::toQueryValue($company_max_daily_usage);
        }
        // query params
        if ($company_max_daily_usage_email !== null) {
            $queryParams['company.maxDailyUsageEmail'] = ObjectSerializer::toQueryValue($company_max_daily_usage_email);
        }
        // query params
        if ($company_name !== null) {
            $queryParams['company.name'] = ObjectSerializer::toQueryValue($company_name);
        }
        // query params
        if ($company_nif !== null) {
            $queryParams['company.nif'] = ObjectSerializer::toQueryValue($company_nif);
        }
        // query params
        if ($company_on_demand_record !== null) {
            $queryParams['company.onDemandRecord'] = ObjectSerializer::toQueryValue($company_on_demand_record);
        }
        // query params
        if ($company_on_demand_record_code !== null) {
            $queryParams['company.onDemandRecordCode'] = ObjectSerializer::toQueryValue($company_on_demand_record_code);
        }
        // query params
        if ($company_outgoing_ddi !== null) {
            $queryParams['company.outgoingDdi'] = ObjectSerializer::toQueryValue($company_outgoing_ddi);
        }
        // query params
        if ($company_postal_address !== null) {
            $queryParams['company.postalAddress'] = ObjectSerializer::toQueryValue($company_postal_address);
        }
        // query params
        if ($company_postal_code !== null) {
            $queryParams['company.postalCode'] = ObjectSerializer::toQueryValue($company_postal_code);
        }
        // query params
        if ($company_province !== null) {
            $queryParams['company.province'] = ObjectSerializer::toQueryValue($company_province);
        }
        // query params
        if ($company_show_invoices !== null) {
            $queryParams['company.showInvoices'] = ObjectSerializer::toQueryValue($company_show_invoices);
        }
        // query params
        if ($company_town !== null) {
            $queryParams['company.town'] = ObjectSerializer::toQueryValue($company_town);
        }
        // query params
        if ($company_transformation_rule_set !== null) {
            $queryParams['company.transformationRuleSet'] = ObjectSerializer::toQueryValue($company_transformation_rule_set);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['company.type'] = ObjectSerializer::toQueryValue($company_type);
        }
        // query params
        if ($company_voicemail_notification_template !== null) {
            $queryParams['company.voicemailNotificationTemplate'] = ObjectSerializer::toQueryValue($company_voicemail_notification_template);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($language2 !== null) {
            $queryParams['language[]'] = ObjectSerializer::toQueryValue($language2);
        }
        // query params
        if ($language_exists !== null) {
            $queryParams['language[exists]'] = ObjectSerializer::toQueryValue($language_exists);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json', 'text/csv', 'application/xml', 'text/xml', 'text/html', 'application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json', 'text/csv', 'application/xml', 'text/xml', 'text/html', 'application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatusCollectionRetailAccountCollection
     *
     * Retrieves the collection of RetailAccount resources.
     *
     * @param  string $company company (optional)
     * @param  float $company_balance company_balance (optional)
     * @param  string $company_billing_method company_billing_method (optional)
     * @param  int $company_call_csv_notification_template company_call_csv_notification_template (optional)
     * @param  int $company_country company_country (optional)
     * @param  string $company_country_name company_country_name (optional)
     * @param  int $company_currency company_currency (optional)
     * @param  int $company_default_timezone company_default_timezone (optional)
     * @param  string $company_domain_users company_domain_users (optional)
     * @param  string $company_externallyextraopts company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter company_ipfilter (optional)
     * @param  int $company_language company_language (optional)
     * @param  int $company_max_calls company_max_calls (optional)
     * @param  int $company_max_daily_usage company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email company_max_daily_usage_email (optional)
     * @param  string $company_name company_name (optional)
     * @param  string $company_nif company_nif (optional)
     * @param  int $company_on_demand_record company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi company_outgoing_ddi (optional)
     * @param  string $company_postal_address company_postal_address (optional)
     * @param  string $company_postal_code company_postal_code (optional)
     * @param  string $company_province company_province (optional)
     * @param  bool $company_show_invoices company_show_invoices (optional)
     * @param  string $company_town company_town (optional)
     * @param  int $company_transformation_rule_set company_transformation_rule_set (optional)
     * @param  string $company_type company_type (optional)
     * @param  int $company_voicemail_notification_template company_voicemail_notification_template (optional)
     * @param  string $company2 company2 (optional)
     * @param  string $domain_name domain_name (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RetailAccountStatus[]
     */
    public function getStatusCollectionRetailAccountCollection($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getStatusCollectionRetailAccountCollectionWithHttpInfo($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getStatusCollectionRetailAccountCollectionWithHttpInfo
     *
     * Retrieves the collection of RetailAccount resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RetailAccountStatus[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusCollectionRetailAccountCollectionWithHttpInfo($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\RetailAccountStatus[]';
        $request = $this->getStatusCollectionRetailAccountCollectionRequest($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RetailAccountStatus[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusCollectionRetailAccountCollectionAsync
     *
     * Retrieves the collection of RetailAccount resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusCollectionRetailAccountCollectionAsync($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getStatusCollectionRetailAccountCollectionAsyncWithHttpInfo($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusCollectionRetailAccountCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of RetailAccount resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusCollectionRetailAccountCollectionAsyncWithHttpInfo($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\RetailAccountStatus[]';
        $request = $this->getStatusCollectionRetailAccountCollectionRequest($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatusCollectionRetailAccountCollection'
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusCollectionRetailAccountCollectionRequest($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/retail_accounts/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company_balance !== null) {
            $queryParams['company.balance'] = ObjectSerializer::toQueryValue($company_balance);
        }
        // query params
        if ($company_billing_method !== null) {
            $queryParams['company.billingMethod'] = ObjectSerializer::toQueryValue($company_billing_method);
        }
        // query params
        if ($company_call_csv_notification_template !== null) {
            $queryParams['company.callCsvNotificationTemplate'] = ObjectSerializer::toQueryValue($company_call_csv_notification_template);
        }
        // query params
        if ($company_country !== null) {
            $queryParams['company.country'] = ObjectSerializer::toQueryValue($company_country);
        }
        // query params
        if ($company_country_name !== null) {
            $queryParams['company.countryName'] = ObjectSerializer::toQueryValue($company_country_name);
        }
        // query params
        if ($company_currency !== null) {
            $queryParams['company.currency'] = ObjectSerializer::toQueryValue($company_currency);
        }
        // query params
        if ($company_default_timezone !== null) {
            $queryParams['company.defaultTimezone'] = ObjectSerializer::toQueryValue($company_default_timezone);
        }
        // query params
        if ($company_domain_users !== null) {
            $queryParams['company.domainUsers'] = ObjectSerializer::toQueryValue($company_domain_users);
        }
        // query params
        if ($company_externallyextraopts !== null) {
            $queryParams['company.externallyextraopts'] = ObjectSerializer::toQueryValue($company_externallyextraopts);
        }
        // query params
        if ($company_fax_notification_template !== null) {
            $queryParams['company.faxNotificationTemplate'] = ObjectSerializer::toQueryValue($company_fax_notification_template);
        }
        // query params
        if ($company_invoice_notification_template !== null) {
            $queryParams['company.invoiceNotificationTemplate'] = ObjectSerializer::toQueryValue($company_invoice_notification_template);
        }
        // query params
        if ($company_ipfilter !== null) {
            $queryParams['company.ipfilter'] = ObjectSerializer::toQueryValue($company_ipfilter);
        }
        // query params
        if ($company_language !== null) {
            $queryParams['company.language'] = ObjectSerializer::toQueryValue($company_language);
        }
        // query params
        if ($company_max_calls !== null) {
            $queryParams['company.maxCalls'] = ObjectSerializer::toQueryValue($company_max_calls);
        }
        // query params
        if ($company_max_daily_usage !== null) {
            $queryParams['company.maxDailyUsage'] = ObjectSerializer::toQueryValue($company_max_daily_usage);
        }
        // query params
        if ($company_max_daily_usage_email !== null) {
            $queryParams['company.maxDailyUsageEmail'] = ObjectSerializer::toQueryValue($company_max_daily_usage_email);
        }
        // query params
        if ($company_name !== null) {
            $queryParams['company.name'] = ObjectSerializer::toQueryValue($company_name);
        }
        // query params
        if ($company_nif !== null) {
            $queryParams['company.nif'] = ObjectSerializer::toQueryValue($company_nif);
        }
        // query params
        if ($company_on_demand_record !== null) {
            $queryParams['company.onDemandRecord'] = ObjectSerializer::toQueryValue($company_on_demand_record);
        }
        // query params
        if ($company_on_demand_record_code !== null) {
            $queryParams['company.onDemandRecordCode'] = ObjectSerializer::toQueryValue($company_on_demand_record_code);
        }
        // query params
        if ($company_outgoing_ddi !== null) {
            $queryParams['company.outgoingDdi'] = ObjectSerializer::toQueryValue($company_outgoing_ddi);
        }
        // query params
        if ($company_postal_address !== null) {
            $queryParams['company.postalAddress'] = ObjectSerializer::toQueryValue($company_postal_address);
        }
        // query params
        if ($company_postal_code !== null) {
            $queryParams['company.postalCode'] = ObjectSerializer::toQueryValue($company_postal_code);
        }
        // query params
        if ($company_province !== null) {
            $queryParams['company.province'] = ObjectSerializer::toQueryValue($company_province);
        }
        // query params
        if ($company_show_invoices !== null) {
            $queryParams['company.showInvoices'] = ObjectSerializer::toQueryValue($company_show_invoices);
        }
        // query params
        if ($company_town !== null) {
            $queryParams['company.town'] = ObjectSerializer::toQueryValue($company_town);
        }
        // query params
        if ($company_transformation_rule_set !== null) {
            $queryParams['company.transformationRuleSet'] = ObjectSerializer::toQueryValue($company_transformation_rule_set);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['company.type'] = ObjectSerializer::toQueryValue($company_type);
        }
        // query params
        if ($company_voicemail_notification_template !== null) {
            $queryParams['company.voicemailNotificationTemplate'] = ObjectSerializer::toQueryValue($company_voicemail_notification_template);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json', 'text/csv', 'application/xml', 'text/xml', 'text/html', 'application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json', 'text/csv', 'application/xml', 'text/xml', 'text/html', 'application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatusCollectionTerminalCollection
     *
     * Retrieves the collection of Terminal resources.
     *
     * @param  string $company company (optional)
     * @param  float $company_balance company_balance (optional)
     * @param  string $company_billing_method company_billing_method (optional)
     * @param  int $company_call_csv_notification_template company_call_csv_notification_template (optional)
     * @param  int $company_country company_country (optional)
     * @param  string $company_country_name company_country_name (optional)
     * @param  int $company_currency company_currency (optional)
     * @param  int $company_default_timezone company_default_timezone (optional)
     * @param  string $company_domain_users company_domain_users (optional)
     * @param  string $company_externallyextraopts company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter company_ipfilter (optional)
     * @param  int $company_language company_language (optional)
     * @param  int $company_max_calls company_max_calls (optional)
     * @param  int $company_max_daily_usage company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email company_max_daily_usage_email (optional)
     * @param  string $company_name company_name (optional)
     * @param  string $company_nif company_nif (optional)
     * @param  int $company_on_demand_record company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi company_outgoing_ddi (optional)
     * @param  string $company_postal_address company_postal_address (optional)
     * @param  string $company_postal_code company_postal_code (optional)
     * @param  string $company_province company_province (optional)
     * @param  bool $company_show_invoices company_show_invoices (optional)
     * @param  string $company_town company_town (optional)
     * @param  int $company_transformation_rule_set company_transformation_rule_set (optional)
     * @param  string $company_type company_type (optional)
     * @param  int $company_voicemail_notification_template company_voicemail_notification_template (optional)
     * @param  string $company2 company2 (optional)
     * @param  string $domain_name domain_name (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TerminalStatus[]
     */
    public function getStatusCollectionTerminalCollection($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getStatusCollectionTerminalCollectionWithHttpInfo($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getStatusCollectionTerminalCollectionWithHttpInfo
     *
     * Retrieves the collection of Terminal resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TerminalStatus[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusCollectionTerminalCollectionWithHttpInfo($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\TerminalStatus[]';
        $request = $this->getStatusCollectionTerminalCollectionRequest($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TerminalStatus[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusCollectionTerminalCollectionAsync
     *
     * Retrieves the collection of Terminal resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusCollectionTerminalCollectionAsync($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getStatusCollectionTerminalCollectionAsyncWithHttpInfo($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusCollectionTerminalCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Terminal resources.
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusCollectionTerminalCollectionAsyncWithHttpInfo($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\TerminalStatus[]';
        $request = $this->getStatusCollectionTerminalCollectionRequest($company, $company_balance, $company_billing_method, $company_call_csv_notification_template, $company_country, $company_country_name, $company_currency, $company_default_timezone, $company_domain_users, $company_externallyextraopts, $company_fax_notification_template, $company_invoice_notification_template, $company_ipfilter, $company_language, $company_max_calls, $company_max_daily_usage, $company_max_daily_usage_email, $company_name, $company_nif, $company_on_demand_record, $company_on_demand_record_code, $company_outgoing_ddi, $company_postal_address, $company_postal_code, $company_province, $company_show_invoices, $company_town, $company_transformation_rule_set, $company_type, $company_voicemail_notification_template, $company2, $domain_name, $id_exact, $name, $name_end, $name_exact, $name_partial, $name_start, $_order_id, $_order_name, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatusCollectionTerminalCollection'
     *
     * @param  string $company (optional)
     * @param  float $company_balance (optional)
     * @param  string $company_billing_method (optional)
     * @param  int $company_call_csv_notification_template (optional)
     * @param  int $company_country (optional)
     * @param  string $company_country_name (optional)
     * @param  int $company_currency (optional)
     * @param  int $company_default_timezone (optional)
     * @param  string $company_domain_users (optional)
     * @param  string $company_externallyextraopts (optional)
     * @param  int $company_fax_notification_template (optional)
     * @param  int $company_invoice_notification_template (optional)
     * @param  bool $company_ipfilter (optional)
     * @param  int $company_language (optional)
     * @param  int $company_max_calls (optional)
     * @param  int $company_max_daily_usage (optional)
     * @param  string $company_max_daily_usage_email (optional)
     * @param  string $company_name (optional)
     * @param  string $company_nif (optional)
     * @param  int $company_on_demand_record (optional)
     * @param  string $company_on_demand_record_code (optional)
     * @param  int $company_outgoing_ddi (optional)
     * @param  string $company_postal_address (optional)
     * @param  string $company_postal_code (optional)
     * @param  string $company_province (optional)
     * @param  bool $company_show_invoices (optional)
     * @param  string $company_town (optional)
     * @param  int $company_transformation_rule_set (optional)
     * @param  string $company_type (optional)
     * @param  int $company_voicemail_notification_template (optional)
     * @param  string $company2 (optional)
     * @param  string $domain_name (optional)
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusCollectionTerminalCollectionRequest($company = null, $company_balance = null, $company_billing_method = null, $company_call_csv_notification_template = null, $company_country = null, $company_country_name = null, $company_currency = null, $company_default_timezone = null, $company_domain_users = null, $company_externallyextraopts = null, $company_fax_notification_template = null, $company_invoice_notification_template = null, $company_ipfilter = null, $company_language = null, $company_max_calls = null, $company_max_daily_usage = null, $company_max_daily_usage_email = null, $company_name = null, $company_nif = null, $company_on_demand_record = null, $company_on_demand_record_code = null, $company_outgoing_ddi = null, $company_postal_address = null, $company_postal_code = null, $company_province = null, $company_show_invoices = null, $company_town = null, $company_transformation_rule_set = null, $company_type = null, $company_voicemail_notification_template = null, $company2 = null, $domain_name = null, $id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $_order_id = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/terminals/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company_balance !== null) {
            $queryParams['company.balance'] = ObjectSerializer::toQueryValue($company_balance);
        }
        // query params
        if ($company_billing_method !== null) {
            $queryParams['company.billingMethod'] = ObjectSerializer::toQueryValue($company_billing_method);
        }
        // query params
        if ($company_call_csv_notification_template !== null) {
            $queryParams['company.callCsvNotificationTemplate'] = ObjectSerializer::toQueryValue($company_call_csv_notification_template);
        }
        // query params
        if ($company_country !== null) {
            $queryParams['company.country'] = ObjectSerializer::toQueryValue($company_country);
        }
        // query params
        if ($company_country_name !== null) {
            $queryParams['company.countryName'] = ObjectSerializer::toQueryValue($company_country_name);
        }
        // query params
        if ($company_currency !== null) {
            $queryParams['company.currency'] = ObjectSerializer::toQueryValue($company_currency);
        }
        // query params
        if ($company_default_timezone !== null) {
            $queryParams['company.defaultTimezone'] = ObjectSerializer::toQueryValue($company_default_timezone);
        }
        // query params
        if ($company_domain_users !== null) {
            $queryParams['company.domainUsers'] = ObjectSerializer::toQueryValue($company_domain_users);
        }
        // query params
        if ($company_externallyextraopts !== null) {
            $queryParams['company.externallyextraopts'] = ObjectSerializer::toQueryValue($company_externallyextraopts);
        }
        // query params
        if ($company_fax_notification_template !== null) {
            $queryParams['company.faxNotificationTemplate'] = ObjectSerializer::toQueryValue($company_fax_notification_template);
        }
        // query params
        if ($company_invoice_notification_template !== null) {
            $queryParams['company.invoiceNotificationTemplate'] = ObjectSerializer::toQueryValue($company_invoice_notification_template);
        }
        // query params
        if ($company_ipfilter !== null) {
            $queryParams['company.ipfilter'] = ObjectSerializer::toQueryValue($company_ipfilter);
        }
        // query params
        if ($company_language !== null) {
            $queryParams['company.language'] = ObjectSerializer::toQueryValue($company_language);
        }
        // query params
        if ($company_max_calls !== null) {
            $queryParams['company.maxCalls'] = ObjectSerializer::toQueryValue($company_max_calls);
        }
        // query params
        if ($company_max_daily_usage !== null) {
            $queryParams['company.maxDailyUsage'] = ObjectSerializer::toQueryValue($company_max_daily_usage);
        }
        // query params
        if ($company_max_daily_usage_email !== null) {
            $queryParams['company.maxDailyUsageEmail'] = ObjectSerializer::toQueryValue($company_max_daily_usage_email);
        }
        // query params
        if ($company_name !== null) {
            $queryParams['company.name'] = ObjectSerializer::toQueryValue($company_name);
        }
        // query params
        if ($company_nif !== null) {
            $queryParams['company.nif'] = ObjectSerializer::toQueryValue($company_nif);
        }
        // query params
        if ($company_on_demand_record !== null) {
            $queryParams['company.onDemandRecord'] = ObjectSerializer::toQueryValue($company_on_demand_record);
        }
        // query params
        if ($company_on_demand_record_code !== null) {
            $queryParams['company.onDemandRecordCode'] = ObjectSerializer::toQueryValue($company_on_demand_record_code);
        }
        // query params
        if ($company_outgoing_ddi !== null) {
            $queryParams['company.outgoingDdi'] = ObjectSerializer::toQueryValue($company_outgoing_ddi);
        }
        // query params
        if ($company_postal_address !== null) {
            $queryParams['company.postalAddress'] = ObjectSerializer::toQueryValue($company_postal_address);
        }
        // query params
        if ($company_postal_code !== null) {
            $queryParams['company.postalCode'] = ObjectSerializer::toQueryValue($company_postal_code);
        }
        // query params
        if ($company_province !== null) {
            $queryParams['company.province'] = ObjectSerializer::toQueryValue($company_province);
        }
        // query params
        if ($company_show_invoices !== null) {
            $queryParams['company.showInvoices'] = ObjectSerializer::toQueryValue($company_show_invoices);
        }
        // query params
        if ($company_town !== null) {
            $queryParams['company.town'] = ObjectSerializer::toQueryValue($company_town);
        }
        // query params
        if ($company_transformation_rule_set !== null) {
            $queryParams['company.transformationRuleSet'] = ObjectSerializer::toQueryValue($company_transformation_rule_set);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['company.type'] = ObjectSerializer::toQueryValue($company_type);
        }
        // query params
        if ($company_voicemail_notification_template !== null) {
            $queryParams['company.voicemailNotificationTemplate'] = ObjectSerializer::toQueryValue($company_voicemail_notification_template);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json', 'text/csv', 'application/xml', 'text/xml', 'text/html', 'application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json', 'text/csv', 'application/xml', 'text/xml', 'text/html', 'application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTimezoneCollection
     *
     * Retrieves the collection of Timezone resources.
     *
     * @param  string $country country (optional)
     * @param  string $country2 country2 (optional)
     * @param  bool $country_exists country_exists (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $tz tz (optional)
     * @param  string $tz_end tz_end (optional)
     * @param  string $tz_exact tz_exact (optional)
     * @param  string $tz_partial tz_partial (optional)
     * @param  string $tz_start tz_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_tz _order_tz (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     * @param  bool $_pagination _pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TimezoneCollection[]
     */
    public function getTimezoneCollection($country = null, $country2 = null, $country_exists = null, $id_exact = null, $tz = null, $tz_end = null, $tz_exact = null, $tz_partial = null, $tz_start = null, $_order_id = null, $_order_tz = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        list($response) = $this->getTimezoneCollectionWithHttpInfo($country, $country2, $country_exists, $id_exact, $tz, $tz_end, $tz_exact, $tz_partial, $tz_start, $_order_id, $_order_tz, $_items_per_page, $_page, $_properties, $_pagination);
        return $response;
    }

    /**
     * Operation getTimezoneCollectionWithHttpInfo
     *
     * Retrieves the collection of Timezone resources.
     *
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $tz (optional)
     * @param  string $tz_end (optional)
     * @param  string $tz_exact (optional)
     * @param  string $tz_partial (optional)
     * @param  string $tz_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_tz (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TimezoneCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimezoneCollectionWithHttpInfo($country = null, $country2 = null, $country_exists = null, $id_exact = null, $tz = null, $tz_end = null, $tz_exact = null, $tz_partial = null, $tz_start = null, $_order_id = null, $_order_tz = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\TimezoneCollection[]';
        $request = $this->getTimezoneCollectionRequest($country, $country2, $country_exists, $id_exact, $tz, $tz_end, $tz_exact, $tz_partial, $tz_start, $_order_id, $_order_tz, $_items_per_page, $_page, $_properties, $_pagination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TimezoneCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTimezoneCollectionAsync
     *
     * Retrieves the collection of Timezone resources.
     *
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $tz (optional)
     * @param  string $tz_end (optional)
     * @param  string $tz_exact (optional)
     * @param  string $tz_partial (optional)
     * @param  string $tz_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_tz (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimezoneCollectionAsync($country = null, $country2 = null, $country_exists = null, $id_exact = null, $tz = null, $tz_end = null, $tz_exact = null, $tz_partial = null, $tz_start = null, $_order_id = null, $_order_tz = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        return $this->getTimezoneCollectionAsyncWithHttpInfo($country, $country2, $country_exists, $id_exact, $tz, $tz_end, $tz_exact, $tz_partial, $tz_start, $_order_id, $_order_tz, $_items_per_page, $_page, $_properties, $_pagination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTimezoneCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Timezone resources.
     *
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $tz (optional)
     * @param  string $tz_end (optional)
     * @param  string $tz_exact (optional)
     * @param  string $tz_partial (optional)
     * @param  string $tz_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_tz (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimezoneCollectionAsyncWithHttpInfo($country = null, $country2 = null, $country_exists = null, $id_exact = null, $tz = null, $tz_end = null, $tz_exact = null, $tz_partial = null, $tz_start = null, $_order_id = null, $_order_tz = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {
        $returnType = '\Delta/Voip\Model\TimezoneCollection[]';
        $request = $this->getTimezoneCollectionRequest($country, $country2, $country_exists, $id_exact, $tz, $tz_end, $tz_exact, $tz_partial, $tz_start, $_order_id, $_order_tz, $_items_per_page, $_page, $_properties, $_pagination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTimezoneCollection'
     *
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  int $id_exact (optional)
     * @param  string $tz (optional)
     * @param  string $tz_end (optional)
     * @param  string $tz_exact (optional)
     * @param  string $tz_partial (optional)
     * @param  string $tz_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_tz (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     * @param  bool $_pagination (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTimezoneCollectionRequest($country = null, $country2 = null, $country_exists = null, $id_exact = null, $tz = null, $tz_end = null, $tz_exact = null, $tz_partial = null, $tz_start = null, $_order_id = null, $_order_tz = null, $_items_per_page = null, $_page = null, $_properties = null, $_pagination = null)
    {

        $resourcePath = '/timezones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($country !== null) {
            $queryParams['country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($country2 !== null) {
            $queryParams['country[]'] = ObjectSerializer::toQueryValue($country2);
        }
        // query params
        if ($country_exists !== null) {
            $queryParams['country[exists]'] = ObjectSerializer::toQueryValue($country_exists);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($tz_end !== null) {
            $queryParams['tz[end]'] = ObjectSerializer::toQueryValue($tz_end);
        }
        // query params
        if ($tz_exact !== null) {
            $queryParams['tz[exact]'] = ObjectSerializer::toQueryValue($tz_exact);
        }
        // query params
        if ($tz_partial !== null) {
            $queryParams['tz[partial]'] = ObjectSerializer::toQueryValue($tz_partial);
        }
        // query params
        if ($tz_start !== null) {
            $queryParams['tz[start]'] = ObjectSerializer::toQueryValue($tz_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_tz !== null) {
            $queryParams['_order[tz]'] = ObjectSerializer::toQueryValue($_order_tz);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }
        // query params
        if ($_pagination !== null) {
            $queryParams['_pagination'] = ObjectSerializer::toQueryValue($_pagination);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTimezoneItem
     *
     * Retrieves a Timezone resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TimezoneDetailed
     */
    public function getTimezoneItem($id)
    {
        list($response) = $this->getTimezoneItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getTimezoneItemWithHttpInfo
     *
     * Retrieves a Timezone resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TimezoneDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimezoneItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\TimezoneDetailed';
        $request = $this->getTimezoneItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TimezoneDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTimezoneItemAsync
     *
     * Retrieves a Timezone resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimezoneItemAsync($id)
    {
        return $this->getTimezoneItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTimezoneItemAsyncWithHttpInfo
     *
     * Retrieves a Timezone resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimezoneItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\TimezoneDetailed';
        $request = $this->getTimezoneItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTimezoneItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTimezoneItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTimezoneItem'
            );
        }

        $resourcePath = '/timezones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransformationRuleCollection
     *
     * Retrieves the collection of TransformationRule resources.
     *
     * @param  string $description description (optional)
     * @param  string $description_end description_end (optional)
     * @param  string $description_exact description_exact (optional)
     * @param  string $description_partial description_partial (optional)
     * @param  string $description_start description_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $match_expr match_expr (optional)
     * @param  string $match_expr_end match_expr_end (optional)
     * @param  string $match_expr_exact match_expr_exact (optional)
     * @param  bool $match_expr_exists match_expr_exists (optional)
     * @param  string $match_expr_partial match_expr_partial (optional)
     * @param  string $match_expr_start match_expr_start (optional)
     * @param  int $priority priority (optional)
     * @param  string $priority_between priority_between (optional)
     * @param  bool $priority_exists priority_exists (optional)
     * @param  string $priority_gt priority_gt (optional)
     * @param  string $priority_gte priority_gte (optional)
     * @param  string $priority_lt priority_lt (optional)
     * @param  string $priority_lte priority_lte (optional)
     * @param  string $replace_expr replace_expr (optional)
     * @param  string $replace_expr_end replace_expr_end (optional)
     * @param  string $replace_expr_exact replace_expr_exact (optional)
     * @param  bool $replace_expr_exists replace_expr_exists (optional)
     * @param  string $replace_expr_partial replace_expr_partial (optional)
     * @param  string $replace_expr_start replace_expr_start (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $type type (optional)
     * @param  string $type_end type_end (optional)
     * @param  string $type_exact type_exact (optional)
     * @param  string $type_partial type_partial (optional)
     * @param  string $type_start type_start (optional)
     * @param  string $_order_description _order_description (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_match_expr _order_match_expr (optional)
     * @param  string $_order_priority _order_priority (optional)
     * @param  string $_order_replace_expr _order_replace_expr (optional)
     * @param  string $_order_type _order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TransformationRuleCollection[]
     */
    public function getTransformationRuleCollection($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $match_expr = null, $match_expr_end = null, $match_expr_exact = null, $match_expr_exists = null, $match_expr_partial = null, $match_expr_start = null, $priority = null, $priority_between = null, $priority_exists = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $replace_expr = null, $replace_expr_end = null, $replace_expr_exact = null, $replace_expr_exists = null, $replace_expr_partial = null, $replace_expr_start = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_description = null, $_order_id = null, $_order_match_expr = null, $_order_priority = null, $_order_replace_expr = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getTransformationRuleCollectionWithHttpInfo($description, $description_end, $description_exact, $description_partial, $description_start, $id_exact, $match_expr, $match_expr_end, $match_expr_exact, $match_expr_exists, $match_expr_partial, $match_expr_start, $priority, $priority_between, $priority_exists, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $replace_expr, $replace_expr_end, $replace_expr_exact, $replace_expr_exists, $replace_expr_partial, $replace_expr_start, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $type, $type_end, $type_exact, $type_partial, $type_start, $_order_description, $_order_id, $_order_match_expr, $_order_priority, $_order_replace_expr, $_order_type, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getTransformationRuleCollectionWithHttpInfo
     *
     * Retrieves the collection of TransformationRule resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $match_expr (optional)
     * @param  string $match_expr_end (optional)
     * @param  string $match_expr_exact (optional)
     * @param  bool $match_expr_exists (optional)
     * @param  string $match_expr_partial (optional)
     * @param  string $match_expr_start (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  bool $priority_exists (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $replace_expr (optional)
     * @param  string $replace_expr_end (optional)
     * @param  string $replace_expr_exact (optional)
     * @param  bool $replace_expr_exists (optional)
     * @param  string $replace_expr_partial (optional)
     * @param  string $replace_expr_start (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_match_expr (optional)
     * @param  string $_order_priority (optional)
     * @param  string $_order_replace_expr (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TransformationRuleCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransformationRuleCollectionWithHttpInfo($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $match_expr = null, $match_expr_end = null, $match_expr_exact = null, $match_expr_exists = null, $match_expr_partial = null, $match_expr_start = null, $priority = null, $priority_between = null, $priority_exists = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $replace_expr = null, $replace_expr_end = null, $replace_expr_exact = null, $replace_expr_exists = null, $replace_expr_partial = null, $replace_expr_start = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_description = null, $_order_id = null, $_order_match_expr = null, $_order_priority = null, $_order_replace_expr = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleCollection[]';
        $request = $this->getTransformationRuleCollectionRequest($description, $description_end, $description_exact, $description_partial, $description_start, $id_exact, $match_expr, $match_expr_end, $match_expr_exact, $match_expr_exists, $match_expr_partial, $match_expr_start, $priority, $priority_between, $priority_exists, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $replace_expr, $replace_expr_end, $replace_expr_exact, $replace_expr_exists, $replace_expr_partial, $replace_expr_start, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $type, $type_end, $type_exact, $type_partial, $type_start, $_order_description, $_order_id, $_order_match_expr, $_order_priority, $_order_replace_expr, $_order_type, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TransformationRuleCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransformationRuleCollectionAsync
     *
     * Retrieves the collection of TransformationRule resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $match_expr (optional)
     * @param  string $match_expr_end (optional)
     * @param  string $match_expr_exact (optional)
     * @param  bool $match_expr_exists (optional)
     * @param  string $match_expr_partial (optional)
     * @param  string $match_expr_start (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  bool $priority_exists (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $replace_expr (optional)
     * @param  string $replace_expr_end (optional)
     * @param  string $replace_expr_exact (optional)
     * @param  bool $replace_expr_exists (optional)
     * @param  string $replace_expr_partial (optional)
     * @param  string $replace_expr_start (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_match_expr (optional)
     * @param  string $_order_priority (optional)
     * @param  string $_order_replace_expr (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransformationRuleCollectionAsync($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $match_expr = null, $match_expr_end = null, $match_expr_exact = null, $match_expr_exists = null, $match_expr_partial = null, $match_expr_start = null, $priority = null, $priority_between = null, $priority_exists = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $replace_expr = null, $replace_expr_end = null, $replace_expr_exact = null, $replace_expr_exists = null, $replace_expr_partial = null, $replace_expr_start = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_description = null, $_order_id = null, $_order_match_expr = null, $_order_priority = null, $_order_replace_expr = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getTransformationRuleCollectionAsyncWithHttpInfo($description, $description_end, $description_exact, $description_partial, $description_start, $id_exact, $match_expr, $match_expr_end, $match_expr_exact, $match_expr_exists, $match_expr_partial, $match_expr_start, $priority, $priority_between, $priority_exists, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $replace_expr, $replace_expr_end, $replace_expr_exact, $replace_expr_exists, $replace_expr_partial, $replace_expr_start, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $type, $type_end, $type_exact, $type_partial, $type_start, $_order_description, $_order_id, $_order_match_expr, $_order_priority, $_order_replace_expr, $_order_type, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransformationRuleCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of TransformationRule resources.
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $match_expr (optional)
     * @param  string $match_expr_end (optional)
     * @param  string $match_expr_exact (optional)
     * @param  bool $match_expr_exists (optional)
     * @param  string $match_expr_partial (optional)
     * @param  string $match_expr_start (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  bool $priority_exists (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $replace_expr (optional)
     * @param  string $replace_expr_end (optional)
     * @param  string $replace_expr_exact (optional)
     * @param  bool $replace_expr_exists (optional)
     * @param  string $replace_expr_partial (optional)
     * @param  string $replace_expr_start (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_match_expr (optional)
     * @param  string $_order_priority (optional)
     * @param  string $_order_replace_expr (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransformationRuleCollectionAsyncWithHttpInfo($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $match_expr = null, $match_expr_end = null, $match_expr_exact = null, $match_expr_exists = null, $match_expr_partial = null, $match_expr_start = null, $priority = null, $priority_between = null, $priority_exists = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $replace_expr = null, $replace_expr_end = null, $replace_expr_exact = null, $replace_expr_exists = null, $replace_expr_partial = null, $replace_expr_start = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_description = null, $_order_id = null, $_order_match_expr = null, $_order_priority = null, $_order_replace_expr = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleCollection[]';
        $request = $this->getTransformationRuleCollectionRequest($description, $description_end, $description_exact, $description_partial, $description_start, $id_exact, $match_expr, $match_expr_end, $match_expr_exact, $match_expr_exists, $match_expr_partial, $match_expr_start, $priority, $priority_between, $priority_exists, $priority_gt, $priority_gte, $priority_lt, $priority_lte, $replace_expr, $replace_expr_end, $replace_expr_exact, $replace_expr_exists, $replace_expr_partial, $replace_expr_start, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $type, $type_end, $type_exact, $type_partial, $type_start, $_order_description, $_order_id, $_order_match_expr, $_order_priority, $_order_replace_expr, $_order_type, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransformationRuleCollection'
     *
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $match_expr (optional)
     * @param  string $match_expr_end (optional)
     * @param  string $match_expr_exact (optional)
     * @param  bool $match_expr_exists (optional)
     * @param  string $match_expr_partial (optional)
     * @param  string $match_expr_start (optional)
     * @param  int $priority (optional)
     * @param  string $priority_between (optional)
     * @param  bool $priority_exists (optional)
     * @param  string $priority_gt (optional)
     * @param  string $priority_gte (optional)
     * @param  string $priority_lt (optional)
     * @param  string $priority_lte (optional)
     * @param  string $replace_expr (optional)
     * @param  string $replace_expr_end (optional)
     * @param  string $replace_expr_exact (optional)
     * @param  bool $replace_expr_exists (optional)
     * @param  string $replace_expr_partial (optional)
     * @param  string $replace_expr_start (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $type (optional)
     * @param  string $type_end (optional)
     * @param  string $type_exact (optional)
     * @param  string $type_partial (optional)
     * @param  string $type_start (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_match_expr (optional)
     * @param  string $_order_priority (optional)
     * @param  string $_order_replace_expr (optional)
     * @param  string $_order_type (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransformationRuleCollectionRequest($description = null, $description_end = null, $description_exact = null, $description_partial = null, $description_start = null, $id_exact = null, $match_expr = null, $match_expr_end = null, $match_expr_exact = null, $match_expr_exists = null, $match_expr_partial = null, $match_expr_start = null, $priority = null, $priority_between = null, $priority_exists = null, $priority_gt = null, $priority_gte = null, $priority_lt = null, $priority_lte = null, $replace_expr = null, $replace_expr_end = null, $replace_expr_exact = null, $replace_expr_exists = null, $replace_expr_partial = null, $replace_expr_start = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $type = null, $type_end = null, $type_exact = null, $type_partial = null, $type_start = null, $_order_description = null, $_order_id = null, $_order_match_expr = null, $_order_priority = null, $_order_replace_expr = null, $_order_type = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/transformation_rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($description_end !== null) {
            $queryParams['description[end]'] = ObjectSerializer::toQueryValue($description_end);
        }
        // query params
        if ($description_exact !== null) {
            $queryParams['description[exact]'] = ObjectSerializer::toQueryValue($description_exact);
        }
        // query params
        if ($description_partial !== null) {
            $queryParams['description[partial]'] = ObjectSerializer::toQueryValue($description_partial);
        }
        // query params
        if ($description_start !== null) {
            $queryParams['description[start]'] = ObjectSerializer::toQueryValue($description_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($match_expr !== null) {
            $queryParams['matchExpr'] = ObjectSerializer::toQueryValue($match_expr);
        }
        // query params
        if ($match_expr_end !== null) {
            $queryParams['matchExpr[end]'] = ObjectSerializer::toQueryValue($match_expr_end);
        }
        // query params
        if ($match_expr_exact !== null) {
            $queryParams['matchExpr[exact]'] = ObjectSerializer::toQueryValue($match_expr_exact);
        }
        // query params
        if ($match_expr_exists !== null) {
            $queryParams['matchExpr[exists]'] = ObjectSerializer::toQueryValue($match_expr_exists);
        }
        // query params
        if ($match_expr_partial !== null) {
            $queryParams['matchExpr[partial]'] = ObjectSerializer::toQueryValue($match_expr_partial);
        }
        // query params
        if ($match_expr_start !== null) {
            $queryParams['matchExpr[start]'] = ObjectSerializer::toQueryValue($match_expr_start);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority);
        }
        // query params
        if ($priority_between !== null) {
            $queryParams['priority[between]'] = ObjectSerializer::toQueryValue($priority_between);
        }
        // query params
        if ($priority_exists !== null) {
            $queryParams['priority[exists]'] = ObjectSerializer::toQueryValue($priority_exists);
        }
        // query params
        if ($priority_gt !== null) {
            $queryParams['priority[gt]'] = ObjectSerializer::toQueryValue($priority_gt);
        }
        // query params
        if ($priority_gte !== null) {
            $queryParams['priority[gte]'] = ObjectSerializer::toQueryValue($priority_gte);
        }
        // query params
        if ($priority_lt !== null) {
            $queryParams['priority[lt]'] = ObjectSerializer::toQueryValue($priority_lt);
        }
        // query params
        if ($priority_lte !== null) {
            $queryParams['priority[lte]'] = ObjectSerializer::toQueryValue($priority_lte);
        }
        // query params
        if ($replace_expr !== null) {
            $queryParams['replaceExpr'] = ObjectSerializer::toQueryValue($replace_expr);
        }
        // query params
        if ($replace_expr_end !== null) {
            $queryParams['replaceExpr[end]'] = ObjectSerializer::toQueryValue($replace_expr_end);
        }
        // query params
        if ($replace_expr_exact !== null) {
            $queryParams['replaceExpr[exact]'] = ObjectSerializer::toQueryValue($replace_expr_exact);
        }
        // query params
        if ($replace_expr_exists !== null) {
            $queryParams['replaceExpr[exists]'] = ObjectSerializer::toQueryValue($replace_expr_exists);
        }
        // query params
        if ($replace_expr_partial !== null) {
            $queryParams['replaceExpr[partial]'] = ObjectSerializer::toQueryValue($replace_expr_partial);
        }
        // query params
        if ($replace_expr_start !== null) {
            $queryParams['replaceExpr[start]'] = ObjectSerializer::toQueryValue($replace_expr_start);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($type_end !== null) {
            $queryParams['type[end]'] = ObjectSerializer::toQueryValue($type_end);
        }
        // query params
        if ($type_exact !== null) {
            $queryParams['type[exact]'] = ObjectSerializer::toQueryValue($type_exact);
        }
        // query params
        if ($type_partial !== null) {
            $queryParams['type[partial]'] = ObjectSerializer::toQueryValue($type_partial);
        }
        // query params
        if ($type_start !== null) {
            $queryParams['type[start]'] = ObjectSerializer::toQueryValue($type_start);
        }
        // query params
        if ($_order_description !== null) {
            $queryParams['_order[description]'] = ObjectSerializer::toQueryValue($_order_description);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_match_expr !== null) {
            $queryParams['_order[matchExpr]'] = ObjectSerializer::toQueryValue($_order_match_expr);
        }
        // query params
        if ($_order_priority !== null) {
            $queryParams['_order[priority]'] = ObjectSerializer::toQueryValue($_order_priority);
        }
        // query params
        if ($_order_replace_expr !== null) {
            $queryParams['_order[replaceExpr]'] = ObjectSerializer::toQueryValue($_order_replace_expr);
        }
        // query params
        if ($_order_type !== null) {
            $queryParams['_order[type]'] = ObjectSerializer::toQueryValue($_order_type);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransformationRuleItem
     *
     * Retrieves a TransformationRule resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TransformationRuleDetailed
     */
    public function getTransformationRuleItem($id)
    {
        list($response) = $this->getTransformationRuleItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getTransformationRuleItemWithHttpInfo
     *
     * Retrieves a TransformationRule resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TransformationRuleDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransformationRuleItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleDetailed';
        $request = $this->getTransformationRuleItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TransformationRuleDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransformationRuleItemAsync
     *
     * Retrieves a TransformationRule resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransformationRuleItemAsync($id)
    {
        return $this->getTransformationRuleItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransformationRuleItemAsyncWithHttpInfo
     *
     * Retrieves a TransformationRule resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransformationRuleItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleDetailed';
        $request = $this->getTransformationRuleItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransformationRuleItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransformationRuleItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTransformationRuleItem'
            );
        }

        $resourcePath = '/transformation_rules/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransformationRuleSetCollection
     *
     * Retrieves the collection of TransformationRuleSet resources.
     *
     * @param  string $area_code area_code (optional)
     * @param  string $area_code_end area_code_end (optional)
     * @param  string $area_code_exact area_code_exact (optional)
     * @param  bool $area_code_exists area_code_exists (optional)
     * @param  string $area_code_partial area_code_partial (optional)
     * @param  string $area_code_start area_code_start (optional)
     * @param  string $country country (optional)
     * @param  string $country2 country2 (optional)
     * @param  bool $country_exists country_exists (optional)
     * @param  string $description description (optional)
     * @param  string $description_end description_end (optional)
     * @param  string $description_exact description_exact (optional)
     * @param  bool $description_exists description_exists (optional)
     * @param  string $description_partial description_partial (optional)
     * @param  string $description_start description_start (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $international_code international_code (optional)
     * @param  string $international_code_end international_code_end (optional)
     * @param  string $international_code_exact international_code_exact (optional)
     * @param  bool $international_code_exists international_code_exists (optional)
     * @param  string $international_code_partial international_code_partial (optional)
     * @param  string $international_code_start international_code_start (optional)
     * @param  string $name name (optional)
     * @param  string $name_ca name_ca (optional)
     * @param  string $name_ca_end name_ca_end (optional)
     * @param  string $name_ca_exact name_ca_exact (optional)
     * @param  string $name_ca_partial name_ca_partial (optional)
     * @param  string $name_ca_start name_ca_start (optional)
     * @param  string $name_en name_en (optional)
     * @param  string $name_en_end name_en_end (optional)
     * @param  string $name_en_exact name_en_exact (optional)
     * @param  string $name_en_partial name_en_partial (optional)
     * @param  string $name_en_start name_en_start (optional)
     * @param  string $name_es name_es (optional)
     * @param  string $name_es_end name_es_end (optional)
     * @param  string $name_es_exact name_es_exact (optional)
     * @param  string $name_es_partial name_es_partial (optional)
     * @param  string $name_es_start name_es_start (optional)
     * @param  string $name_it name_it (optional)
     * @param  string $name_it_end name_it_end (optional)
     * @param  string $name_it_exact name_it_exact (optional)
     * @param  string $name_it_partial name_it_partial (optional)
     * @param  string $name_it_start name_it_start (optional)
     * @param  int $national_len national_len (optional)
     * @param  string $national_len_between national_len_between (optional)
     * @param  bool $national_len_exists national_len_exists (optional)
     * @param  string $national_len_gt national_len_gt (optional)
     * @param  string $national_len_gte national_len_gte (optional)
     * @param  string $national_len_lt national_len_lt (optional)
     * @param  string $national_len_lte national_len_lte (optional)
     * @param  string $trunk_prefix trunk_prefix (optional)
     * @param  string $trunk_prefix_end trunk_prefix_end (optional)
     * @param  string $trunk_prefix_exact trunk_prefix_exact (optional)
     * @param  bool $trunk_prefix_exists trunk_prefix_exists (optional)
     * @param  string $trunk_prefix_partial trunk_prefix_partial (optional)
     * @param  string $trunk_prefix_start trunk_prefix_start (optional)
     * @param  string $_order_area_code _order_area_code (optional)
     * @param  string $_order_description _order_description (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_international_code _order_international_code (optional)
     * @param  string $_order_name_ca _order_name_ca (optional)
     * @param  string $_order_name_en _order_name_en (optional)
     * @param  string $_order_name_es _order_name_es (optional)
     * @param  string $_order_name_it _order_name_it (optional)
     * @param  string $_order_national_len _order_national_len (optional)
     * @param  string $_order_trunk_prefix _order_trunk_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TransformationRuleSetCollection[]
     */
    public function getTransformationRuleSetCollection($area_code = null, $area_code_end = null, $area_code_exact = null, $area_code_exists = null, $area_code_partial = null, $area_code_start = null, $country = null, $country2 = null, $country_exists = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $international_code = null, $international_code_end = null, $international_code_exact = null, $international_code_exists = null, $international_code_partial = null, $international_code_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $national_len = null, $national_len_between = null, $national_len_exists = null, $national_len_gt = null, $national_len_gte = null, $national_len_lt = null, $national_len_lte = null, $trunk_prefix = null, $trunk_prefix_end = null, $trunk_prefix_exact = null, $trunk_prefix_exists = null, $trunk_prefix_partial = null, $trunk_prefix_start = null, $_order_area_code = null, $_order_description = null, $_order_id = null, $_order_international_code = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_national_len = null, $_order_trunk_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getTransformationRuleSetCollectionWithHttpInfo($area_code, $area_code_end, $area_code_exact, $area_code_exists, $area_code_partial, $area_code_start, $country, $country2, $country_exists, $description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $international_code, $international_code_end, $international_code_exact, $international_code_exists, $international_code_partial, $international_code_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $national_len, $national_len_between, $national_len_exists, $national_len_gt, $national_len_gte, $national_len_lt, $national_len_lte, $trunk_prefix, $trunk_prefix_end, $trunk_prefix_exact, $trunk_prefix_exists, $trunk_prefix_partial, $trunk_prefix_start, $_order_area_code, $_order_description, $_order_id, $_order_international_code, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_national_len, $_order_trunk_prefix, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getTransformationRuleSetCollectionWithHttpInfo
     *
     * Retrieves the collection of TransformationRuleSet resources.
     *
     * @param  string $area_code (optional)
     * @param  string $area_code_end (optional)
     * @param  string $area_code_exact (optional)
     * @param  bool $area_code_exists (optional)
     * @param  string $area_code_partial (optional)
     * @param  string $area_code_start (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $international_code (optional)
     * @param  string $international_code_end (optional)
     * @param  string $international_code_exact (optional)
     * @param  bool $international_code_exists (optional)
     * @param  string $international_code_partial (optional)
     * @param  string $international_code_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  int $national_len (optional)
     * @param  string $national_len_between (optional)
     * @param  bool $national_len_exists (optional)
     * @param  string $national_len_gt (optional)
     * @param  string $national_len_gte (optional)
     * @param  string $national_len_lt (optional)
     * @param  string $national_len_lte (optional)
     * @param  string $trunk_prefix (optional)
     * @param  string $trunk_prefix_end (optional)
     * @param  string $trunk_prefix_exact (optional)
     * @param  bool $trunk_prefix_exists (optional)
     * @param  string $trunk_prefix_partial (optional)
     * @param  string $trunk_prefix_start (optional)
     * @param  string $_order_area_code (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_international_code (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_national_len (optional)
     * @param  string $_order_trunk_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TransformationRuleSetCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransformationRuleSetCollectionWithHttpInfo($area_code = null, $area_code_end = null, $area_code_exact = null, $area_code_exists = null, $area_code_partial = null, $area_code_start = null, $country = null, $country2 = null, $country_exists = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $international_code = null, $international_code_end = null, $international_code_exact = null, $international_code_exists = null, $international_code_partial = null, $international_code_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $national_len = null, $national_len_between = null, $national_len_exists = null, $national_len_gt = null, $national_len_gte = null, $national_len_lt = null, $national_len_lte = null, $trunk_prefix = null, $trunk_prefix_end = null, $trunk_prefix_exact = null, $trunk_prefix_exists = null, $trunk_prefix_partial = null, $trunk_prefix_start = null, $_order_area_code = null, $_order_description = null, $_order_id = null, $_order_international_code = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_national_len = null, $_order_trunk_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleSetCollection[]';
        $request = $this->getTransformationRuleSetCollectionRequest($area_code, $area_code_end, $area_code_exact, $area_code_exists, $area_code_partial, $area_code_start, $country, $country2, $country_exists, $description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $international_code, $international_code_end, $international_code_exact, $international_code_exists, $international_code_partial, $international_code_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $national_len, $national_len_between, $national_len_exists, $national_len_gt, $national_len_gte, $national_len_lt, $national_len_lte, $trunk_prefix, $trunk_prefix_end, $trunk_prefix_exact, $trunk_prefix_exists, $trunk_prefix_partial, $trunk_prefix_start, $_order_area_code, $_order_description, $_order_id, $_order_international_code, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_national_len, $_order_trunk_prefix, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TransformationRuleSetCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransformationRuleSetCollectionAsync
     *
     * Retrieves the collection of TransformationRuleSet resources.
     *
     * @param  string $area_code (optional)
     * @param  string $area_code_end (optional)
     * @param  string $area_code_exact (optional)
     * @param  bool $area_code_exists (optional)
     * @param  string $area_code_partial (optional)
     * @param  string $area_code_start (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $international_code (optional)
     * @param  string $international_code_end (optional)
     * @param  string $international_code_exact (optional)
     * @param  bool $international_code_exists (optional)
     * @param  string $international_code_partial (optional)
     * @param  string $international_code_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  int $national_len (optional)
     * @param  string $national_len_between (optional)
     * @param  bool $national_len_exists (optional)
     * @param  string $national_len_gt (optional)
     * @param  string $national_len_gte (optional)
     * @param  string $national_len_lt (optional)
     * @param  string $national_len_lte (optional)
     * @param  string $trunk_prefix (optional)
     * @param  string $trunk_prefix_end (optional)
     * @param  string $trunk_prefix_exact (optional)
     * @param  bool $trunk_prefix_exists (optional)
     * @param  string $trunk_prefix_partial (optional)
     * @param  string $trunk_prefix_start (optional)
     * @param  string $_order_area_code (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_international_code (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_national_len (optional)
     * @param  string $_order_trunk_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransformationRuleSetCollectionAsync($area_code = null, $area_code_end = null, $area_code_exact = null, $area_code_exists = null, $area_code_partial = null, $area_code_start = null, $country = null, $country2 = null, $country_exists = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $international_code = null, $international_code_end = null, $international_code_exact = null, $international_code_exists = null, $international_code_partial = null, $international_code_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $national_len = null, $national_len_between = null, $national_len_exists = null, $national_len_gt = null, $national_len_gte = null, $national_len_lt = null, $national_len_lte = null, $trunk_prefix = null, $trunk_prefix_end = null, $trunk_prefix_exact = null, $trunk_prefix_exists = null, $trunk_prefix_partial = null, $trunk_prefix_start = null, $_order_area_code = null, $_order_description = null, $_order_id = null, $_order_international_code = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_national_len = null, $_order_trunk_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getTransformationRuleSetCollectionAsyncWithHttpInfo($area_code, $area_code_end, $area_code_exact, $area_code_exists, $area_code_partial, $area_code_start, $country, $country2, $country_exists, $description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $international_code, $international_code_end, $international_code_exact, $international_code_exists, $international_code_partial, $international_code_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $national_len, $national_len_between, $national_len_exists, $national_len_gt, $national_len_gte, $national_len_lt, $national_len_lte, $trunk_prefix, $trunk_prefix_end, $trunk_prefix_exact, $trunk_prefix_exists, $trunk_prefix_partial, $trunk_prefix_start, $_order_area_code, $_order_description, $_order_id, $_order_international_code, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_national_len, $_order_trunk_prefix, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransformationRuleSetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of TransformationRuleSet resources.
     *
     * @param  string $area_code (optional)
     * @param  string $area_code_end (optional)
     * @param  string $area_code_exact (optional)
     * @param  bool $area_code_exists (optional)
     * @param  string $area_code_partial (optional)
     * @param  string $area_code_start (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $international_code (optional)
     * @param  string $international_code_end (optional)
     * @param  string $international_code_exact (optional)
     * @param  bool $international_code_exists (optional)
     * @param  string $international_code_partial (optional)
     * @param  string $international_code_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  int $national_len (optional)
     * @param  string $national_len_between (optional)
     * @param  bool $national_len_exists (optional)
     * @param  string $national_len_gt (optional)
     * @param  string $national_len_gte (optional)
     * @param  string $national_len_lt (optional)
     * @param  string $national_len_lte (optional)
     * @param  string $trunk_prefix (optional)
     * @param  string $trunk_prefix_end (optional)
     * @param  string $trunk_prefix_exact (optional)
     * @param  bool $trunk_prefix_exists (optional)
     * @param  string $trunk_prefix_partial (optional)
     * @param  string $trunk_prefix_start (optional)
     * @param  string $_order_area_code (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_international_code (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_national_len (optional)
     * @param  string $_order_trunk_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransformationRuleSetCollectionAsyncWithHttpInfo($area_code = null, $area_code_end = null, $area_code_exact = null, $area_code_exists = null, $area_code_partial = null, $area_code_start = null, $country = null, $country2 = null, $country_exists = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $international_code = null, $international_code_end = null, $international_code_exact = null, $international_code_exists = null, $international_code_partial = null, $international_code_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $national_len = null, $national_len_between = null, $national_len_exists = null, $national_len_gt = null, $national_len_gte = null, $national_len_lt = null, $national_len_lte = null, $trunk_prefix = null, $trunk_prefix_end = null, $trunk_prefix_exact = null, $trunk_prefix_exists = null, $trunk_prefix_partial = null, $trunk_prefix_start = null, $_order_area_code = null, $_order_description = null, $_order_id = null, $_order_international_code = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_national_len = null, $_order_trunk_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleSetCollection[]';
        $request = $this->getTransformationRuleSetCollectionRequest($area_code, $area_code_end, $area_code_exact, $area_code_exists, $area_code_partial, $area_code_start, $country, $country2, $country_exists, $description, $description_end, $description_exact, $description_exists, $description_partial, $description_start, $id_exact, $international_code, $international_code_end, $international_code_exact, $international_code_exists, $international_code_partial, $international_code_start, $name, $name_ca, $name_ca_end, $name_ca_exact, $name_ca_partial, $name_ca_start, $name_en, $name_en_end, $name_en_exact, $name_en_partial, $name_en_start, $name_es, $name_es_end, $name_es_exact, $name_es_partial, $name_es_start, $name_it, $name_it_end, $name_it_exact, $name_it_partial, $name_it_start, $national_len, $national_len_between, $national_len_exists, $national_len_gt, $national_len_gte, $national_len_lt, $national_len_lte, $trunk_prefix, $trunk_prefix_end, $trunk_prefix_exact, $trunk_prefix_exists, $trunk_prefix_partial, $trunk_prefix_start, $_order_area_code, $_order_description, $_order_id, $_order_international_code, $_order_name_ca, $_order_name_en, $_order_name_es, $_order_name_it, $_order_national_len, $_order_trunk_prefix, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransformationRuleSetCollection'
     *
     * @param  string $area_code (optional)
     * @param  string $area_code_end (optional)
     * @param  string $area_code_exact (optional)
     * @param  bool $area_code_exists (optional)
     * @param  string $area_code_partial (optional)
     * @param  string $area_code_start (optional)
     * @param  string $country (optional)
     * @param  string $country2 (optional)
     * @param  bool $country_exists (optional)
     * @param  string $description (optional)
     * @param  string $description_end (optional)
     * @param  string $description_exact (optional)
     * @param  bool $description_exists (optional)
     * @param  string $description_partial (optional)
     * @param  string $description_start (optional)
     * @param  int $id_exact (optional)
     * @param  string $international_code (optional)
     * @param  string $international_code_end (optional)
     * @param  string $international_code_exact (optional)
     * @param  bool $international_code_exists (optional)
     * @param  string $international_code_partial (optional)
     * @param  string $international_code_start (optional)
     * @param  string $name (optional)
     * @param  string $name_ca (optional)
     * @param  string $name_ca_end (optional)
     * @param  string $name_ca_exact (optional)
     * @param  string $name_ca_partial (optional)
     * @param  string $name_ca_start (optional)
     * @param  string $name_en (optional)
     * @param  string $name_en_end (optional)
     * @param  string $name_en_exact (optional)
     * @param  string $name_en_partial (optional)
     * @param  string $name_en_start (optional)
     * @param  string $name_es (optional)
     * @param  string $name_es_end (optional)
     * @param  string $name_es_exact (optional)
     * @param  string $name_es_partial (optional)
     * @param  string $name_es_start (optional)
     * @param  string $name_it (optional)
     * @param  string $name_it_end (optional)
     * @param  string $name_it_exact (optional)
     * @param  string $name_it_partial (optional)
     * @param  string $name_it_start (optional)
     * @param  int $national_len (optional)
     * @param  string $national_len_between (optional)
     * @param  bool $national_len_exists (optional)
     * @param  string $national_len_gt (optional)
     * @param  string $national_len_gte (optional)
     * @param  string $national_len_lt (optional)
     * @param  string $national_len_lte (optional)
     * @param  string $trunk_prefix (optional)
     * @param  string $trunk_prefix_end (optional)
     * @param  string $trunk_prefix_exact (optional)
     * @param  bool $trunk_prefix_exists (optional)
     * @param  string $trunk_prefix_partial (optional)
     * @param  string $trunk_prefix_start (optional)
     * @param  string $_order_area_code (optional)
     * @param  string $_order_description (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_international_code (optional)
     * @param  string $_order_name_ca (optional)
     * @param  string $_order_name_en (optional)
     * @param  string $_order_name_es (optional)
     * @param  string $_order_name_it (optional)
     * @param  string $_order_national_len (optional)
     * @param  string $_order_trunk_prefix (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransformationRuleSetCollectionRequest($area_code = null, $area_code_end = null, $area_code_exact = null, $area_code_exists = null, $area_code_partial = null, $area_code_start = null, $country = null, $country2 = null, $country_exists = null, $description = null, $description_end = null, $description_exact = null, $description_exists = null, $description_partial = null, $description_start = null, $id_exact = null, $international_code = null, $international_code_end = null, $international_code_exact = null, $international_code_exists = null, $international_code_partial = null, $international_code_start = null, $name = null, $name_ca = null, $name_ca_end = null, $name_ca_exact = null, $name_ca_partial = null, $name_ca_start = null, $name_en = null, $name_en_end = null, $name_en_exact = null, $name_en_partial = null, $name_en_start = null, $name_es = null, $name_es_end = null, $name_es_exact = null, $name_es_partial = null, $name_es_start = null, $name_it = null, $name_it_end = null, $name_it_exact = null, $name_it_partial = null, $name_it_start = null, $national_len = null, $national_len_between = null, $national_len_exists = null, $national_len_gt = null, $national_len_gte = null, $national_len_lt = null, $national_len_lte = null, $trunk_prefix = null, $trunk_prefix_end = null, $trunk_prefix_exact = null, $trunk_prefix_exists = null, $trunk_prefix_partial = null, $trunk_prefix_start = null, $_order_area_code = null, $_order_description = null, $_order_id = null, $_order_international_code = null, $_order_name_ca = null, $_order_name_en = null, $_order_name_es = null, $_order_name_it = null, $_order_national_len = null, $_order_trunk_prefix = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/transformation_rule_sets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($area_code !== null) {
            $queryParams['areaCode'] = ObjectSerializer::toQueryValue($area_code);
        }
        // query params
        if ($area_code_end !== null) {
            $queryParams['areaCode[end]'] = ObjectSerializer::toQueryValue($area_code_end);
        }
        // query params
        if ($area_code_exact !== null) {
            $queryParams['areaCode[exact]'] = ObjectSerializer::toQueryValue($area_code_exact);
        }
        // query params
        if ($area_code_exists !== null) {
            $queryParams['areaCode[exists]'] = ObjectSerializer::toQueryValue($area_code_exists);
        }
        // query params
        if ($area_code_partial !== null) {
            $queryParams['areaCode[partial]'] = ObjectSerializer::toQueryValue($area_code_partial);
        }
        // query params
        if ($area_code_start !== null) {
            $queryParams['areaCode[start]'] = ObjectSerializer::toQueryValue($area_code_start);
        }
        // query params
        if ($country !== null) {
            $queryParams['country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($country2 !== null) {
            $queryParams['country[]'] = ObjectSerializer::toQueryValue($country2);
        }
        // query params
        if ($country_exists !== null) {
            $queryParams['country[exists]'] = ObjectSerializer::toQueryValue($country_exists);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($description_end !== null) {
            $queryParams['description[end]'] = ObjectSerializer::toQueryValue($description_end);
        }
        // query params
        if ($description_exact !== null) {
            $queryParams['description[exact]'] = ObjectSerializer::toQueryValue($description_exact);
        }
        // query params
        if ($description_exists !== null) {
            $queryParams['description[exists]'] = ObjectSerializer::toQueryValue($description_exists);
        }
        // query params
        if ($description_partial !== null) {
            $queryParams['description[partial]'] = ObjectSerializer::toQueryValue($description_partial);
        }
        // query params
        if ($description_start !== null) {
            $queryParams['description[start]'] = ObjectSerializer::toQueryValue($description_start);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($international_code !== null) {
            $queryParams['internationalCode'] = ObjectSerializer::toQueryValue($international_code);
        }
        // query params
        if ($international_code_end !== null) {
            $queryParams['internationalCode[end]'] = ObjectSerializer::toQueryValue($international_code_end);
        }
        // query params
        if ($international_code_exact !== null) {
            $queryParams['internationalCode[exact]'] = ObjectSerializer::toQueryValue($international_code_exact);
        }
        // query params
        if ($international_code_exists !== null) {
            $queryParams['internationalCode[exists]'] = ObjectSerializer::toQueryValue($international_code_exists);
        }
        // query params
        if ($international_code_partial !== null) {
            $queryParams['internationalCode[partial]'] = ObjectSerializer::toQueryValue($international_code_partial);
        }
        // query params
        if ($international_code_start !== null) {
            $queryParams['internationalCode[start]'] = ObjectSerializer::toQueryValue($international_code_start);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_ca !== null) {
            $queryParams['name.ca'] = ObjectSerializer::toQueryValue($name_ca);
        }
        // query params
        if ($name_ca_end !== null) {
            $queryParams['name.ca[end]'] = ObjectSerializer::toQueryValue($name_ca_end);
        }
        // query params
        if ($name_ca_exact !== null) {
            $queryParams['name.ca[exact]'] = ObjectSerializer::toQueryValue($name_ca_exact);
        }
        // query params
        if ($name_ca_partial !== null) {
            $queryParams['name.ca[partial]'] = ObjectSerializer::toQueryValue($name_ca_partial);
        }
        // query params
        if ($name_ca_start !== null) {
            $queryParams['name.ca[start]'] = ObjectSerializer::toQueryValue($name_ca_start);
        }
        // query params
        if ($name_en !== null) {
            $queryParams['name.en'] = ObjectSerializer::toQueryValue($name_en);
        }
        // query params
        if ($name_en_end !== null) {
            $queryParams['name.en[end]'] = ObjectSerializer::toQueryValue($name_en_end);
        }
        // query params
        if ($name_en_exact !== null) {
            $queryParams['name.en[exact]'] = ObjectSerializer::toQueryValue($name_en_exact);
        }
        // query params
        if ($name_en_partial !== null) {
            $queryParams['name.en[partial]'] = ObjectSerializer::toQueryValue($name_en_partial);
        }
        // query params
        if ($name_en_start !== null) {
            $queryParams['name.en[start]'] = ObjectSerializer::toQueryValue($name_en_start);
        }
        // query params
        if ($name_es !== null) {
            $queryParams['name.es'] = ObjectSerializer::toQueryValue($name_es);
        }
        // query params
        if ($name_es_end !== null) {
            $queryParams['name.es[end]'] = ObjectSerializer::toQueryValue($name_es_end);
        }
        // query params
        if ($name_es_exact !== null) {
            $queryParams['name.es[exact]'] = ObjectSerializer::toQueryValue($name_es_exact);
        }
        // query params
        if ($name_es_partial !== null) {
            $queryParams['name.es[partial]'] = ObjectSerializer::toQueryValue($name_es_partial);
        }
        // query params
        if ($name_es_start !== null) {
            $queryParams['name.es[start]'] = ObjectSerializer::toQueryValue($name_es_start);
        }
        // query params
        if ($name_it !== null) {
            $queryParams['name.it'] = ObjectSerializer::toQueryValue($name_it);
        }
        // query params
        if ($name_it_end !== null) {
            $queryParams['name.it[end]'] = ObjectSerializer::toQueryValue($name_it_end);
        }
        // query params
        if ($name_it_exact !== null) {
            $queryParams['name.it[exact]'] = ObjectSerializer::toQueryValue($name_it_exact);
        }
        // query params
        if ($name_it_partial !== null) {
            $queryParams['name.it[partial]'] = ObjectSerializer::toQueryValue($name_it_partial);
        }
        // query params
        if ($name_it_start !== null) {
            $queryParams['name.it[start]'] = ObjectSerializer::toQueryValue($name_it_start);
        }
        // query params
        if ($national_len !== null) {
            $queryParams['nationalLen'] = ObjectSerializer::toQueryValue($national_len);
        }
        // query params
        if ($national_len_between !== null) {
            $queryParams['nationalLen[between]'] = ObjectSerializer::toQueryValue($national_len_between);
        }
        // query params
        if ($national_len_exists !== null) {
            $queryParams['nationalLen[exists]'] = ObjectSerializer::toQueryValue($national_len_exists);
        }
        // query params
        if ($national_len_gt !== null) {
            $queryParams['nationalLen[gt]'] = ObjectSerializer::toQueryValue($national_len_gt);
        }
        // query params
        if ($national_len_gte !== null) {
            $queryParams['nationalLen[gte]'] = ObjectSerializer::toQueryValue($national_len_gte);
        }
        // query params
        if ($national_len_lt !== null) {
            $queryParams['nationalLen[lt]'] = ObjectSerializer::toQueryValue($national_len_lt);
        }
        // query params
        if ($national_len_lte !== null) {
            $queryParams['nationalLen[lte]'] = ObjectSerializer::toQueryValue($national_len_lte);
        }
        // query params
        if ($trunk_prefix !== null) {
            $queryParams['trunkPrefix'] = ObjectSerializer::toQueryValue($trunk_prefix);
        }
        // query params
        if ($trunk_prefix_end !== null) {
            $queryParams['trunkPrefix[end]'] = ObjectSerializer::toQueryValue($trunk_prefix_end);
        }
        // query params
        if ($trunk_prefix_exact !== null) {
            $queryParams['trunkPrefix[exact]'] = ObjectSerializer::toQueryValue($trunk_prefix_exact);
        }
        // query params
        if ($trunk_prefix_exists !== null) {
            $queryParams['trunkPrefix[exists]'] = ObjectSerializer::toQueryValue($trunk_prefix_exists);
        }
        // query params
        if ($trunk_prefix_partial !== null) {
            $queryParams['trunkPrefix[partial]'] = ObjectSerializer::toQueryValue($trunk_prefix_partial);
        }
        // query params
        if ($trunk_prefix_start !== null) {
            $queryParams['trunkPrefix[start]'] = ObjectSerializer::toQueryValue($trunk_prefix_start);
        }
        // query params
        if ($_order_area_code !== null) {
            $queryParams['_order[areaCode]'] = ObjectSerializer::toQueryValue($_order_area_code);
        }
        // query params
        if ($_order_description !== null) {
            $queryParams['_order[description]'] = ObjectSerializer::toQueryValue($_order_description);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_international_code !== null) {
            $queryParams['_order[internationalCode]'] = ObjectSerializer::toQueryValue($_order_international_code);
        }
        // query params
        if ($_order_name_ca !== null) {
            $queryParams['_order[name.ca]'] = ObjectSerializer::toQueryValue($_order_name_ca);
        }
        // query params
        if ($_order_name_en !== null) {
            $queryParams['_order[name.en]'] = ObjectSerializer::toQueryValue($_order_name_en);
        }
        // query params
        if ($_order_name_es !== null) {
            $queryParams['_order[name.es]'] = ObjectSerializer::toQueryValue($_order_name_es);
        }
        // query params
        if ($_order_name_it !== null) {
            $queryParams['_order[name.it]'] = ObjectSerializer::toQueryValue($_order_name_it);
        }
        // query params
        if ($_order_national_len !== null) {
            $queryParams['_order[nationalLen]'] = ObjectSerializer::toQueryValue($_order_national_len);
        }
        // query params
        if ($_order_trunk_prefix !== null) {
            $queryParams['_order[trunkPrefix]'] = ObjectSerializer::toQueryValue($_order_trunk_prefix);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransformationRuleSetItem
     *
     * Retrieves a TransformationRuleSet resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TransformationRuleSetDetailed
     */
    public function getTransformationRuleSetItem($id)
    {
        list($response) = $this->getTransformationRuleSetItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getTransformationRuleSetItemWithHttpInfo
     *
     * Retrieves a TransformationRuleSet resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TransformationRuleSetDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransformationRuleSetItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleSetDetailed';
        $request = $this->getTransformationRuleSetItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TransformationRuleSetDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransformationRuleSetItemAsync
     *
     * Retrieves a TransformationRuleSet resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransformationRuleSetItemAsync($id)
    {
        return $this->getTransformationRuleSetItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransformationRuleSetItemAsyncWithHttpInfo
     *
     * Retrieves a TransformationRuleSet resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransformationRuleSetItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleSetDetailed';
        $request = $this->getTransformationRuleSetItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransformationRuleSetItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransformationRuleSetItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTransformationRuleSetItem'
            );
        }

        $resourcePath = '/transformation_rule_sets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserCollection
     *
     * Retrieves the collection of User resources.
     *
     * @param  string $boss_assistant boss_assistant (optional)
     * @param  string $boss_assistant2 boss_assistant2 (optional)
     * @param  bool $boss_assistant_exists boss_assistant_exists (optional)
     * @param  string $company company (optional)
     * @param  string $company2 company2 (optional)
     * @param  int $id_exact id_exact (optional)
     * @param  string $language language (optional)
     * @param  string $language2 language2 (optional)
     * @param  bool $language_exists language_exists (optional)
     * @param  string $lastname lastname (optional)
     * @param  string $lastname_end lastname_end (optional)
     * @param  string $lastname_exact lastname_exact (optional)
     * @param  string $lastname_partial lastname_partial (optional)
     * @param  string $lastname_start lastname_start (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $outgoing_ddi outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists outgoing_ddi_exists (optional)
     * @param  string $terminal terminal (optional)
     * @param  string $terminal2 terminal2 (optional)
     * @param  bool $terminal_exists terminal_exists (optional)
     * @param  string $timezone timezone (optional)
     * @param  string $timezone2 timezone2 (optional)
     * @param  bool $timezone_exists timezone_exists (optional)
     * @param  string $transformation_rule_set transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists transformation_rule_set_exists (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_lastname _order_lastname (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\UserCollection[]
     */
    public function getUserCollection($boss_assistant = null, $boss_assistant2 = null, $boss_assistant_exists = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $terminal = null, $terminal2 = null, $terminal_exists = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getUserCollectionWithHttpInfo($boss_assistant, $boss_assistant2, $boss_assistant_exists, $company, $company2, $id_exact, $language, $language2, $language_exists, $lastname, $lastname_end, $lastname_exact, $lastname_partial, $lastname_start, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $terminal, $terminal2, $terminal_exists, $timezone, $timezone2, $timezone_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_lastname, $_order_name, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getUserCollectionWithHttpInfo
     *
     * Retrieves the collection of User resources.
     *
     * @param  string $boss_assistant (optional)
     * @param  string $boss_assistant2 (optional)
     * @param  bool $boss_assistant_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $lastname (optional)
     * @param  string $lastname_end (optional)
     * @param  string $lastname_exact (optional)
     * @param  string $lastname_partial (optional)
     * @param  string $lastname_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $terminal (optional)
     * @param  string $terminal2 (optional)
     * @param  bool $terminal_exists (optional)
     * @param  string $timezone (optional)
     * @param  string $timezone2 (optional)
     * @param  bool $timezone_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_lastname (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\UserCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserCollectionWithHttpInfo($boss_assistant = null, $boss_assistant2 = null, $boss_assistant_exists = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $terminal = null, $terminal2 = null, $terminal_exists = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\UserCollection[]';
        $request = $this->getUserCollectionRequest($boss_assistant, $boss_assistant2, $boss_assistant_exists, $company, $company2, $id_exact, $language, $language2, $language_exists, $lastname, $lastname_end, $lastname_exact, $lastname_partial, $lastname_start, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $terminal, $terminal2, $terminal_exists, $timezone, $timezone2, $timezone_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_lastname, $_order_name, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\UserCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserCollectionAsync
     *
     * Retrieves the collection of User resources.
     *
     * @param  string $boss_assistant (optional)
     * @param  string $boss_assistant2 (optional)
     * @param  bool $boss_assistant_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $lastname (optional)
     * @param  string $lastname_end (optional)
     * @param  string $lastname_exact (optional)
     * @param  string $lastname_partial (optional)
     * @param  string $lastname_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $terminal (optional)
     * @param  string $terminal2 (optional)
     * @param  bool $terminal_exists (optional)
     * @param  string $timezone (optional)
     * @param  string $timezone2 (optional)
     * @param  bool $timezone_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_lastname (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserCollectionAsync($boss_assistant = null, $boss_assistant2 = null, $boss_assistant_exists = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $terminal = null, $terminal2 = null, $terminal_exists = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getUserCollectionAsyncWithHttpInfo($boss_assistant, $boss_assistant2, $boss_assistant_exists, $company, $company2, $id_exact, $language, $language2, $language_exists, $lastname, $lastname_end, $lastname_exact, $lastname_partial, $lastname_start, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $terminal, $terminal2, $terminal_exists, $timezone, $timezone2, $timezone_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_lastname, $_order_name, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of User resources.
     *
     * @param  string $boss_assistant (optional)
     * @param  string $boss_assistant2 (optional)
     * @param  bool $boss_assistant_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $lastname (optional)
     * @param  string $lastname_end (optional)
     * @param  string $lastname_exact (optional)
     * @param  string $lastname_partial (optional)
     * @param  string $lastname_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $terminal (optional)
     * @param  string $terminal2 (optional)
     * @param  bool $terminal_exists (optional)
     * @param  string $timezone (optional)
     * @param  string $timezone2 (optional)
     * @param  bool $timezone_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_lastname (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserCollectionAsyncWithHttpInfo($boss_assistant = null, $boss_assistant2 = null, $boss_assistant_exists = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $terminal = null, $terminal2 = null, $terminal_exists = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\UserCollection[]';
        $request = $this->getUserCollectionRequest($boss_assistant, $boss_assistant2, $boss_assistant_exists, $company, $company2, $id_exact, $language, $language2, $language_exists, $lastname, $lastname_end, $lastname_exact, $lastname_partial, $lastname_start, $name, $name_end, $name_exact, $name_partial, $name_start, $outgoing_ddi, $outgoing_ddi2, $outgoing_ddi_exists, $terminal, $terminal2, $terminal_exists, $timezone, $timezone2, $timezone_exists, $transformation_rule_set, $transformation_rule_set2, $transformation_rule_set_exists, $_order_id, $_order_lastname, $_order_name, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserCollection'
     *
     * @param  string $boss_assistant (optional)
     * @param  string $boss_assistant2 (optional)
     * @param  bool $boss_assistant_exists (optional)
     * @param  string $company (optional)
     * @param  string $company2 (optional)
     * @param  int $id_exact (optional)
     * @param  string $language (optional)
     * @param  string $language2 (optional)
     * @param  bool $language_exists (optional)
     * @param  string $lastname (optional)
     * @param  string $lastname_end (optional)
     * @param  string $lastname_exact (optional)
     * @param  string $lastname_partial (optional)
     * @param  string $lastname_start (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $outgoing_ddi (optional)
     * @param  string $outgoing_ddi2 (optional)
     * @param  bool $outgoing_ddi_exists (optional)
     * @param  string $terminal (optional)
     * @param  string $terminal2 (optional)
     * @param  bool $terminal_exists (optional)
     * @param  string $timezone (optional)
     * @param  string $timezone2 (optional)
     * @param  bool $timezone_exists (optional)
     * @param  string $transformation_rule_set (optional)
     * @param  string $transformation_rule_set2 (optional)
     * @param  bool $transformation_rule_set_exists (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_lastname (optional)
     * @param  string $_order_name (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserCollectionRequest($boss_assistant = null, $boss_assistant2 = null, $boss_assistant_exists = null, $company = null, $company2 = null, $id_exact = null, $language = null, $language2 = null, $language_exists = null, $lastname = null, $lastname_end = null, $lastname_exact = null, $lastname_partial = null, $lastname_start = null, $name = null, $name_end = null, $name_exact = null, $name_partial = null, $name_start = null, $outgoing_ddi = null, $outgoing_ddi2 = null, $outgoing_ddi_exists = null, $terminal = null, $terminal2 = null, $terminal_exists = null, $timezone = null, $timezone2 = null, $timezone_exists = null, $transformation_rule_set = null, $transformation_rule_set2 = null, $transformation_rule_set_exists = null, $_order_id = null, $_order_lastname = null, $_order_name = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($boss_assistant !== null) {
            $queryParams['bossAssistant'] = ObjectSerializer::toQueryValue($boss_assistant);
        }
        // query params
        if ($boss_assistant2 !== null) {
            $queryParams['bossAssistant[]'] = ObjectSerializer::toQueryValue($boss_assistant2);
        }
        // query params
        if ($boss_assistant_exists !== null) {
            $queryParams['bossAssistant[exists]'] = ObjectSerializer::toQueryValue($boss_assistant_exists);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company2 !== null) {
            $queryParams['company[]'] = ObjectSerializer::toQueryValue($company2);
        }
        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($language2 !== null) {
            $queryParams['language[]'] = ObjectSerializer::toQueryValue($language2);
        }
        // query params
        if ($language_exists !== null) {
            $queryParams['language[exists]'] = ObjectSerializer::toQueryValue($language_exists);
        }
        // query params
        if ($lastname !== null) {
            $queryParams['lastname'] = ObjectSerializer::toQueryValue($lastname);
        }
        // query params
        if ($lastname_end !== null) {
            $queryParams['lastname[end]'] = ObjectSerializer::toQueryValue($lastname_end);
        }
        // query params
        if ($lastname_exact !== null) {
            $queryParams['lastname[exact]'] = ObjectSerializer::toQueryValue($lastname_exact);
        }
        // query params
        if ($lastname_partial !== null) {
            $queryParams['lastname[partial]'] = ObjectSerializer::toQueryValue($lastname_partial);
        }
        // query params
        if ($lastname_start !== null) {
            $queryParams['lastname[start]'] = ObjectSerializer::toQueryValue($lastname_start);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($outgoing_ddi !== null) {
            $queryParams['outgoingDdi'] = ObjectSerializer::toQueryValue($outgoing_ddi);
        }
        // query params
        if ($outgoing_ddi2 !== null) {
            $queryParams['outgoingDdi[]'] = ObjectSerializer::toQueryValue($outgoing_ddi2);
        }
        // query params
        if ($outgoing_ddi_exists !== null) {
            $queryParams['outgoingDdi[exists]'] = ObjectSerializer::toQueryValue($outgoing_ddi_exists);
        }
        // query params
        if ($terminal !== null) {
            $queryParams['terminal'] = ObjectSerializer::toQueryValue($terminal);
        }
        // query params
        if ($terminal2 !== null) {
            $queryParams['terminal[]'] = ObjectSerializer::toQueryValue($terminal2);
        }
        // query params
        if ($terminal_exists !== null) {
            $queryParams['terminal[exists]'] = ObjectSerializer::toQueryValue($terminal_exists);
        }
        // query params
        if ($timezone !== null) {
            $queryParams['timezone'] = ObjectSerializer::toQueryValue($timezone);
        }
        // query params
        if ($timezone2 !== null) {
            $queryParams['timezone[]'] = ObjectSerializer::toQueryValue($timezone2);
        }
        // query params
        if ($timezone_exists !== null) {
            $queryParams['timezone[exists]'] = ObjectSerializer::toQueryValue($timezone_exists);
        }
        // query params
        if ($transformation_rule_set !== null) {
            $queryParams['transformationRuleSet'] = ObjectSerializer::toQueryValue($transformation_rule_set);
        }
        // query params
        if ($transformation_rule_set2 !== null) {
            $queryParams['transformationRuleSet[]'] = ObjectSerializer::toQueryValue($transformation_rule_set2);
        }
        // query params
        if ($transformation_rule_set_exists !== null) {
            $queryParams['transformationRuleSet[exists]'] = ObjectSerializer::toQueryValue($transformation_rule_set_exists);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_lastname !== null) {
            $queryParams['_order[lastname]'] = ObjectSerializer::toQueryValue($_order_lastname);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebPortalCollection
     *
     * Retrieves the collection of WebPortal resources.
     *
     * @param  int $id_exact id_exact (optional)
     * @param  string $name name (optional)
     * @param  string $name_end name_end (optional)
     * @param  string $name_exact name_exact (optional)
     * @param  bool $name_exists name_exists (optional)
     * @param  string $name_partial name_partial (optional)
     * @param  string $name_start name_start (optional)
     * @param  string $url url (optional)
     * @param  string $url_type url_type (optional)
     * @param  string $url_type_end url_type_end (optional)
     * @param  string $url_type_exact url_type_exact (optional)
     * @param  string $url_type_partial url_type_partial (optional)
     * @param  string $url_type_start url_type_start (optional)
     * @param  string $url_end url_end (optional)
     * @param  string $url_exact url_exact (optional)
     * @param  string $url_partial url_partial (optional)
     * @param  string $url_start url_start (optional)
     * @param  string $_order_id _order_id (optional)
     * @param  string $_order_name _order_name (optional)
     * @param  string $_order_url_type _order_url_type (optional)
     * @param  string $_order_url _order_url (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties _properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\WebPortalCollection[]
     */
    public function getWebPortalCollection($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $url = null, $url_type = null, $url_type_end = null, $url_type_exact = null, $url_type_partial = null, $url_type_start = null, $url_end = null, $url_exact = null, $url_partial = null, $url_start = null, $_order_id = null, $_order_name = null, $_order_url_type = null, $_order_url = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        list($response) = $this->getWebPortalCollectionWithHttpInfo($id_exact, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $url, $url_type, $url_type_end, $url_type_exact, $url_type_partial, $url_type_start, $url_end, $url_exact, $url_partial, $url_start, $_order_id, $_order_name, $_order_url_type, $_order_url, $_items_per_page, $_page, $_properties);
        return $response;
    }

    /**
     * Operation getWebPortalCollectionWithHttpInfo
     *
     * Retrieves the collection of WebPortal resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $url (optional)
     * @param  string $url_type (optional)
     * @param  string $url_type_end (optional)
     * @param  string $url_type_exact (optional)
     * @param  string $url_type_partial (optional)
     * @param  string $url_type_start (optional)
     * @param  string $url_end (optional)
     * @param  string $url_exact (optional)
     * @param  string $url_partial (optional)
     * @param  string $url_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_url_type (optional)
     * @param  string $_order_url (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\WebPortalCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebPortalCollectionWithHttpInfo($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $url = null, $url_type = null, $url_type_end = null, $url_type_exact = null, $url_type_partial = null, $url_type_start = null, $url_end = null, $url_exact = null, $url_partial = null, $url_start = null, $_order_id = null, $_order_name = null, $_order_url_type = null, $_order_url = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\WebPortalCollection[]';
        $request = $this->getWebPortalCollectionRequest($id_exact, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $url, $url_type, $url_type_end, $url_type_exact, $url_type_partial, $url_type_start, $url_end, $url_exact, $url_partial, $url_start, $_order_id, $_order_name, $_order_url_type, $_order_url, $_items_per_page, $_page, $_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\WebPortalCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebPortalCollectionAsync
     *
     * Retrieves the collection of WebPortal resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $url (optional)
     * @param  string $url_type (optional)
     * @param  string $url_type_end (optional)
     * @param  string $url_type_exact (optional)
     * @param  string $url_type_partial (optional)
     * @param  string $url_type_start (optional)
     * @param  string $url_end (optional)
     * @param  string $url_exact (optional)
     * @param  string $url_partial (optional)
     * @param  string $url_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_url_type (optional)
     * @param  string $_order_url (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebPortalCollectionAsync($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $url = null, $url_type = null, $url_type_end = null, $url_type_exact = null, $url_type_partial = null, $url_type_start = null, $url_end = null, $url_exact = null, $url_partial = null, $url_start = null, $_order_id = null, $_order_name = null, $_order_url_type = null, $_order_url = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        return $this->getWebPortalCollectionAsyncWithHttpInfo($id_exact, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $url, $url_type, $url_type_end, $url_type_exact, $url_type_partial, $url_type_start, $url_end, $url_exact, $url_partial, $url_start, $_order_id, $_order_name, $_order_url_type, $_order_url, $_items_per_page, $_page, $_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebPortalCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of WebPortal resources.
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $url (optional)
     * @param  string $url_type (optional)
     * @param  string $url_type_end (optional)
     * @param  string $url_type_exact (optional)
     * @param  string $url_type_partial (optional)
     * @param  string $url_type_start (optional)
     * @param  string $url_end (optional)
     * @param  string $url_exact (optional)
     * @param  string $url_partial (optional)
     * @param  string $url_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_url_type (optional)
     * @param  string $_order_url (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebPortalCollectionAsyncWithHttpInfo($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $url = null, $url_type = null, $url_type_end = null, $url_type_exact = null, $url_type_partial = null, $url_type_start = null, $url_end = null, $url_exact = null, $url_partial = null, $url_start = null, $_order_id = null, $_order_name = null, $_order_url_type = null, $_order_url = null, $_items_per_page = null, $_page = null, $_properties = null)
    {
        $returnType = '\Delta/Voip\Model\WebPortalCollection[]';
        $request = $this->getWebPortalCollectionRequest($id_exact, $name, $name_end, $name_exact, $name_exists, $name_partial, $name_start, $url, $url_type, $url_type_end, $url_type_exact, $url_type_partial, $url_type_start, $url_end, $url_exact, $url_partial, $url_start, $_order_id, $_order_name, $_order_url_type, $_order_url, $_items_per_page, $_page, $_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebPortalCollection'
     *
     * @param  int $id_exact (optional)
     * @param  string $name (optional)
     * @param  string $name_end (optional)
     * @param  string $name_exact (optional)
     * @param  bool $name_exists (optional)
     * @param  string $name_partial (optional)
     * @param  string $name_start (optional)
     * @param  string $url (optional)
     * @param  string $url_type (optional)
     * @param  string $url_type_end (optional)
     * @param  string $url_type_exact (optional)
     * @param  string $url_type_partial (optional)
     * @param  string $url_type_start (optional)
     * @param  string $url_end (optional)
     * @param  string $url_exact (optional)
     * @param  string $url_partial (optional)
     * @param  string $url_start (optional)
     * @param  string $_order_id (optional)
     * @param  string $_order_name (optional)
     * @param  string $_order_url_type (optional)
     * @param  string $_order_url (optional)
     * @param  int $_items_per_page The number of items per page (optional)
     * @param  int $_page The collection page number (optional)
     * @param  string $_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebPortalCollectionRequest($id_exact = null, $name = null, $name_end = null, $name_exact = null, $name_exists = null, $name_partial = null, $name_start = null, $url = null, $url_type = null, $url_type_end = null, $url_type_exact = null, $url_type_partial = null, $url_type_start = null, $url_end = null, $url_exact = null, $url_partial = null, $url_start = null, $_order_id = null, $_order_name = null, $_order_url_type = null, $_order_url = null, $_items_per_page = null, $_page = null, $_properties = null)
    {

        $resourcePath = '/web_portals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_exact !== null) {
            $queryParams['id[exact]'] = ObjectSerializer::toQueryValue($id_exact);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_end !== null) {
            $queryParams['name[end]'] = ObjectSerializer::toQueryValue($name_end);
        }
        // query params
        if ($name_exact !== null) {
            $queryParams['name[exact]'] = ObjectSerializer::toQueryValue($name_exact);
        }
        // query params
        if ($name_exists !== null) {
            $queryParams['name[exists]'] = ObjectSerializer::toQueryValue($name_exists);
        }
        // query params
        if ($name_partial !== null) {
            $queryParams['name[partial]'] = ObjectSerializer::toQueryValue($name_partial);
        }
        // query params
        if ($name_start !== null) {
            $queryParams['name[start]'] = ObjectSerializer::toQueryValue($name_start);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($url_type !== null) {
            $queryParams['urlType'] = ObjectSerializer::toQueryValue($url_type);
        }
        // query params
        if ($url_type_end !== null) {
            $queryParams['urlType[end]'] = ObjectSerializer::toQueryValue($url_type_end);
        }
        // query params
        if ($url_type_exact !== null) {
            $queryParams['urlType[exact]'] = ObjectSerializer::toQueryValue($url_type_exact);
        }
        // query params
        if ($url_type_partial !== null) {
            $queryParams['urlType[partial]'] = ObjectSerializer::toQueryValue($url_type_partial);
        }
        // query params
        if ($url_type_start !== null) {
            $queryParams['urlType[start]'] = ObjectSerializer::toQueryValue($url_type_start);
        }
        // query params
        if ($url_end !== null) {
            $queryParams['url[end]'] = ObjectSerializer::toQueryValue($url_end);
        }
        // query params
        if ($url_exact !== null) {
            $queryParams['url[exact]'] = ObjectSerializer::toQueryValue($url_exact);
        }
        // query params
        if ($url_partial !== null) {
            $queryParams['url[partial]'] = ObjectSerializer::toQueryValue($url_partial);
        }
        // query params
        if ($url_start !== null) {
            $queryParams['url[start]'] = ObjectSerializer::toQueryValue($url_start);
        }
        // query params
        if ($_order_id !== null) {
            $queryParams['_order[id]'] = ObjectSerializer::toQueryValue($_order_id);
        }
        // query params
        if ($_order_name !== null) {
            $queryParams['_order[name]'] = ObjectSerializer::toQueryValue($_order_name);
        }
        // query params
        if ($_order_url_type !== null) {
            $queryParams['_order[urlType]'] = ObjectSerializer::toQueryValue($_order_url_type);
        }
        // query params
        if ($_order_url !== null) {
            $queryParams['_order[url]'] = ObjectSerializer::toQueryValue($_order_url);
        }
        // query params
        if ($_items_per_page !== null) {
            $queryParams['_itemsPerPage'] = ObjectSerializer::toQueryValue($_items_per_page);
        }
        // query params
        if ($_page !== null) {
            $queryParams['_page'] = ObjectSerializer::toQueryValue($_page);
        }
        // query params
        if ($_properties !== null) {
            $queryParams['_properties[]'] = ObjectSerializer::toQueryValue($_properties);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebPortalItem
     *
     * Retrieves a WebPortal resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\WebPortalDetailed
     */
    public function getWebPortalItem($id)
    {
        list($response) = $this->getWebPortalItemWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getWebPortalItemWithHttpInfo
     *
     * Retrieves a WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\WebPortalDetailed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebPortalItemWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\WebPortalDetailed';
        $request = $this->getWebPortalItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\WebPortalDetailed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebPortalItemAsync
     *
     * Retrieves a WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebPortalItemAsync($id)
    {
        return $this->getWebPortalItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebPortalItemAsyncWithHttpInfo
     *
     * Retrieves a WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebPortalItemAsyncWithHttpInfo($id)
    {
        $returnType = '\Delta/Voip\Model\WebPortalDetailed';
        $request = $this->getWebPortalItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebPortalItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebPortalItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getWebPortalItem'
            );
        }

        $resourcePath = '/web_portals/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoicePdfInvoiceItem
     *
     * Retrieves a Invoice resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoicePdfInvoiceItem($id)
    {
        $this->invoicePdfInvoiceItemWithHttpInfo($id);
    }

    /**
     * Operation invoicePdfInvoiceItemWithHttpInfo
     *
     * Retrieves a Invoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoicePdfInvoiceItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->invoicePdfInvoiceItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation invoicePdfInvoiceItemAsync
     *
     * Retrieves a Invoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePdfInvoiceItemAsync($id)
    {
        return $this->invoicePdfInvoiceItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoicePdfInvoiceItemAsyncWithHttpInfo
     *
     * Retrieves a Invoice resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePdfInvoiceItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->invoicePdfInvoiceItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoicePdfInvoiceItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function invoicePdfInvoiceItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling invoicePdfInvoiceItem'
            );
        }

        $resourcePath = '/invoices/{id}/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAdministratorCollection
     *
     * Creates a Administrator resource.
     *
     * @param  \Delta/Voip\Model\Administrator $administrator The new Administrator resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Administrator
     */
    public function postAdministratorCollection($administrator = null)
    {
        list($response) = $this->postAdministratorCollectionWithHttpInfo($administrator);
        return $response;
    }

    /**
     * Operation postAdministratorCollectionWithHttpInfo
     *
     * Creates a Administrator resource.
     *
     * @param  \Delta/Voip\Model\Administrator $administrator The new Administrator resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Administrator, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAdministratorCollectionWithHttpInfo($administrator = null)
    {
        $returnType = '\Delta/Voip\Model\Administrator';
        $request = $this->postAdministratorCollectionRequest($administrator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Administrator',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAdministratorCollectionAsync
     *
     * Creates a Administrator resource.
     *
     * @param  \Delta/Voip\Model\Administrator $administrator The new Administrator resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAdministratorCollectionAsync($administrator = null)
    {
        return $this->postAdministratorCollectionAsyncWithHttpInfo($administrator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAdministratorCollectionAsyncWithHttpInfo
     *
     * Creates a Administrator resource.
     *
     * @param  \Delta/Voip\Model\Administrator $administrator The new Administrator resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAdministratorCollectionAsyncWithHttpInfo($administrator = null)
    {
        $returnType = '\Delta/Voip\Model\Administrator';
        $request = $this->postAdministratorCollectionRequest($administrator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAdministratorCollection'
     *
     * @param  \Delta/Voip\Model\Administrator $administrator The new Administrator resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAdministratorCollectionRequest($administrator = null)
    {

        $resourcePath = '/administrators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($administrator)) {
            $_tempBody = $administrator;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postBalanceNotificationCollection
     *
     * Creates a BalanceNotification resource.
     *
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The new BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BalanceNotification
     */
    public function postBalanceNotificationCollection($balance_notification = null, $_timezone = null)
    {
        list($response) = $this->postBalanceNotificationCollectionWithHttpInfo($balance_notification, $_timezone);
        return $response;
    }

    /**
     * Operation postBalanceNotificationCollectionWithHttpInfo
     *
     * Creates a BalanceNotification resource.
     *
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The new BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BalanceNotification, HTTP status code, HTTP response headers (array of strings)
     */
    public function postBalanceNotificationCollectionWithHttpInfo($balance_notification = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BalanceNotification';
        $request = $this->postBalanceNotificationCollectionRequest($balance_notification, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BalanceNotification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postBalanceNotificationCollectionAsync
     *
     * Creates a BalanceNotification resource.
     *
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The new BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBalanceNotificationCollectionAsync($balance_notification = null, $_timezone = null)
    {
        return $this->postBalanceNotificationCollectionAsyncWithHttpInfo($balance_notification, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postBalanceNotificationCollectionAsyncWithHttpInfo
     *
     * Creates a BalanceNotification resource.
     *
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The new BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBalanceNotificationCollectionAsyncWithHttpInfo($balance_notification = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BalanceNotification';
        $request = $this->postBalanceNotificationCollectionRequest($balance_notification, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postBalanceNotificationCollection'
     *
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The new BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postBalanceNotificationCollectionRequest($balance_notification = null, $_timezone = null)
    {

        $resourcePath = '/balance_notifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($balance_notification)) {
            $_tempBody = $balance_notification;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postBrandServiceCollection
     *
     * Creates a BrandService resource.
     *
     * @param  \Delta/Voip\Model\BrandService $brand_service The new BrandService resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BrandService
     */
    public function postBrandServiceCollection($brand_service = null)
    {
        list($response) = $this->postBrandServiceCollectionWithHttpInfo($brand_service);
        return $response;
    }

    /**
     * Operation postBrandServiceCollectionWithHttpInfo
     *
     * Creates a BrandService resource.
     *
     * @param  \Delta/Voip\Model\BrandService $brand_service The new BrandService resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BrandService, HTTP status code, HTTP response headers (array of strings)
     */
    public function postBrandServiceCollectionWithHttpInfo($brand_service = null)
    {
        $returnType = '\Delta/Voip\Model\BrandService';
        $request = $this->postBrandServiceCollectionRequest($brand_service);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BrandService',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postBrandServiceCollectionAsync
     *
     * Creates a BrandService resource.
     *
     * @param  \Delta/Voip\Model\BrandService $brand_service The new BrandService resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBrandServiceCollectionAsync($brand_service = null)
    {
        return $this->postBrandServiceCollectionAsyncWithHttpInfo($brand_service)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postBrandServiceCollectionAsyncWithHttpInfo
     *
     * Creates a BrandService resource.
     *
     * @param  \Delta/Voip\Model\BrandService $brand_service The new BrandService resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBrandServiceCollectionAsyncWithHttpInfo($brand_service = null)
    {
        $returnType = '\Delta/Voip\Model\BrandService';
        $request = $this->postBrandServiceCollectionRequest($brand_service);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postBrandServiceCollection'
     *
     * @param  \Delta/Voip\Model\BrandService $brand_service The new BrandService resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postBrandServiceCollectionRequest($brand_service = null)
    {

        $resourcePath = '/brand_services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($brand_service)) {
            $_tempBody = $brand_service;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCallCsvSchedulerCollection
     *
     * Creates a CallCsvScheduler resource.
     *
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The new CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CallCsvScheduler
     */
    public function postCallCsvSchedulerCollection($call_csv_scheduler = null, $_timezone = null)
    {
        list($response) = $this->postCallCsvSchedulerCollectionWithHttpInfo($call_csv_scheduler, $_timezone);
        return $response;
    }

    /**
     * Operation postCallCsvSchedulerCollectionWithHttpInfo
     *
     * Creates a CallCsvScheduler resource.
     *
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The new CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CallCsvScheduler, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCallCsvSchedulerCollectionWithHttpInfo($call_csv_scheduler = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvScheduler';
        $request = $this->postCallCsvSchedulerCollectionRequest($call_csv_scheduler, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CallCsvScheduler',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCallCsvSchedulerCollectionAsync
     *
     * Creates a CallCsvScheduler resource.
     *
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The new CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCallCsvSchedulerCollectionAsync($call_csv_scheduler = null, $_timezone = null)
    {
        return $this->postCallCsvSchedulerCollectionAsyncWithHttpInfo($call_csv_scheduler, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCallCsvSchedulerCollectionAsyncWithHttpInfo
     *
     * Creates a CallCsvScheduler resource.
     *
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The new CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCallCsvSchedulerCollectionAsyncWithHttpInfo($call_csv_scheduler = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvScheduler';
        $request = $this->postCallCsvSchedulerCollectionRequest($call_csv_scheduler, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCallCsvSchedulerCollection'
     *
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The new CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCallCsvSchedulerCollectionRequest($call_csv_scheduler = null, $_timezone = null)
    {

        $resourcePath = '/call_csv_schedulers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($call_csv_scheduler)) {
            $_tempBody = $call_csv_scheduler;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCarrierCollection
     *
     * Creates a Carrier resource.
     *
     * @param  \Delta/Voip\Model\Carrier $carrier The new Carrier resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Carrier
     */
    public function postCarrierCollection($carrier = null)
    {
        list($response) = $this->postCarrierCollectionWithHttpInfo($carrier);
        return $response;
    }

    /**
     * Operation postCarrierCollectionWithHttpInfo
     *
     * Creates a Carrier resource.
     *
     * @param  \Delta/Voip\Model\Carrier $carrier The new Carrier resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Carrier, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCarrierCollectionWithHttpInfo($carrier = null)
    {
        $returnType = '\Delta/Voip\Model\Carrier';
        $request = $this->postCarrierCollectionRequest($carrier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Carrier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCarrierCollectionAsync
     *
     * Creates a Carrier resource.
     *
     * @param  \Delta/Voip\Model\Carrier $carrier The new Carrier resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCarrierCollectionAsync($carrier = null)
    {
        return $this->postCarrierCollectionAsyncWithHttpInfo($carrier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCarrierCollectionAsyncWithHttpInfo
     *
     * Creates a Carrier resource.
     *
     * @param  \Delta/Voip\Model\Carrier $carrier The new Carrier resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCarrierCollectionAsyncWithHttpInfo($carrier = null)
    {
        $returnType = '\Delta/Voip\Model\Carrier';
        $request = $this->postCarrierCollectionRequest($carrier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCarrierCollection'
     *
     * @param  \Delta/Voip\Model\Carrier $carrier The new Carrier resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCarrierCollectionRequest($carrier = null)
    {

        $resourcePath = '/carriers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($carrier)) {
            $_tempBody = $carrier;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCarrierServerCollection
     *
     * Creates a CarrierServer resource.
     *
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The new CarrierServer resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CarrierServer
     */
    public function postCarrierServerCollection($carrier_server = null)
    {
        list($response) = $this->postCarrierServerCollectionWithHttpInfo($carrier_server);
        return $response;
    }

    /**
     * Operation postCarrierServerCollectionWithHttpInfo
     *
     * Creates a CarrierServer resource.
     *
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The new CarrierServer resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CarrierServer, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCarrierServerCollectionWithHttpInfo($carrier_server = null)
    {
        $returnType = '\Delta/Voip\Model\CarrierServer';
        $request = $this->postCarrierServerCollectionRequest($carrier_server);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CarrierServer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCarrierServerCollectionAsync
     *
     * Creates a CarrierServer resource.
     *
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The new CarrierServer resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCarrierServerCollectionAsync($carrier_server = null)
    {
        return $this->postCarrierServerCollectionAsyncWithHttpInfo($carrier_server)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCarrierServerCollectionAsyncWithHttpInfo
     *
     * Creates a CarrierServer resource.
     *
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The new CarrierServer resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCarrierServerCollectionAsyncWithHttpInfo($carrier_server = null)
    {
        $returnType = '\Delta/Voip\Model\CarrierServer';
        $request = $this->postCarrierServerCollectionRequest($carrier_server);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCarrierServerCollection'
     *
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The new CarrierServer resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCarrierServerCollectionRequest($carrier_server = null)
    {

        $resourcePath = '/carrier_servers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($carrier_server)) {
            $_tempBody = $carrier_server;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCompanyCollection
     *
     * Creates a Company resource.
     *
     * @param  \Delta/Voip\Model\Company $company The new Company resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CompanyWithFeatures
     */
    public function postCompanyCollection($company = null)
    {
        list($response) = $this->postCompanyCollectionWithHttpInfo($company);
        return $response;
    }

    /**
     * Operation postCompanyCollectionWithHttpInfo
     *
     * Creates a Company resource.
     *
     * @param  \Delta/Voip\Model\Company $company The new Company resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CompanyWithFeatures, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCompanyCollectionWithHttpInfo($company = null)
    {
        $returnType = '\Delta/Voip\Model\CompanyWithFeatures';
        $request = $this->postCompanyCollectionRequest($company);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CompanyWithFeatures',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCompanyCollectionAsync
     *
     * Creates a Company resource.
     *
     * @param  \Delta/Voip\Model\Company $company The new Company resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCompanyCollectionAsync($company = null)
    {
        return $this->postCompanyCollectionAsyncWithHttpInfo($company)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCompanyCollectionAsyncWithHttpInfo
     *
     * Creates a Company resource.
     *
     * @param  \Delta/Voip\Model\Company $company The new Company resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCompanyCollectionAsyncWithHttpInfo($company = null)
    {
        $returnType = '\Delta/Voip\Model\CompanyWithFeatures';
        $request = $this->postCompanyCollectionRequest($company);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCompanyCollection'
     *
     * @param  \Delta/Voip\Model\Company $company The new Company resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCompanyCollectionRequest($company = null)
    {

        $resourcePath = '/companies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($company)) {
            $_tempBody = $company;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDdiCollection
     *
     * Creates a Ddi resource.
     *
     * @param  \Delta/Voip\Model\Ddi $ddi The new Ddi resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Ddi
     */
    public function postDdiCollection($ddi = null)
    {
        list($response) = $this->postDdiCollectionWithHttpInfo($ddi);
        return $response;
    }

    /**
     * Operation postDdiCollectionWithHttpInfo
     *
     * Creates a Ddi resource.
     *
     * @param  \Delta/Voip\Model\Ddi $ddi The new Ddi resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Ddi, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDdiCollectionWithHttpInfo($ddi = null)
    {
        $returnType = '\Delta/Voip\Model\Ddi';
        $request = $this->postDdiCollectionRequest($ddi);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Ddi',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDdiCollectionAsync
     *
     * Creates a Ddi resource.
     *
     * @param  \Delta/Voip\Model\Ddi $ddi The new Ddi resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDdiCollectionAsync($ddi = null)
    {
        return $this->postDdiCollectionAsyncWithHttpInfo($ddi)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDdiCollectionAsyncWithHttpInfo
     *
     * Creates a Ddi resource.
     *
     * @param  \Delta/Voip\Model\Ddi $ddi The new Ddi resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDdiCollectionAsyncWithHttpInfo($ddi = null)
    {
        $returnType = '\Delta/Voip\Model\Ddi';
        $request = $this->postDdiCollectionRequest($ddi);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDdiCollection'
     *
     * @param  \Delta/Voip\Model\Ddi $ddi The new Ddi resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDdiCollectionRequest($ddi = null)
    {

        $resourcePath = '/ddis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($ddi)) {
            $_tempBody = $ddi;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDdiProviderAddressCollection
     *
     * Creates a DdiProviderAddress resource.
     *
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The new DdiProviderAddress resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderAddress
     */
    public function postDdiProviderAddressCollection($ddi_provider_address = null)
    {
        list($response) = $this->postDdiProviderAddressCollectionWithHttpInfo($ddi_provider_address);
        return $response;
    }

    /**
     * Operation postDdiProviderAddressCollectionWithHttpInfo
     *
     * Creates a DdiProviderAddress resource.
     *
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The new DdiProviderAddress resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDdiProviderAddressCollectionWithHttpInfo($ddi_provider_address = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderAddress';
        $request = $this->postDdiProviderAddressCollectionRequest($ddi_provider_address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDdiProviderAddressCollectionAsync
     *
     * Creates a DdiProviderAddress resource.
     *
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The new DdiProviderAddress resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDdiProviderAddressCollectionAsync($ddi_provider_address = null)
    {
        return $this->postDdiProviderAddressCollectionAsyncWithHttpInfo($ddi_provider_address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDdiProviderAddressCollectionAsyncWithHttpInfo
     *
     * Creates a DdiProviderAddress resource.
     *
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The new DdiProviderAddress resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDdiProviderAddressCollectionAsyncWithHttpInfo($ddi_provider_address = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderAddress';
        $request = $this->postDdiProviderAddressCollectionRequest($ddi_provider_address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDdiProviderAddressCollection'
     *
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The new DdiProviderAddress resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDdiProviderAddressCollectionRequest($ddi_provider_address = null)
    {

        $resourcePath = '/ddi_provider_addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($ddi_provider_address)) {
            $_tempBody = $ddi_provider_address;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDdiProviderCollection
     *
     * Creates a DdiProvider resource.
     *
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The new DdiProvider resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProvider
     */
    public function postDdiProviderCollection($ddi_provider = null)
    {
        list($response) = $this->postDdiProviderCollectionWithHttpInfo($ddi_provider);
        return $response;
    }

    /**
     * Operation postDdiProviderCollectionWithHttpInfo
     *
     * Creates a DdiProvider resource.
     *
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The new DdiProvider resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProvider, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDdiProviderCollectionWithHttpInfo($ddi_provider = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProvider';
        $request = $this->postDdiProviderCollectionRequest($ddi_provider);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProvider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDdiProviderCollectionAsync
     *
     * Creates a DdiProvider resource.
     *
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The new DdiProvider resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDdiProviderCollectionAsync($ddi_provider = null)
    {
        return $this->postDdiProviderCollectionAsyncWithHttpInfo($ddi_provider)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDdiProviderCollectionAsyncWithHttpInfo
     *
     * Creates a DdiProvider resource.
     *
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The new DdiProvider resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDdiProviderCollectionAsyncWithHttpInfo($ddi_provider = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProvider';
        $request = $this->postDdiProviderCollectionRequest($ddi_provider);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDdiProviderCollection'
     *
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The new DdiProvider resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDdiProviderCollectionRequest($ddi_provider = null)
    {

        $resourcePath = '/ddi_providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($ddi_provider)) {
            $_tempBody = $ddi_provider;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDdiProviderRegistrationCollection
     *
     * Creates a DdiProviderRegistration resource.
     *
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The new DdiProviderRegistration resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderRegistration
     */
    public function postDdiProviderRegistrationCollection($ddi_provider_registration = null)
    {
        list($response) = $this->postDdiProviderRegistrationCollectionWithHttpInfo($ddi_provider_registration);
        return $response;
    }

    /**
     * Operation postDdiProviderRegistrationCollectionWithHttpInfo
     *
     * Creates a DdiProviderRegistration resource.
     *
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The new DdiProviderRegistration resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderRegistration, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDdiProviderRegistrationCollectionWithHttpInfo($ddi_provider_registration = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderRegistration';
        $request = $this->postDdiProviderRegistrationCollectionRequest($ddi_provider_registration);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderRegistration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDdiProviderRegistrationCollectionAsync
     *
     * Creates a DdiProviderRegistration resource.
     *
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The new DdiProviderRegistration resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDdiProviderRegistrationCollectionAsync($ddi_provider_registration = null)
    {
        return $this->postDdiProviderRegistrationCollectionAsyncWithHttpInfo($ddi_provider_registration)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDdiProviderRegistrationCollectionAsyncWithHttpInfo
     *
     * Creates a DdiProviderRegistration resource.
     *
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The new DdiProviderRegistration resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDdiProviderRegistrationCollectionAsyncWithHttpInfo($ddi_provider_registration = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderRegistration';
        $request = $this->postDdiProviderRegistrationCollectionRequest($ddi_provider_registration);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDdiProviderRegistrationCollection'
     *
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The new DdiProviderRegistration resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDdiProviderRegistrationCollectionRequest($ddi_provider_registration = null)
    {

        $resourcePath = '/ddi_provider_registrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($ddi_provider_registration)) {
            $_tempBody = $ddi_provider_registration;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDestinationCollection
     *
     * Creates a Destination resource.
     *
     * @param  \Delta/Voip\Model\Destination $destination The new Destination resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Destination
     */
    public function postDestinationCollection($destination = null)
    {
        list($response) = $this->postDestinationCollectionWithHttpInfo($destination);
        return $response;
    }

    /**
     * Operation postDestinationCollectionWithHttpInfo
     *
     * Creates a Destination resource.
     *
     * @param  \Delta/Voip\Model\Destination $destination The new Destination resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Destination, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDestinationCollectionWithHttpInfo($destination = null)
    {
        $returnType = '\Delta/Voip\Model\Destination';
        $request = $this->postDestinationCollectionRequest($destination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Destination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDestinationCollectionAsync
     *
     * Creates a Destination resource.
     *
     * @param  \Delta/Voip\Model\Destination $destination The new Destination resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDestinationCollectionAsync($destination = null)
    {
        return $this->postDestinationCollectionAsyncWithHttpInfo($destination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDestinationCollectionAsyncWithHttpInfo
     *
     * Creates a Destination resource.
     *
     * @param  \Delta/Voip\Model\Destination $destination The new Destination resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDestinationCollectionAsyncWithHttpInfo($destination = null)
    {
        $returnType = '\Delta/Voip\Model\Destination';
        $request = $this->postDestinationCollectionRequest($destination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDestinationCollection'
     *
     * @param  \Delta/Voip\Model\Destination $destination The new Destination resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDestinationCollectionRequest($destination = null)
    {

        $resourcePath = '/destinations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destination)) {
            $_tempBody = $destination;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDestinationRateCollection
     *
     * Creates a DestinationRate resource.
     *
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The new DestinationRate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationRate
     */
    public function postDestinationRateCollection($destination_rate = null)
    {
        list($response) = $this->postDestinationRateCollectionWithHttpInfo($destination_rate);
        return $response;
    }

    /**
     * Operation postDestinationRateCollectionWithHttpInfo
     *
     * Creates a DestinationRate resource.
     *
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The new DestinationRate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationRate, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDestinationRateCollectionWithHttpInfo($destination_rate = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRate';
        $request = $this->postDestinationRateCollectionRequest($destination_rate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationRate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDestinationRateCollectionAsync
     *
     * Creates a DestinationRate resource.
     *
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The new DestinationRate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDestinationRateCollectionAsync($destination_rate = null)
    {
        return $this->postDestinationRateCollectionAsyncWithHttpInfo($destination_rate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDestinationRateCollectionAsyncWithHttpInfo
     *
     * Creates a DestinationRate resource.
     *
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The new DestinationRate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDestinationRateCollectionAsyncWithHttpInfo($destination_rate = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRate';
        $request = $this->postDestinationRateCollectionRequest($destination_rate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDestinationRateCollection'
     *
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The new DestinationRate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDestinationRateCollectionRequest($destination_rate = null)
    {

        $resourcePath = '/destination_rates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destination_rate)) {
            $_tempBody = $destination_rate;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDestinationRateGroupCollection
     *
     * Creates a DestinationRateGroup resource.
     *
     * @param  string $destination_rate_group The new DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file file (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationRateGroup
     */
    public function postDestinationRateGroupCollection($destination_rate_group = null, $file = null)
    {
        list($response) = $this->postDestinationRateGroupCollectionWithHttpInfo($destination_rate_group, $file);
        return $response;
    }

    /**
     * Operation postDestinationRateGroupCollectionWithHttpInfo
     *
     * Creates a DestinationRateGroup resource.
     *
     * @param  string $destination_rate_group The new DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationRateGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDestinationRateGroupCollectionWithHttpInfo($destination_rate_group = null, $file = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateGroup';
        $request = $this->postDestinationRateGroupCollectionRequest($destination_rate_group, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationRateGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDestinationRateGroupCollectionAsync
     *
     * Creates a DestinationRateGroup resource.
     *
     * @param  string $destination_rate_group The new DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDestinationRateGroupCollectionAsync($destination_rate_group = null, $file = null)
    {
        return $this->postDestinationRateGroupCollectionAsyncWithHttpInfo($destination_rate_group, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDestinationRateGroupCollectionAsyncWithHttpInfo
     *
     * Creates a DestinationRateGroup resource.
     *
     * @param  string $destination_rate_group The new DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDestinationRateGroupCollectionAsyncWithHttpInfo($destination_rate_group = null, $file = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateGroup';
        $request = $this->postDestinationRateGroupCollectionRequest($destination_rate_group, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDestinationRateGroupCollection'
     *
     * @param  string $destination_rate_group The new DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDestinationRateGroupCollectionRequest($destination_rate_group = null, $file = null)
    {

        $resourcePath = '/destination_rate_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($destination_rate_group !== null) {
            $formParams['destinationRateGroup'] = ObjectSerializer::toFormValue($destination_rate_group);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['multipart/form-data', 'application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFeaturesRelCompanyCollection
     *
     * Creates a FeaturesRelCompany resource.
     *
     * @param  \Delta/Voip\Model\FeaturesRelCompany $features_rel_company The new FeaturesRelCompany resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FeaturesRelCompany
     */
    public function postFeaturesRelCompanyCollection($features_rel_company = null)
    {
        list($response) = $this->postFeaturesRelCompanyCollectionWithHttpInfo($features_rel_company);
        return $response;
    }

    /**
     * Operation postFeaturesRelCompanyCollectionWithHttpInfo
     *
     * Creates a FeaturesRelCompany resource.
     *
     * @param  \Delta/Voip\Model\FeaturesRelCompany $features_rel_company The new FeaturesRelCompany resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FeaturesRelCompany, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFeaturesRelCompanyCollectionWithHttpInfo($features_rel_company = null)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelCompany';
        $request = $this->postFeaturesRelCompanyCollectionRequest($features_rel_company);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FeaturesRelCompany',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFeaturesRelCompanyCollectionAsync
     *
     * Creates a FeaturesRelCompany resource.
     *
     * @param  \Delta/Voip\Model\FeaturesRelCompany $features_rel_company The new FeaturesRelCompany resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFeaturesRelCompanyCollectionAsync($features_rel_company = null)
    {
        return $this->postFeaturesRelCompanyCollectionAsyncWithHttpInfo($features_rel_company)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFeaturesRelCompanyCollectionAsyncWithHttpInfo
     *
     * Creates a FeaturesRelCompany resource.
     *
     * @param  \Delta/Voip\Model\FeaturesRelCompany $features_rel_company The new FeaturesRelCompany resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFeaturesRelCompanyCollectionAsyncWithHttpInfo($features_rel_company = null)
    {
        $returnType = '\Delta/Voip\Model\FeaturesRelCompany';
        $request = $this->postFeaturesRelCompanyCollectionRequest($features_rel_company);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFeaturesRelCompanyCollection'
     *
     * @param  \Delta/Voip\Model\FeaturesRelCompany $features_rel_company The new FeaturesRelCompany resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFeaturesRelCompanyCollectionRequest($features_rel_company = null)
    {

        $resourcePath = '/features_rel_companies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($features_rel_company)) {
            $_tempBody = $features_rel_company;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFixedCostCollection
     *
     * Creates a FixedCost resource.
     *
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The new FixedCost resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCost
     */
    public function postFixedCostCollection($fixed_cost = null)
    {
        list($response) = $this->postFixedCostCollectionWithHttpInfo($fixed_cost);
        return $response;
    }

    /**
     * Operation postFixedCostCollectionWithHttpInfo
     *
     * Creates a FixedCost resource.
     *
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The new FixedCost resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCost, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFixedCostCollectionWithHttpInfo($fixed_cost = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCost';
        $request = $this->postFixedCostCollectionRequest($fixed_cost);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCost',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFixedCostCollectionAsync
     *
     * Creates a FixedCost resource.
     *
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The new FixedCost resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFixedCostCollectionAsync($fixed_cost = null)
    {
        return $this->postFixedCostCollectionAsyncWithHttpInfo($fixed_cost)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFixedCostCollectionAsyncWithHttpInfo
     *
     * Creates a FixedCost resource.
     *
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The new FixedCost resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFixedCostCollectionAsyncWithHttpInfo($fixed_cost = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCost';
        $request = $this->postFixedCostCollectionRequest($fixed_cost);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFixedCostCollection'
     *
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The new FixedCost resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFixedCostCollectionRequest($fixed_cost = null)
    {

        $resourcePath = '/fixed_costs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($fixed_cost)) {
            $_tempBody = $fixed_cost;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFixedCostsRelInvoiceCollection
     *
     * Creates a FixedCostsRelInvoice resource.
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The new FixedCostsRelInvoice resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostsRelInvoice
     */
    public function postFixedCostsRelInvoiceCollection($fixed_costs_rel_invoice = null)
    {
        list($response) = $this->postFixedCostsRelInvoiceCollectionWithHttpInfo($fixed_costs_rel_invoice);
        return $response;
    }

    /**
     * Operation postFixedCostsRelInvoiceCollectionWithHttpInfo
     *
     * Creates a FixedCostsRelInvoice resource.
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The new FixedCostsRelInvoice resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostsRelInvoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFixedCostsRelInvoiceCollectionWithHttpInfo($fixed_costs_rel_invoice = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoice';
        $request = $this->postFixedCostsRelInvoiceCollectionRequest($fixed_costs_rel_invoice);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostsRelInvoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFixedCostsRelInvoiceCollectionAsync
     *
     * Creates a FixedCostsRelInvoice resource.
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The new FixedCostsRelInvoice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFixedCostsRelInvoiceCollectionAsync($fixed_costs_rel_invoice = null)
    {
        return $this->postFixedCostsRelInvoiceCollectionAsyncWithHttpInfo($fixed_costs_rel_invoice)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFixedCostsRelInvoiceCollectionAsyncWithHttpInfo
     *
     * Creates a FixedCostsRelInvoice resource.
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The new FixedCostsRelInvoice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFixedCostsRelInvoiceCollectionAsyncWithHttpInfo($fixed_costs_rel_invoice = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoice';
        $request = $this->postFixedCostsRelInvoiceCollectionRequest($fixed_costs_rel_invoice);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFixedCostsRelInvoiceCollection'
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The new FixedCostsRelInvoice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFixedCostsRelInvoiceCollectionRequest($fixed_costs_rel_invoice = null)
    {

        $resourcePath = '/fixed_costs_rel_invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($fixed_costs_rel_invoice)) {
            $_tempBody = $fixed_costs_rel_invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFixedCostsRelInvoiceSchedulerCollection
     *
     * Creates a FixedCostsRelInvoiceScheduler resource.
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The new FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostsRelInvoiceScheduler
     */
    public function postFixedCostsRelInvoiceSchedulerCollection($fixed_costs_rel_invoice_scheduler = null)
    {
        list($response) = $this->postFixedCostsRelInvoiceSchedulerCollectionWithHttpInfo($fixed_costs_rel_invoice_scheduler);
        return $response;
    }

    /**
     * Operation postFixedCostsRelInvoiceSchedulerCollectionWithHttpInfo
     *
     * Creates a FixedCostsRelInvoiceScheduler resource.
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The new FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostsRelInvoiceScheduler, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFixedCostsRelInvoiceSchedulerCollectionWithHttpInfo($fixed_costs_rel_invoice_scheduler = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceScheduler';
        $request = $this->postFixedCostsRelInvoiceSchedulerCollectionRequest($fixed_costs_rel_invoice_scheduler);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostsRelInvoiceScheduler',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFixedCostsRelInvoiceSchedulerCollectionAsync
     *
     * Creates a FixedCostsRelInvoiceScheduler resource.
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The new FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFixedCostsRelInvoiceSchedulerCollectionAsync($fixed_costs_rel_invoice_scheduler = null)
    {
        return $this->postFixedCostsRelInvoiceSchedulerCollectionAsyncWithHttpInfo($fixed_costs_rel_invoice_scheduler)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFixedCostsRelInvoiceSchedulerCollectionAsyncWithHttpInfo
     *
     * Creates a FixedCostsRelInvoiceScheduler resource.
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The new FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFixedCostsRelInvoiceSchedulerCollectionAsyncWithHttpInfo($fixed_costs_rel_invoice_scheduler = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceScheduler';
        $request = $this->postFixedCostsRelInvoiceSchedulerCollectionRequest($fixed_costs_rel_invoice_scheduler);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFixedCostsRelInvoiceSchedulerCollection'
     *
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The new FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFixedCostsRelInvoiceSchedulerCollectionRequest($fixed_costs_rel_invoice_scheduler = null)
    {

        $resourcePath = '/fixed_costs_rel_invoice_schedulers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($fixed_costs_rel_invoice_scheduler)) {
            $_tempBody = $fixed_costs_rel_invoice_scheduler;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFriendCollection
     *
     * Creates a Friend resource.
     *
     * @param  \Delta/Voip\Model\Friend $friend The new Friend resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Friend
     */
    public function postFriendCollection($friend = null)
    {
        list($response) = $this->postFriendCollectionWithHttpInfo($friend);
        return $response;
    }

    /**
     * Operation postFriendCollectionWithHttpInfo
     *
     * Creates a Friend resource.
     *
     * @param  \Delta/Voip\Model\Friend $friend The new Friend resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Friend, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFriendCollectionWithHttpInfo($friend = null)
    {
        $returnType = '\Delta/Voip\Model\Friend';
        $request = $this->postFriendCollectionRequest($friend);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Friend',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFriendCollectionAsync
     *
     * Creates a Friend resource.
     *
     * @param  \Delta/Voip\Model\Friend $friend The new Friend resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFriendCollectionAsync($friend = null)
    {
        return $this->postFriendCollectionAsyncWithHttpInfo($friend)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFriendCollectionAsyncWithHttpInfo
     *
     * Creates a Friend resource.
     *
     * @param  \Delta/Voip\Model\Friend $friend The new Friend resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFriendCollectionAsyncWithHttpInfo($friend = null)
    {
        $returnType = '\Delta/Voip\Model\Friend';
        $request = $this->postFriendCollectionRequest($friend);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFriendCollection'
     *
     * @param  \Delta/Voip\Model\Friend $friend The new Friend resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFriendCollectionRequest($friend = null)
    {

        $resourcePath = '/friends';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($friend)) {
            $_tempBody = $friend;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postInvoiceCollection
     *
     * Creates a Invoice resource.
     *
     * @param  \Delta/Voip\Model\Invoice $invoice The new Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Invoice
     */
    public function postInvoiceCollection($invoice = null, $_timezone = null)
    {
        list($response) = $this->postInvoiceCollectionWithHttpInfo($invoice, $_timezone);
        return $response;
    }

    /**
     * Operation postInvoiceCollectionWithHttpInfo
     *
     * Creates a Invoice resource.
     *
     * @param  \Delta/Voip\Model\Invoice $invoice The new Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function postInvoiceCollectionWithHttpInfo($invoice = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\Invoice';
        $request = $this->postInvoiceCollectionRequest($invoice, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postInvoiceCollectionAsync
     *
     * Creates a Invoice resource.
     *
     * @param  \Delta/Voip\Model\Invoice $invoice The new Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInvoiceCollectionAsync($invoice = null, $_timezone = null)
    {
        return $this->postInvoiceCollectionAsyncWithHttpInfo($invoice, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postInvoiceCollectionAsyncWithHttpInfo
     *
     * Creates a Invoice resource.
     *
     * @param  \Delta/Voip\Model\Invoice $invoice The new Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInvoiceCollectionAsyncWithHttpInfo($invoice = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\Invoice';
        $request = $this->postInvoiceCollectionRequest($invoice, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postInvoiceCollection'
     *
     * @param  \Delta/Voip\Model\Invoice $invoice The new Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postInvoiceCollectionRequest($invoice = null, $_timezone = null)
    {

        $resourcePath = '/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($invoice)) {
            $_tempBody = $invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postInvoiceNumberSequenceCollection
     *
     * Creates a InvoiceNumberSequence resource.
     *
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The new InvoiceNumberSequence resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceNumberSequence
     */
    public function postInvoiceNumberSequenceCollection($invoice_number_sequence = null)
    {
        list($response) = $this->postInvoiceNumberSequenceCollectionWithHttpInfo($invoice_number_sequence);
        return $response;
    }

    /**
     * Operation postInvoiceNumberSequenceCollectionWithHttpInfo
     *
     * Creates a InvoiceNumberSequence resource.
     *
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The new InvoiceNumberSequence resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceNumberSequence, HTTP status code, HTTP response headers (array of strings)
     */
    public function postInvoiceNumberSequenceCollectionWithHttpInfo($invoice_number_sequence = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceNumberSequence';
        $request = $this->postInvoiceNumberSequenceCollectionRequest($invoice_number_sequence);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceNumberSequence',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postInvoiceNumberSequenceCollectionAsync
     *
     * Creates a InvoiceNumberSequence resource.
     *
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The new InvoiceNumberSequence resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInvoiceNumberSequenceCollectionAsync($invoice_number_sequence = null)
    {
        return $this->postInvoiceNumberSequenceCollectionAsyncWithHttpInfo($invoice_number_sequence)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postInvoiceNumberSequenceCollectionAsyncWithHttpInfo
     *
     * Creates a InvoiceNumberSequence resource.
     *
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The new InvoiceNumberSequence resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInvoiceNumberSequenceCollectionAsyncWithHttpInfo($invoice_number_sequence = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceNumberSequence';
        $request = $this->postInvoiceNumberSequenceCollectionRequest($invoice_number_sequence);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postInvoiceNumberSequenceCollection'
     *
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The new InvoiceNumberSequence resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postInvoiceNumberSequenceCollectionRequest($invoice_number_sequence = null)
    {

        $resourcePath = '/invoice_number_sequences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($invoice_number_sequence)) {
            $_tempBody = $invoice_number_sequence;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postInvoiceSchedulerCollection
     *
     * Creates a InvoiceScheduler resource.
     *
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The new InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceScheduler
     */
    public function postInvoiceSchedulerCollection($invoice_scheduler = null, $_timezone = null)
    {
        list($response) = $this->postInvoiceSchedulerCollectionWithHttpInfo($invoice_scheduler, $_timezone);
        return $response;
    }

    /**
     * Operation postInvoiceSchedulerCollectionWithHttpInfo
     *
     * Creates a InvoiceScheduler resource.
     *
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The new InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceScheduler, HTTP status code, HTTP response headers (array of strings)
     */
    public function postInvoiceSchedulerCollectionWithHttpInfo($invoice_scheduler = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceScheduler';
        $request = $this->postInvoiceSchedulerCollectionRequest($invoice_scheduler, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceScheduler',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postInvoiceSchedulerCollectionAsync
     *
     * Creates a InvoiceScheduler resource.
     *
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The new InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInvoiceSchedulerCollectionAsync($invoice_scheduler = null, $_timezone = null)
    {
        return $this->postInvoiceSchedulerCollectionAsyncWithHttpInfo($invoice_scheduler, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postInvoiceSchedulerCollectionAsyncWithHttpInfo
     *
     * Creates a InvoiceScheduler resource.
     *
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The new InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInvoiceSchedulerCollectionAsyncWithHttpInfo($invoice_scheduler = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceScheduler';
        $request = $this->postInvoiceSchedulerCollectionRequest($invoice_scheduler, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postInvoiceSchedulerCollection'
     *
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The new InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postInvoiceSchedulerCollectionRequest($invoice_scheduler = null, $_timezone = null)
    {

        $resourcePath = '/invoice_schedulers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($invoice_scheduler)) {
            $_tempBody = $invoice_scheduler;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postInvoiceTemplateCollection
     *
     * Creates a InvoiceTemplate resource.
     *
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The new InvoiceTemplate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceTemplate
     */
    public function postInvoiceTemplateCollection($invoice_template = null)
    {
        list($response) = $this->postInvoiceTemplateCollectionWithHttpInfo($invoice_template);
        return $response;
    }

    /**
     * Operation postInvoiceTemplateCollectionWithHttpInfo
     *
     * Creates a InvoiceTemplate resource.
     *
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The new InvoiceTemplate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function postInvoiceTemplateCollectionWithHttpInfo($invoice_template = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceTemplate';
        $request = $this->postInvoiceTemplateCollectionRequest($invoice_template);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postInvoiceTemplateCollectionAsync
     *
     * Creates a InvoiceTemplate resource.
     *
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The new InvoiceTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInvoiceTemplateCollectionAsync($invoice_template = null)
    {
        return $this->postInvoiceTemplateCollectionAsyncWithHttpInfo($invoice_template)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postInvoiceTemplateCollectionAsyncWithHttpInfo
     *
     * Creates a InvoiceTemplate resource.
     *
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The new InvoiceTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInvoiceTemplateCollectionAsyncWithHttpInfo($invoice_template = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceTemplate';
        $request = $this->postInvoiceTemplateCollectionRequest($invoice_template);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postInvoiceTemplateCollection'
     *
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The new InvoiceTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postInvoiceTemplateCollectionRequest($invoice_template = null)
    {

        $resourcePath = '/invoice_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($invoice_template)) {
            $_tempBody = $invoice_template;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postNotificationTemplateCollection
     *
     * Creates a NotificationTemplate resource.
     *
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The new NotificationTemplate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\NotificationTemplate
     */
    public function postNotificationTemplateCollection($notification_template = null)
    {
        list($response) = $this->postNotificationTemplateCollectionWithHttpInfo($notification_template);
        return $response;
    }

    /**
     * Operation postNotificationTemplateCollectionWithHttpInfo
     *
     * Creates a NotificationTemplate resource.
     *
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The new NotificationTemplate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\NotificationTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function postNotificationTemplateCollectionWithHttpInfo($notification_template = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplate';
        $request = $this->postNotificationTemplateCollectionRequest($notification_template);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\NotificationTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postNotificationTemplateCollectionAsync
     *
     * Creates a NotificationTemplate resource.
     *
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The new NotificationTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNotificationTemplateCollectionAsync($notification_template = null)
    {
        return $this->postNotificationTemplateCollectionAsyncWithHttpInfo($notification_template)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postNotificationTemplateCollectionAsyncWithHttpInfo
     *
     * Creates a NotificationTemplate resource.
     *
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The new NotificationTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNotificationTemplateCollectionAsyncWithHttpInfo($notification_template = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplate';
        $request = $this->postNotificationTemplateCollectionRequest($notification_template);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postNotificationTemplateCollection'
     *
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The new NotificationTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postNotificationTemplateCollectionRequest($notification_template = null)
    {

        $resourcePath = '/notification_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($notification_template)) {
            $_tempBody = $notification_template;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postNotificationTemplateContentCollection
     *
     * Creates a NotificationTemplateContent resource.
     *
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The new NotificationTemplateContent resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\NotificationTemplateContent
     */
    public function postNotificationTemplateContentCollection($notification_template_content = null)
    {
        list($response) = $this->postNotificationTemplateContentCollectionWithHttpInfo($notification_template_content);
        return $response;
    }

    /**
     * Operation postNotificationTemplateContentCollectionWithHttpInfo
     *
     * Creates a NotificationTemplateContent resource.
     *
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The new NotificationTemplateContent resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\NotificationTemplateContent, HTTP status code, HTTP response headers (array of strings)
     */
    public function postNotificationTemplateContentCollectionWithHttpInfo($notification_template_content = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateContent';
        $request = $this->postNotificationTemplateContentCollectionRequest($notification_template_content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\NotificationTemplateContent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postNotificationTemplateContentCollectionAsync
     *
     * Creates a NotificationTemplateContent resource.
     *
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The new NotificationTemplateContent resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNotificationTemplateContentCollectionAsync($notification_template_content = null)
    {
        return $this->postNotificationTemplateContentCollectionAsyncWithHttpInfo($notification_template_content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postNotificationTemplateContentCollectionAsyncWithHttpInfo
     *
     * Creates a NotificationTemplateContent resource.
     *
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The new NotificationTemplateContent resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNotificationTemplateContentCollectionAsyncWithHttpInfo($notification_template_content = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateContent';
        $request = $this->postNotificationTemplateContentCollectionRequest($notification_template_content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postNotificationTemplateContentCollection'
     *
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The new NotificationTemplateContent resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postNotificationTemplateContentCollectionRequest($notification_template_content = null)
    {

        $resourcePath = '/notification_template_contents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($notification_template_content)) {
            $_tempBody = $notification_template_content;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postOutgoingRoutingCollection
     *
     * Creates a OutgoingRouting resource.
     *
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The new OutgoingRouting resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\OutgoingRoutingWithCarriers
     */
    public function postOutgoingRoutingCollection($outgoing_routing = null)
    {
        list($response) = $this->postOutgoingRoutingCollectionWithHttpInfo($outgoing_routing);
        return $response;
    }

    /**
     * Operation postOutgoingRoutingCollectionWithHttpInfo
     *
     * Creates a OutgoingRouting resource.
     *
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The new OutgoingRouting resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\OutgoingRoutingWithCarriers, HTTP status code, HTTP response headers (array of strings)
     */
    public function postOutgoingRoutingCollectionWithHttpInfo($outgoing_routing = null)
    {
        $returnType = '\Delta/Voip\Model\OutgoingRoutingWithCarriers';
        $request = $this->postOutgoingRoutingCollectionRequest($outgoing_routing);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\OutgoingRoutingWithCarriers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postOutgoingRoutingCollectionAsync
     *
     * Creates a OutgoingRouting resource.
     *
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The new OutgoingRouting resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOutgoingRoutingCollectionAsync($outgoing_routing = null)
    {
        return $this->postOutgoingRoutingCollectionAsyncWithHttpInfo($outgoing_routing)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postOutgoingRoutingCollectionAsyncWithHttpInfo
     *
     * Creates a OutgoingRouting resource.
     *
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The new OutgoingRouting resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOutgoingRoutingCollectionAsyncWithHttpInfo($outgoing_routing = null)
    {
        $returnType = '\Delta/Voip\Model\OutgoingRoutingWithCarriers';
        $request = $this->postOutgoingRoutingCollectionRequest($outgoing_routing);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postOutgoingRoutingCollection'
     *
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The new OutgoingRouting resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postOutgoingRoutingCollectionRequest($outgoing_routing = null)
    {

        $resourcePath = '/outgoing_routings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($outgoing_routing)) {
            $_tempBody = $outgoing_routing;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRatingPlanCollection
     *
     * Creates a RatingPlan resource.
     *
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The new RatingPlan resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingPlan
     */
    public function postRatingPlanCollection($rating_plan = null)
    {
        list($response) = $this->postRatingPlanCollectionWithHttpInfo($rating_plan);
        return $response;
    }

    /**
     * Operation postRatingPlanCollectionWithHttpInfo
     *
     * Creates a RatingPlan resource.
     *
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The new RatingPlan resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingPlan, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRatingPlanCollectionWithHttpInfo($rating_plan = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlan';
        $request = $this->postRatingPlanCollectionRequest($rating_plan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingPlan',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postRatingPlanCollectionAsync
     *
     * Creates a RatingPlan resource.
     *
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The new RatingPlan resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRatingPlanCollectionAsync($rating_plan = null)
    {
        return $this->postRatingPlanCollectionAsyncWithHttpInfo($rating_plan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRatingPlanCollectionAsyncWithHttpInfo
     *
     * Creates a RatingPlan resource.
     *
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The new RatingPlan resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRatingPlanCollectionAsyncWithHttpInfo($rating_plan = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlan';
        $request = $this->postRatingPlanCollectionRequest($rating_plan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRatingPlanCollection'
     *
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The new RatingPlan resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postRatingPlanCollectionRequest($rating_plan = null)
    {

        $resourcePath = '/rating_plans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($rating_plan)) {
            $_tempBody = $rating_plan;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRatingPlanGroupCollection
     *
     * Creates a RatingPlanGroup resource.
     *
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The new RatingPlanGroup resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingPlanGroup
     */
    public function postRatingPlanGroupCollection($rating_plan_group = null)
    {
        list($response) = $this->postRatingPlanGroupCollectionWithHttpInfo($rating_plan_group);
        return $response;
    }

    /**
     * Operation postRatingPlanGroupCollectionWithHttpInfo
     *
     * Creates a RatingPlanGroup resource.
     *
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The new RatingPlanGroup resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingPlanGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRatingPlanGroupCollectionWithHttpInfo($rating_plan_group = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanGroup';
        $request = $this->postRatingPlanGroupCollectionRequest($rating_plan_group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingPlanGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postRatingPlanGroupCollectionAsync
     *
     * Creates a RatingPlanGroup resource.
     *
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The new RatingPlanGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRatingPlanGroupCollectionAsync($rating_plan_group = null)
    {
        return $this->postRatingPlanGroupCollectionAsyncWithHttpInfo($rating_plan_group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRatingPlanGroupCollectionAsyncWithHttpInfo
     *
     * Creates a RatingPlanGroup resource.
     *
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The new RatingPlanGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRatingPlanGroupCollectionAsyncWithHttpInfo($rating_plan_group = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanGroup';
        $request = $this->postRatingPlanGroupCollectionRequest($rating_plan_group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRatingPlanGroupCollection'
     *
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The new RatingPlanGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postRatingPlanGroupCollectionRequest($rating_plan_group = null)
    {

        $resourcePath = '/rating_plan_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($rating_plan_group)) {
            $_tempBody = $rating_plan_group;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRatingProfileCollection
     *
     * Creates a RatingProfile resource.
     *
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The new RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingProfile
     */
    public function postRatingProfileCollection($rating_profile = null, $_timezone = null)
    {
        list($response) = $this->postRatingProfileCollectionWithHttpInfo($rating_profile, $_timezone);
        return $response;
    }

    /**
     * Operation postRatingProfileCollectionWithHttpInfo
     *
     * Creates a RatingProfile resource.
     *
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The new RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRatingProfileCollectionWithHttpInfo($rating_profile = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\RatingProfile';
        $request = $this->postRatingProfileCollectionRequest($rating_profile, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postRatingProfileCollectionAsync
     *
     * Creates a RatingProfile resource.
     *
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The new RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRatingProfileCollectionAsync($rating_profile = null, $_timezone = null)
    {
        return $this->postRatingProfileCollectionAsyncWithHttpInfo($rating_profile, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRatingProfileCollectionAsyncWithHttpInfo
     *
     * Creates a RatingProfile resource.
     *
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The new RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRatingProfileCollectionAsyncWithHttpInfo($rating_profile = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\RatingProfile';
        $request = $this->postRatingProfileCollectionRequest($rating_profile, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRatingProfileCollection'
     *
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The new RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postRatingProfileCollectionRequest($rating_profile = null, $_timezone = null)
    {

        $resourcePath = '/rating_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($rating_profile)) {
            $_tempBody = $rating_profile;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postResidentialDeviceCollection
     *
     * Creates a ResidentialDevice resource.
     *
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The new ResidentialDevice resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ResidentialDevice
     */
    public function postResidentialDeviceCollection($residential_device = null)
    {
        list($response) = $this->postResidentialDeviceCollectionWithHttpInfo($residential_device);
        return $response;
    }

    /**
     * Operation postResidentialDeviceCollectionWithHttpInfo
     *
     * Creates a ResidentialDevice resource.
     *
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The new ResidentialDevice resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ResidentialDevice, HTTP status code, HTTP response headers (array of strings)
     */
    public function postResidentialDeviceCollectionWithHttpInfo($residential_device = null)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDevice';
        $request = $this->postResidentialDeviceCollectionRequest($residential_device);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ResidentialDevice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postResidentialDeviceCollectionAsync
     *
     * Creates a ResidentialDevice resource.
     *
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The new ResidentialDevice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postResidentialDeviceCollectionAsync($residential_device = null)
    {
        return $this->postResidentialDeviceCollectionAsyncWithHttpInfo($residential_device)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postResidentialDeviceCollectionAsyncWithHttpInfo
     *
     * Creates a ResidentialDevice resource.
     *
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The new ResidentialDevice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postResidentialDeviceCollectionAsyncWithHttpInfo($residential_device = null)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDevice';
        $request = $this->postResidentialDeviceCollectionRequest($residential_device);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postResidentialDeviceCollection'
     *
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The new ResidentialDevice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postResidentialDeviceCollectionRequest($residential_device = null)
    {

        $resourcePath = '/residential_devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($residential_device)) {
            $_tempBody = $residential_device;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRetailAccountCollection
     *
     * Creates a RetailAccount resource.
     *
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The new RetailAccount resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RetailAccount
     */
    public function postRetailAccountCollection($retail_account = null)
    {
        list($response) = $this->postRetailAccountCollectionWithHttpInfo($retail_account);
        return $response;
    }

    /**
     * Operation postRetailAccountCollectionWithHttpInfo
     *
     * Creates a RetailAccount resource.
     *
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The new RetailAccount resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RetailAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRetailAccountCollectionWithHttpInfo($retail_account = null)
    {
        $returnType = '\Delta/Voip\Model\RetailAccount';
        $request = $this->postRetailAccountCollectionRequest($retail_account);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RetailAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postRetailAccountCollectionAsync
     *
     * Creates a RetailAccount resource.
     *
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The new RetailAccount resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRetailAccountCollectionAsync($retail_account = null)
    {
        return $this->postRetailAccountCollectionAsyncWithHttpInfo($retail_account)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRetailAccountCollectionAsyncWithHttpInfo
     *
     * Creates a RetailAccount resource.
     *
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The new RetailAccount resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRetailAccountCollectionAsyncWithHttpInfo($retail_account = null)
    {
        $returnType = '\Delta/Voip\Model\RetailAccount';
        $request = $this->postRetailAccountCollectionRequest($retail_account);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRetailAccountCollection'
     *
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The new RetailAccount resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postRetailAccountCollectionRequest($retail_account = null)
    {

        $resourcePath = '/retail_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($retail_account)) {
            $_tempBody = $retail_account;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRoutingPatternCollection
     *
     * Creates a RoutingPattern resource.
     *
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The new RoutingPattern resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPattern
     */
    public function postRoutingPatternCollection($routing_pattern = null)
    {
        list($response) = $this->postRoutingPatternCollectionWithHttpInfo($routing_pattern);
        return $response;
    }

    /**
     * Operation postRoutingPatternCollectionWithHttpInfo
     *
     * Creates a RoutingPattern resource.
     *
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The new RoutingPattern resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPattern, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRoutingPatternCollectionWithHttpInfo($routing_pattern = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPattern';
        $request = $this->postRoutingPatternCollectionRequest($routing_pattern);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPattern',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postRoutingPatternCollectionAsync
     *
     * Creates a RoutingPattern resource.
     *
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The new RoutingPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRoutingPatternCollectionAsync($routing_pattern = null)
    {
        return $this->postRoutingPatternCollectionAsyncWithHttpInfo($routing_pattern)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRoutingPatternCollectionAsyncWithHttpInfo
     *
     * Creates a RoutingPattern resource.
     *
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The new RoutingPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRoutingPatternCollectionAsyncWithHttpInfo($routing_pattern = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPattern';
        $request = $this->postRoutingPatternCollectionRequest($routing_pattern);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRoutingPatternCollection'
     *
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The new RoutingPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postRoutingPatternCollectionRequest($routing_pattern = null)
    {

        $resourcePath = '/routing_patterns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($routing_pattern)) {
            $_tempBody = $routing_pattern;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRoutingPatternGroupCollection
     *
     * Creates a RoutingPatternGroup resource.
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The new RoutingPatternGroup resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternGroupWithPatterns
     */
    public function postRoutingPatternGroupCollection($routing_pattern_group = null)
    {
        list($response) = $this->postRoutingPatternGroupCollectionWithHttpInfo($routing_pattern_group);
        return $response;
    }

    /**
     * Operation postRoutingPatternGroupCollectionWithHttpInfo
     *
     * Creates a RoutingPatternGroup resource.
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The new RoutingPatternGroup resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternGroupWithPatterns, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRoutingPatternGroupCollectionWithHttpInfo($routing_pattern_group = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupWithPatterns';
        $request = $this->postRoutingPatternGroupCollectionRequest($routing_pattern_group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternGroupWithPatterns',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postRoutingPatternGroupCollectionAsync
     *
     * Creates a RoutingPatternGroup resource.
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The new RoutingPatternGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRoutingPatternGroupCollectionAsync($routing_pattern_group = null)
    {
        return $this->postRoutingPatternGroupCollectionAsyncWithHttpInfo($routing_pattern_group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRoutingPatternGroupCollectionAsyncWithHttpInfo
     *
     * Creates a RoutingPatternGroup resource.
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The new RoutingPatternGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRoutingPatternGroupCollectionAsyncWithHttpInfo($routing_pattern_group = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupWithPatterns';
        $request = $this->postRoutingPatternGroupCollectionRequest($routing_pattern_group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRoutingPatternGroupCollection'
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The new RoutingPatternGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postRoutingPatternGroupCollectionRequest($routing_pattern_group = null)
    {

        $resourcePath = '/routing_pattern_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($routing_pattern_group)) {
            $_tempBody = $routing_pattern_group;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRoutingPatternGroupsRelPatternCollection
     *
     * Creates a RoutingPatternGroupsRelPattern resource.
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The new RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternGroupsRelPattern
     */
    public function postRoutingPatternGroupsRelPatternCollection($routing_pattern_groups_rel_pattern = null)
    {
        list($response) = $this->postRoutingPatternGroupsRelPatternCollectionWithHttpInfo($routing_pattern_groups_rel_pattern);
        return $response;
    }

    /**
     * Operation postRoutingPatternGroupsRelPatternCollectionWithHttpInfo
     *
     * Creates a RoutingPatternGroupsRelPattern resource.
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The new RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternGroupsRelPattern, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRoutingPatternGroupsRelPatternCollectionWithHttpInfo($routing_pattern_groups_rel_pattern = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupsRelPattern';
        $request = $this->postRoutingPatternGroupsRelPatternCollectionRequest($routing_pattern_groups_rel_pattern);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternGroupsRelPattern',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postRoutingPatternGroupsRelPatternCollectionAsync
     *
     * Creates a RoutingPatternGroupsRelPattern resource.
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The new RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRoutingPatternGroupsRelPatternCollectionAsync($routing_pattern_groups_rel_pattern = null)
    {
        return $this->postRoutingPatternGroupsRelPatternCollectionAsyncWithHttpInfo($routing_pattern_groups_rel_pattern)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRoutingPatternGroupsRelPatternCollectionAsyncWithHttpInfo
     *
     * Creates a RoutingPatternGroupsRelPattern resource.
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The new RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRoutingPatternGroupsRelPatternCollectionAsyncWithHttpInfo($routing_pattern_groups_rel_pattern = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupsRelPattern';
        $request = $this->postRoutingPatternGroupsRelPatternCollectionRequest($routing_pattern_groups_rel_pattern);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRoutingPatternGroupsRelPatternCollection'
     *
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The new RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postRoutingPatternGroupsRelPatternCollectionRequest($routing_pattern_groups_rel_pattern = null)
    {

        $resourcePath = '/routing_pattern_groups_rel_patterns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($routing_pattern_groups_rel_pattern)) {
            $_tempBody = $routing_pattern_groups_rel_pattern;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRoutingTagCollection
     *
     * Creates a RoutingTag resource.
     *
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The new RoutingTag resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingTag
     */
    public function postRoutingTagCollection($routing_tag = null)
    {
        list($response) = $this->postRoutingTagCollectionWithHttpInfo($routing_tag);
        return $response;
    }

    /**
     * Operation postRoutingTagCollectionWithHttpInfo
     *
     * Creates a RoutingTag resource.
     *
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The new RoutingTag resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRoutingTagCollectionWithHttpInfo($routing_tag = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingTag';
        $request = $this->postRoutingTagCollectionRequest($routing_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postRoutingTagCollectionAsync
     *
     * Creates a RoutingTag resource.
     *
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The new RoutingTag resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRoutingTagCollectionAsync($routing_tag = null)
    {
        return $this->postRoutingTagCollectionAsyncWithHttpInfo($routing_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRoutingTagCollectionAsyncWithHttpInfo
     *
     * Creates a RoutingTag resource.
     *
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The new RoutingTag resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRoutingTagCollectionAsyncWithHttpInfo($routing_tag = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingTag';
        $request = $this->postRoutingTagCollectionRequest($routing_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRoutingTagCollection'
     *
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The new RoutingTag resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postRoutingTagCollectionRequest($routing_tag = null)
    {

        $resourcePath = '/routing_tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($routing_tag)) {
            $_tempBody = $routing_tag;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSpecialNumberCollection
     *
     * Creates a SpecialNumber resource.
     *
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The new SpecialNumber resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\SpecialNumber
     */
    public function postSpecialNumberCollection($special_number = null)
    {
        list($response) = $this->postSpecialNumberCollectionWithHttpInfo($special_number);
        return $response;
    }

    /**
     * Operation postSpecialNumberCollectionWithHttpInfo
     *
     * Creates a SpecialNumber resource.
     *
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The new SpecialNumber resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\SpecialNumber, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSpecialNumberCollectionWithHttpInfo($special_number = null)
    {
        $returnType = '\Delta/Voip\Model\SpecialNumber';
        $request = $this->postSpecialNumberCollectionRequest($special_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\SpecialNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSpecialNumberCollectionAsync
     *
     * Creates a SpecialNumber resource.
     *
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The new SpecialNumber resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpecialNumberCollectionAsync($special_number = null)
    {
        return $this->postSpecialNumberCollectionAsyncWithHttpInfo($special_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSpecialNumberCollectionAsyncWithHttpInfo
     *
     * Creates a SpecialNumber resource.
     *
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The new SpecialNumber resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpecialNumberCollectionAsyncWithHttpInfo($special_number = null)
    {
        $returnType = '\Delta/Voip\Model\SpecialNumber';
        $request = $this->postSpecialNumberCollectionRequest($special_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSpecialNumberCollection'
     *
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The new SpecialNumber resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSpecialNumberCollectionRequest($special_number = null)
    {

        $resourcePath = '/special_numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($special_number)) {
            $_tempBody = $special_number;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTransformationRuleCollection
     *
     * Creates a TransformationRule resource.
     *
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The new TransformationRule resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TransformationRule
     */
    public function postTransformationRuleCollection($transformation_rule = null)
    {
        list($response) = $this->postTransformationRuleCollectionWithHttpInfo($transformation_rule);
        return $response;
    }

    /**
     * Operation postTransformationRuleCollectionWithHttpInfo
     *
     * Creates a TransformationRule resource.
     *
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The new TransformationRule resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TransformationRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTransformationRuleCollectionWithHttpInfo($transformation_rule = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRule';
        $request = $this->postTransformationRuleCollectionRequest($transformation_rule);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TransformationRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postTransformationRuleCollectionAsync
     *
     * Creates a TransformationRule resource.
     *
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The new TransformationRule resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTransformationRuleCollectionAsync($transformation_rule = null)
    {
        return $this->postTransformationRuleCollectionAsyncWithHttpInfo($transformation_rule)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTransformationRuleCollectionAsyncWithHttpInfo
     *
     * Creates a TransformationRule resource.
     *
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The new TransformationRule resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTransformationRuleCollectionAsyncWithHttpInfo($transformation_rule = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRule';
        $request = $this->postTransformationRuleCollectionRequest($transformation_rule);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTransformationRuleCollection'
     *
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The new TransformationRule resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTransformationRuleCollectionRequest($transformation_rule = null)
    {

        $resourcePath = '/transformation_rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($transformation_rule)) {
            $_tempBody = $transformation_rule;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTransformationRuleSetCollection
     *
     * Creates a TransformationRuleSet resource.
     *
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The new TransformationRuleSet resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TransformationRuleSet
     */
    public function postTransformationRuleSetCollection($transformation_rule_set = null)
    {
        list($response) = $this->postTransformationRuleSetCollectionWithHttpInfo($transformation_rule_set);
        return $response;
    }

    /**
     * Operation postTransformationRuleSetCollectionWithHttpInfo
     *
     * Creates a TransformationRuleSet resource.
     *
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The new TransformationRuleSet resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TransformationRuleSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTransformationRuleSetCollectionWithHttpInfo($transformation_rule_set = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleSet';
        $request = $this->postTransformationRuleSetCollectionRequest($transformation_rule_set);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TransformationRuleSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postTransformationRuleSetCollectionAsync
     *
     * Creates a TransformationRuleSet resource.
     *
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The new TransformationRuleSet resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTransformationRuleSetCollectionAsync($transformation_rule_set = null)
    {
        return $this->postTransformationRuleSetCollectionAsyncWithHttpInfo($transformation_rule_set)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTransformationRuleSetCollectionAsyncWithHttpInfo
     *
     * Creates a TransformationRuleSet resource.
     *
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The new TransformationRuleSet resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTransformationRuleSetCollectionAsyncWithHttpInfo($transformation_rule_set = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleSet';
        $request = $this->postTransformationRuleSetCollectionRequest($transformation_rule_set);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTransformationRuleSetCollection'
     *
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The new TransformationRuleSet resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTransformationRuleSetCollectionRequest($transformation_rule_set = null)
    {

        $resourcePath = '/transformation_rule_sets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($transformation_rule_set)) {
            $_tempBody = $transformation_rule_set;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postUsersMassImportUsersMassImportCollection
     *
     * Creates a UsersMassImport resource.
     *
     * @param  int $company Company Id (required)
     * @param  \SplFileObject $csv *name, *lastname, email, terminal name,terminal password, terminal model, mac, extension, ddi country, ddi number, ddi provider (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\UsersMassImport
     */
    public function postUsersMassImportUsersMassImportCollection($company, $csv)
    {
        list($response) = $this->postUsersMassImportUsersMassImportCollectionWithHttpInfo($company, $csv);
        return $response;
    }

    /**
     * Operation postUsersMassImportUsersMassImportCollectionWithHttpInfo
     *
     * Creates a UsersMassImport resource.
     *
     * @param  int $company Company Id (required)
     * @param  \SplFileObject $csv *name, *lastname, email, terminal name,terminal password, terminal model, mac, extension, ddi country, ddi number, ddi provider (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\UsersMassImport, HTTP status code, HTTP response headers (array of strings)
     */
    public function postUsersMassImportUsersMassImportCollectionWithHttpInfo($company, $csv)
    {
        $returnType = '\Delta/Voip\Model\UsersMassImport';
        $request = $this->postUsersMassImportUsersMassImportCollectionRequest($company, $csv);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\UsersMassImport',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postUsersMassImportUsersMassImportCollectionAsync
     *
     * Creates a UsersMassImport resource.
     *
     * @param  int $company Company Id (required)
     * @param  \SplFileObject $csv *name, *lastname, email, terminal name,terminal password, terminal model, mac, extension, ddi country, ddi number, ddi provider (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUsersMassImportUsersMassImportCollectionAsync($company, $csv)
    {
        return $this->postUsersMassImportUsersMassImportCollectionAsyncWithHttpInfo($company, $csv)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postUsersMassImportUsersMassImportCollectionAsyncWithHttpInfo
     *
     * Creates a UsersMassImport resource.
     *
     * @param  int $company Company Id (required)
     * @param  \SplFileObject $csv *name, *lastname, email, terminal name,terminal password, terminal model, mac, extension, ddi country, ddi number, ddi provider (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUsersMassImportUsersMassImportCollectionAsyncWithHttpInfo($company, $csv)
    {
        $returnType = '\Delta/Voip\Model\UsersMassImport';
        $request = $this->postUsersMassImportUsersMassImportCollectionRequest($company, $csv);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postUsersMassImportUsersMassImportCollection'
     *
     * @param  int $company Company Id (required)
     * @param  \SplFileObject $csv *name, *lastname, email, terminal name,terminal password, terminal model, mac, extension, ddi country, ddi number, ddi provider (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postUsersMassImportUsersMassImportCollectionRequest($company, $csv)
    {
        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling postUsersMassImportUsersMassImportCollection'
            );
        }
        // verify the required parameter 'csv' is set
        if ($csv === null || (is_array($csv) && count($csv) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $csv when calling postUsersMassImportUsersMassImportCollection'
            );
        }

        $resourcePath = '/users/mass_import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($company !== null) {
            $formParams['company'] = ObjectSerializer::toFormValue($company);
        }
        // form params
        if ($csv !== null) {
            $multipart = true;
            $formParams['csv'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($csv), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postWebPortalCollection
     *
     * Creates a WebPortal resource.
     *
     * @param  string $web_portal The new WebPortal resource (optional)
     * @param  \SplFileObject $logo logo (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\WebPortal
     */
    public function postWebPortalCollection($web_portal = null, $logo = null)
    {
        list($response) = $this->postWebPortalCollectionWithHttpInfo($web_portal, $logo);
        return $response;
    }

    /**
     * Operation postWebPortalCollectionWithHttpInfo
     *
     * Creates a WebPortal resource.
     *
     * @param  string $web_portal The new WebPortal resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\WebPortal, HTTP status code, HTTP response headers (array of strings)
     */
    public function postWebPortalCollectionWithHttpInfo($web_portal = null, $logo = null)
    {
        $returnType = '\Delta/Voip\Model\WebPortal';
        $request = $this->postWebPortalCollectionRequest($web_portal, $logo);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\WebPortal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postWebPortalCollectionAsync
     *
     * Creates a WebPortal resource.
     *
     * @param  string $web_portal The new WebPortal resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postWebPortalCollectionAsync($web_portal = null, $logo = null)
    {
        return $this->postWebPortalCollectionAsyncWithHttpInfo($web_portal, $logo)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postWebPortalCollectionAsyncWithHttpInfo
     *
     * Creates a WebPortal resource.
     *
     * @param  string $web_portal The new WebPortal resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postWebPortalCollectionAsyncWithHttpInfo($web_portal = null, $logo = null)
    {
        $returnType = '\Delta/Voip\Model\WebPortal';
        $request = $this->postWebPortalCollectionRequest($web_portal, $logo);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postWebPortalCollection'
     *
     * @param  string $web_portal The new WebPortal resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postWebPortalCollectionRequest($web_portal = null, $logo = null)
    {

        $resourcePath = '/web_portals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($web_portal !== null) {
            $formParams['webPortal'] = ObjectSerializer::toFormValue($web_portal);
        }
        // form params
        if ($logo !== null) {
            $multipart = true;
            $formParams['Logo'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($logo), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['multipart/form-data', 'application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAdministratorItem
     *
     * Replaces the Administrator resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\Administrator $administrator The updated Administrator resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Administrator
     */
    public function putAdministratorItem($id, $administrator = null)
    {
        list($response) = $this->putAdministratorItemWithHttpInfo($id, $administrator);
        return $response;
    }

    /**
     * Operation putAdministratorItemWithHttpInfo
     *
     * Replaces the Administrator resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Administrator $administrator The updated Administrator resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Administrator, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAdministratorItemWithHttpInfo($id, $administrator = null)
    {
        $returnType = '\Delta/Voip\Model\Administrator';
        $request = $this->putAdministratorItemRequest($id, $administrator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Administrator',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAdministratorItemAsync
     *
     * Replaces the Administrator resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Administrator $administrator The updated Administrator resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAdministratorItemAsync($id, $administrator = null)
    {
        return $this->putAdministratorItemAsyncWithHttpInfo($id, $administrator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAdministratorItemAsyncWithHttpInfo
     *
     * Replaces the Administrator resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Administrator $administrator The updated Administrator resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAdministratorItemAsyncWithHttpInfo($id, $administrator = null)
    {
        $returnType = '\Delta/Voip\Model\Administrator';
        $request = $this->putAdministratorItemRequest($id, $administrator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAdministratorItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Administrator $administrator The updated Administrator resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAdministratorItemRequest($id, $administrator = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putAdministratorItem'
            );
        }

        $resourcePath = '/administrators/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($administrator)) {
            $_tempBody = $administrator;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAdministratorRelPublicEntityItem
     *
     * Replaces the AdministratorRelPublicEntity resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\AdministratorRelPublicEntity $administrator_rel_public_entity The updated AdministratorRelPublicEntity resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\AdministratorRelPublicEntity
     */
    public function putAdministratorRelPublicEntityItem($id, $administrator_rel_public_entity = null)
    {
        list($response) = $this->putAdministratorRelPublicEntityItemWithHttpInfo($id, $administrator_rel_public_entity);
        return $response;
    }

    /**
     * Operation putAdministratorRelPublicEntityItemWithHttpInfo
     *
     * Replaces the AdministratorRelPublicEntity resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\AdministratorRelPublicEntity $administrator_rel_public_entity The updated AdministratorRelPublicEntity resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\AdministratorRelPublicEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAdministratorRelPublicEntityItemWithHttpInfo($id, $administrator_rel_public_entity = null)
    {
        $returnType = '\Delta/Voip\Model\AdministratorRelPublicEntity';
        $request = $this->putAdministratorRelPublicEntityItemRequest($id, $administrator_rel_public_entity);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\AdministratorRelPublicEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAdministratorRelPublicEntityItemAsync
     *
     * Replaces the AdministratorRelPublicEntity resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\AdministratorRelPublicEntity $administrator_rel_public_entity The updated AdministratorRelPublicEntity resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAdministratorRelPublicEntityItemAsync($id, $administrator_rel_public_entity = null)
    {
        return $this->putAdministratorRelPublicEntityItemAsyncWithHttpInfo($id, $administrator_rel_public_entity)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAdministratorRelPublicEntityItemAsyncWithHttpInfo
     *
     * Replaces the AdministratorRelPublicEntity resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\AdministratorRelPublicEntity $administrator_rel_public_entity The updated AdministratorRelPublicEntity resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAdministratorRelPublicEntityItemAsyncWithHttpInfo($id, $administrator_rel_public_entity = null)
    {
        $returnType = '\Delta/Voip\Model\AdministratorRelPublicEntity';
        $request = $this->putAdministratorRelPublicEntityItemRequest($id, $administrator_rel_public_entity);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAdministratorRelPublicEntityItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\AdministratorRelPublicEntity $administrator_rel_public_entity The updated AdministratorRelPublicEntity resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAdministratorRelPublicEntityItemRequest($id, $administrator_rel_public_entity = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putAdministratorRelPublicEntityItem'
            );
        }

        $resourcePath = '/administrator_rel_public_entities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($administrator_rel_public_entity)) {
            $_tempBody = $administrator_rel_public_entity;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putBalanceNotificationItem
     *
     * Replaces the BalanceNotification resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The updated BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BalanceNotification
     */
    public function putBalanceNotificationItem($id, $balance_notification = null, $_timezone = null)
    {
        list($response) = $this->putBalanceNotificationItemWithHttpInfo($id, $balance_notification, $_timezone);
        return $response;
    }

    /**
     * Operation putBalanceNotificationItemWithHttpInfo
     *
     * Replaces the BalanceNotification resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The updated BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BalanceNotification, HTTP status code, HTTP response headers (array of strings)
     */
    public function putBalanceNotificationItemWithHttpInfo($id, $balance_notification = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BalanceNotification';
        $request = $this->putBalanceNotificationItemRequest($id, $balance_notification, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BalanceNotification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putBalanceNotificationItemAsync
     *
     * Replaces the BalanceNotification resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The updated BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBalanceNotificationItemAsync($id, $balance_notification = null, $_timezone = null)
    {
        return $this->putBalanceNotificationItemAsyncWithHttpInfo($id, $balance_notification, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putBalanceNotificationItemAsyncWithHttpInfo
     *
     * Replaces the BalanceNotification resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The updated BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBalanceNotificationItemAsyncWithHttpInfo($id, $balance_notification = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BalanceNotification';
        $request = $this->putBalanceNotificationItemRequest($id, $balance_notification, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putBalanceNotificationItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\BalanceNotification $balance_notification The updated BalanceNotification resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putBalanceNotificationItemRequest($id, $balance_notification = null, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putBalanceNotificationItem'
            );
        }

        $resourcePath = '/balance_notifications/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($balance_notification)) {
            $_tempBody = $balance_notification;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putBillableCallRateByCallidBillableCallItem
     *
     * Replaces the BillableCall resource.
     *
     * @param  string $callid callid (required)
     * @param  \Delta/Voip\Model\BillableCallRating $rating The rating values (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BillableCall
     */
    public function putBillableCallRateByCallidBillableCallItem($callid, $rating, $_timezone = null)
    {
        list($response) = $this->putBillableCallRateByCallidBillableCallItemWithHttpInfo($callid, $rating, $_timezone);
        return $response;
    }

    /**
     * Operation putBillableCallRateByCallidBillableCallItemWithHttpInfo
     *
     * Replaces the BillableCall resource.
     *
     * @param  string $callid callid (required)
     * @param  \Delta/Voip\Model\BillableCallRating $rating The rating values (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BillableCall, HTTP status code, HTTP response headers (array of strings)
     */
    public function putBillableCallRateByCallidBillableCallItemWithHttpInfo($callid, $rating, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BillableCall';
        $request = $this->putBillableCallRateByCallidBillableCallItemRequest($callid, $rating, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BillableCall',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putBillableCallRateByCallidBillableCallItemAsync
     *
     * Replaces the BillableCall resource.
     *
     * @param  string $callid callid (required)
     * @param  \Delta/Voip\Model\BillableCallRating $rating The rating values (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBillableCallRateByCallidBillableCallItemAsync($callid, $rating, $_timezone = null)
    {
        return $this->putBillableCallRateByCallidBillableCallItemAsyncWithHttpInfo($callid, $rating, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putBillableCallRateByCallidBillableCallItemAsyncWithHttpInfo
     *
     * Replaces the BillableCall resource.
     *
     * @param  string $callid callid (required)
     * @param  \Delta/Voip\Model\BillableCallRating $rating The rating values (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBillableCallRateByCallidBillableCallItemAsyncWithHttpInfo($callid, $rating, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\BillableCall';
        $request = $this->putBillableCallRateByCallidBillableCallItemRequest($callid, $rating, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putBillableCallRateByCallidBillableCallItem'
     *
     * @param  string $callid callid (required)
     * @param  \Delta/Voip\Model\BillableCallRating $rating The rating values (required)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putBillableCallRateByCallidBillableCallItemRequest($callid, $rating, $_timezone = null)
    {
        // verify the required parameter 'callid' is set
        if ($callid === null || (is_array($callid) && count($callid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $callid when calling putBillableCallRateByCallidBillableCallItem'
            );
        }
        // verify the required parameter 'rating' is set
        if ($rating === null || (is_array($rating) && count($rating) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rating when calling putBillableCallRateByCallidBillableCallItem'
            );
        }

        $resourcePath = '/billable_calls/{callid}/rate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($callid !== null) {
            $resourcePath = str_replace(
                '{' . 'callid' . '}',
                ObjectSerializer::toPathValue($callid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($rating)) {
            $_tempBody = $rating;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putBrandItem
     *
     * Replaces the Brand resource.
     *
     * @param  string $id id (required)
     * @param  string $brand The updated Brand resource (optional)
     * @param  \SplFileObject $logo logo (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Brand
     */
    public function putBrandItem($id, $brand = null, $logo = null)
    {
        list($response) = $this->putBrandItemWithHttpInfo($id, $brand, $logo);
        return $response;
    }

    /**
     * Operation putBrandItemWithHttpInfo
     *
     * Replaces the Brand resource.
     *
     * @param  string $id (required)
     * @param  string $brand The updated Brand resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Brand, HTTP status code, HTTP response headers (array of strings)
     */
    public function putBrandItemWithHttpInfo($id, $brand = null, $logo = null)
    {
        $returnType = '\Delta/Voip\Model\Brand';
        $request = $this->putBrandItemRequest($id, $brand, $logo);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Brand',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putBrandItemAsync
     *
     * Replaces the Brand resource.
     *
     * @param  string $id (required)
     * @param  string $brand The updated Brand resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBrandItemAsync($id, $brand = null, $logo = null)
    {
        return $this->putBrandItemAsyncWithHttpInfo($id, $brand, $logo)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putBrandItemAsyncWithHttpInfo
     *
     * Replaces the Brand resource.
     *
     * @param  string $id (required)
     * @param  string $brand The updated Brand resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBrandItemAsyncWithHttpInfo($id, $brand = null, $logo = null)
    {
        $returnType = '\Delta/Voip\Model\Brand';
        $request = $this->putBrandItemRequest($id, $brand, $logo);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putBrandItem'
     *
     * @param  string $id (required)
     * @param  string $brand The updated Brand resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putBrandItemRequest($id, $brand = null, $logo = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putBrandItem'
            );
        }

        $resourcePath = '/brands/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($brand !== null) {
            $formParams['brand'] = ObjectSerializer::toFormValue($brand);
        }
        // form params
        if ($logo !== null) {
            $multipart = true;
            $formParams['Logo'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($logo), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['multipart/form-data', 'application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putBrandServiceItem
     *
     * Replaces the BrandService resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\BrandService $brand_service The updated BrandService resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\BrandService
     */
    public function putBrandServiceItem($id, $brand_service = null)
    {
        list($response) = $this->putBrandServiceItemWithHttpInfo($id, $brand_service);
        return $response;
    }

    /**
     * Operation putBrandServiceItemWithHttpInfo
     *
     * Replaces the BrandService resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\BrandService $brand_service The updated BrandService resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\BrandService, HTTP status code, HTTP response headers (array of strings)
     */
    public function putBrandServiceItemWithHttpInfo($id, $brand_service = null)
    {
        $returnType = '\Delta/Voip\Model\BrandService';
        $request = $this->putBrandServiceItemRequest($id, $brand_service);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\BrandService',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putBrandServiceItemAsync
     *
     * Replaces the BrandService resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\BrandService $brand_service The updated BrandService resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBrandServiceItemAsync($id, $brand_service = null)
    {
        return $this->putBrandServiceItemAsyncWithHttpInfo($id, $brand_service)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putBrandServiceItemAsyncWithHttpInfo
     *
     * Replaces the BrandService resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\BrandService $brand_service The updated BrandService resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBrandServiceItemAsyncWithHttpInfo($id, $brand_service = null)
    {
        $returnType = '\Delta/Voip\Model\BrandService';
        $request = $this->putBrandServiceItemRequest($id, $brand_service);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putBrandServiceItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\BrandService $brand_service The updated BrandService resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putBrandServiceItemRequest($id, $brand_service = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putBrandServiceItem'
            );
        }

        $resourcePath = '/brand_services/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($brand_service)) {
            $_tempBody = $brand_service;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCallCsvSchedulerItem
     *
     * Replaces the CallCsvScheduler resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The updated CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CallCsvScheduler
     */
    public function putCallCsvSchedulerItem($id, $call_csv_scheduler = null, $_timezone = null)
    {
        list($response) = $this->putCallCsvSchedulerItemWithHttpInfo($id, $call_csv_scheduler, $_timezone);
        return $response;
    }

    /**
     * Operation putCallCsvSchedulerItemWithHttpInfo
     *
     * Replaces the CallCsvScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The updated CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CallCsvScheduler, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCallCsvSchedulerItemWithHttpInfo($id, $call_csv_scheduler = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvScheduler';
        $request = $this->putCallCsvSchedulerItemRequest($id, $call_csv_scheduler, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CallCsvScheduler',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCallCsvSchedulerItemAsync
     *
     * Replaces the CallCsvScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The updated CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCallCsvSchedulerItemAsync($id, $call_csv_scheduler = null, $_timezone = null)
    {
        return $this->putCallCsvSchedulerItemAsyncWithHttpInfo($id, $call_csv_scheduler, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCallCsvSchedulerItemAsyncWithHttpInfo
     *
     * Replaces the CallCsvScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The updated CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCallCsvSchedulerItemAsyncWithHttpInfo($id, $call_csv_scheduler = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\CallCsvScheduler';
        $request = $this->putCallCsvSchedulerItemRequest($id, $call_csv_scheduler, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCallCsvSchedulerItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\CallCsvScheduler $call_csv_scheduler The updated CallCsvScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCallCsvSchedulerItemRequest($id, $call_csv_scheduler = null, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putCallCsvSchedulerItem'
            );
        }

        $resourcePath = '/call_csv_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($call_csv_scheduler)) {
            $_tempBody = $call_csv_scheduler;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCarrierItem
     *
     * Replaces the Carrier resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\Carrier $carrier The updated Carrier resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Carrier
     */
    public function putCarrierItem($id, $carrier = null)
    {
        list($response) = $this->putCarrierItemWithHttpInfo($id, $carrier);
        return $response;
    }

    /**
     * Operation putCarrierItemWithHttpInfo
     *
     * Replaces the Carrier resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Carrier $carrier The updated Carrier resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Carrier, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCarrierItemWithHttpInfo($id, $carrier = null)
    {
        $returnType = '\Delta/Voip\Model\Carrier';
        $request = $this->putCarrierItemRequest($id, $carrier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Carrier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCarrierItemAsync
     *
     * Replaces the Carrier resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Carrier $carrier The updated Carrier resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCarrierItemAsync($id, $carrier = null)
    {
        return $this->putCarrierItemAsyncWithHttpInfo($id, $carrier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCarrierItemAsyncWithHttpInfo
     *
     * Replaces the Carrier resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Carrier $carrier The updated Carrier resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCarrierItemAsyncWithHttpInfo($id, $carrier = null)
    {
        $returnType = '\Delta/Voip\Model\Carrier';
        $request = $this->putCarrierItemRequest($id, $carrier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCarrierItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Carrier $carrier The updated Carrier resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCarrierItemRequest($id, $carrier = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putCarrierItem'
            );
        }

        $resourcePath = '/carriers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($carrier)) {
            $_tempBody = $carrier;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCarrierServerItem
     *
     * Replaces the CarrierServer resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The updated CarrierServer resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CarrierServer
     */
    public function putCarrierServerItem($id, $carrier_server = null)
    {
        list($response) = $this->putCarrierServerItemWithHttpInfo($id, $carrier_server);
        return $response;
    }

    /**
     * Operation putCarrierServerItemWithHttpInfo
     *
     * Replaces the CarrierServer resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The updated CarrierServer resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CarrierServer, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCarrierServerItemWithHttpInfo($id, $carrier_server = null)
    {
        $returnType = '\Delta/Voip\Model\CarrierServer';
        $request = $this->putCarrierServerItemRequest($id, $carrier_server);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CarrierServer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCarrierServerItemAsync
     *
     * Replaces the CarrierServer resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The updated CarrierServer resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCarrierServerItemAsync($id, $carrier_server = null)
    {
        return $this->putCarrierServerItemAsyncWithHttpInfo($id, $carrier_server)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCarrierServerItemAsyncWithHttpInfo
     *
     * Replaces the CarrierServer resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The updated CarrierServer resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCarrierServerItemAsyncWithHttpInfo($id, $carrier_server = null)
    {
        $returnType = '\Delta/Voip\Model\CarrierServer';
        $request = $this->putCarrierServerItemRequest($id, $carrier_server);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCarrierServerItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\CarrierServer $carrier_server The updated CarrierServer resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCarrierServerItemRequest($id, $carrier_server = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putCarrierServerItem'
            );
        }

        $resourcePath = '/carrier_servers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($carrier_server)) {
            $_tempBody = $carrier_server;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCompanyItem
     *
     * Replaces the Company resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\Company $company The updated Company resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\CompanyWithFeatures
     */
    public function putCompanyItem($id, $company = null)
    {
        list($response) = $this->putCompanyItemWithHttpInfo($id, $company);
        return $response;
    }

    /**
     * Operation putCompanyItemWithHttpInfo
     *
     * Replaces the Company resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Company $company The updated Company resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\CompanyWithFeatures, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCompanyItemWithHttpInfo($id, $company = null)
    {
        $returnType = '\Delta/Voip\Model\CompanyWithFeatures';
        $request = $this->putCompanyItemRequest($id, $company);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\CompanyWithFeatures',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCompanyItemAsync
     *
     * Replaces the Company resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Company $company The updated Company resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCompanyItemAsync($id, $company = null)
    {
        return $this->putCompanyItemAsyncWithHttpInfo($id, $company)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCompanyItemAsyncWithHttpInfo
     *
     * Replaces the Company resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Company $company The updated Company resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCompanyItemAsyncWithHttpInfo($id, $company = null)
    {
        $returnType = '\Delta/Voip\Model\CompanyWithFeatures';
        $request = $this->putCompanyItemRequest($id, $company);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCompanyItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Company $company The updated Company resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCompanyItemRequest($id, $company = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putCompanyItem'
            );
        }

        $resourcePath = '/companies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($company)) {
            $_tempBody = $company;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDdiItem
     *
     * Replaces the Ddi resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\Ddi $ddi The updated Ddi resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Ddi
     */
    public function putDdiItem($id, $ddi = null)
    {
        list($response) = $this->putDdiItemWithHttpInfo($id, $ddi);
        return $response;
    }

    /**
     * Operation putDdiItemWithHttpInfo
     *
     * Replaces the Ddi resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Ddi $ddi The updated Ddi resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Ddi, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDdiItemWithHttpInfo($id, $ddi = null)
    {
        $returnType = '\Delta/Voip\Model\Ddi';
        $request = $this->putDdiItemRequest($id, $ddi);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Ddi',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDdiItemAsync
     *
     * Replaces the Ddi resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Ddi $ddi The updated Ddi resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDdiItemAsync($id, $ddi = null)
    {
        return $this->putDdiItemAsyncWithHttpInfo($id, $ddi)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDdiItemAsyncWithHttpInfo
     *
     * Replaces the Ddi resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Ddi $ddi The updated Ddi resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDdiItemAsyncWithHttpInfo($id, $ddi = null)
    {
        $returnType = '\Delta/Voip\Model\Ddi';
        $request = $this->putDdiItemRequest($id, $ddi);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDdiItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Ddi $ddi The updated Ddi resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDdiItemRequest($id, $ddi = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putDdiItem'
            );
        }

        $resourcePath = '/ddis/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($ddi)) {
            $_tempBody = $ddi;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDdiProviderAddressItem
     *
     * Replaces the DdiProviderAddress resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The updated DdiProviderAddress resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderAddress
     */
    public function putDdiProviderAddressItem($id, $ddi_provider_address = null)
    {
        list($response) = $this->putDdiProviderAddressItemWithHttpInfo($id, $ddi_provider_address);
        return $response;
    }

    /**
     * Operation putDdiProviderAddressItemWithHttpInfo
     *
     * Replaces the DdiProviderAddress resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The updated DdiProviderAddress resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDdiProviderAddressItemWithHttpInfo($id, $ddi_provider_address = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderAddress';
        $request = $this->putDdiProviderAddressItemRequest($id, $ddi_provider_address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDdiProviderAddressItemAsync
     *
     * Replaces the DdiProviderAddress resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The updated DdiProviderAddress resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDdiProviderAddressItemAsync($id, $ddi_provider_address = null)
    {
        return $this->putDdiProviderAddressItemAsyncWithHttpInfo($id, $ddi_provider_address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDdiProviderAddressItemAsyncWithHttpInfo
     *
     * Replaces the DdiProviderAddress resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The updated DdiProviderAddress resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDdiProviderAddressItemAsyncWithHttpInfo($id, $ddi_provider_address = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderAddress';
        $request = $this->putDdiProviderAddressItemRequest($id, $ddi_provider_address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDdiProviderAddressItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProviderAddress $ddi_provider_address The updated DdiProviderAddress resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDdiProviderAddressItemRequest($id, $ddi_provider_address = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putDdiProviderAddressItem'
            );
        }

        $resourcePath = '/ddi_provider_addresses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($ddi_provider_address)) {
            $_tempBody = $ddi_provider_address;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDdiProviderItem
     *
     * Replaces the DdiProvider resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The updated DdiProvider resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProvider
     */
    public function putDdiProviderItem($id, $ddi_provider = null)
    {
        list($response) = $this->putDdiProviderItemWithHttpInfo($id, $ddi_provider);
        return $response;
    }

    /**
     * Operation putDdiProviderItemWithHttpInfo
     *
     * Replaces the DdiProvider resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The updated DdiProvider resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProvider, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDdiProviderItemWithHttpInfo($id, $ddi_provider = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProvider';
        $request = $this->putDdiProviderItemRequest($id, $ddi_provider);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProvider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDdiProviderItemAsync
     *
     * Replaces the DdiProvider resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The updated DdiProvider resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDdiProviderItemAsync($id, $ddi_provider = null)
    {
        return $this->putDdiProviderItemAsyncWithHttpInfo($id, $ddi_provider)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDdiProviderItemAsyncWithHttpInfo
     *
     * Replaces the DdiProvider resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The updated DdiProvider resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDdiProviderItemAsyncWithHttpInfo($id, $ddi_provider = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProvider';
        $request = $this->putDdiProviderItemRequest($id, $ddi_provider);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDdiProviderItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProvider $ddi_provider The updated DdiProvider resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDdiProviderItemRequest($id, $ddi_provider = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putDdiProviderItem'
            );
        }

        $resourcePath = '/ddi_providers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($ddi_provider)) {
            $_tempBody = $ddi_provider;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDdiProviderRegistrationItem
     *
     * Replaces the DdiProviderRegistration resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The updated DdiProviderRegistration resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DdiProviderRegistration
     */
    public function putDdiProviderRegistrationItem($id, $ddi_provider_registration = null)
    {
        list($response) = $this->putDdiProviderRegistrationItemWithHttpInfo($id, $ddi_provider_registration);
        return $response;
    }

    /**
     * Operation putDdiProviderRegistrationItemWithHttpInfo
     *
     * Replaces the DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The updated DdiProviderRegistration resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DdiProviderRegistration, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDdiProviderRegistrationItemWithHttpInfo($id, $ddi_provider_registration = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderRegistration';
        $request = $this->putDdiProviderRegistrationItemRequest($id, $ddi_provider_registration);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DdiProviderRegistration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDdiProviderRegistrationItemAsync
     *
     * Replaces the DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The updated DdiProviderRegistration resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDdiProviderRegistrationItemAsync($id, $ddi_provider_registration = null)
    {
        return $this->putDdiProviderRegistrationItemAsyncWithHttpInfo($id, $ddi_provider_registration)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDdiProviderRegistrationItemAsyncWithHttpInfo
     *
     * Replaces the DdiProviderRegistration resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The updated DdiProviderRegistration resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDdiProviderRegistrationItemAsyncWithHttpInfo($id, $ddi_provider_registration = null)
    {
        $returnType = '\Delta/Voip\Model\DdiProviderRegistration';
        $request = $this->putDdiProviderRegistrationItemRequest($id, $ddi_provider_registration);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDdiProviderRegistrationItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DdiProviderRegistration $ddi_provider_registration The updated DdiProviderRegistration resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDdiProviderRegistrationItemRequest($id, $ddi_provider_registration = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putDdiProviderRegistrationItem'
            );
        }

        $resourcePath = '/ddi_provider_registrations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($ddi_provider_registration)) {
            $_tempBody = $ddi_provider_registration;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDestinationItem
     *
     * Replaces the Destination resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\Destination $destination The updated Destination resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Destination
     */
    public function putDestinationItem($id, $destination = null)
    {
        list($response) = $this->putDestinationItemWithHttpInfo($id, $destination);
        return $response;
    }

    /**
     * Operation putDestinationItemWithHttpInfo
     *
     * Replaces the Destination resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Destination $destination The updated Destination resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Destination, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDestinationItemWithHttpInfo($id, $destination = null)
    {
        $returnType = '\Delta/Voip\Model\Destination';
        $request = $this->putDestinationItemRequest($id, $destination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Destination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDestinationItemAsync
     *
     * Replaces the Destination resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Destination $destination The updated Destination resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDestinationItemAsync($id, $destination = null)
    {
        return $this->putDestinationItemAsyncWithHttpInfo($id, $destination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDestinationItemAsyncWithHttpInfo
     *
     * Replaces the Destination resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Destination $destination The updated Destination resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDestinationItemAsyncWithHttpInfo($id, $destination = null)
    {
        $returnType = '\Delta/Voip\Model\Destination';
        $request = $this->putDestinationItemRequest($id, $destination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDestinationItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Destination $destination The updated Destination resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDestinationItemRequest($id, $destination = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putDestinationItem'
            );
        }

        $resourcePath = '/destinations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($destination)) {
            $_tempBody = $destination;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDestinationRateGroupItem
     *
     * Replaces the DestinationRateGroup resource.
     *
     * @param  string $id id (required)
     * @param  string $destination_rate_group The updated DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file file (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationRateGroup
     */
    public function putDestinationRateGroupItem($id, $destination_rate_group = null, $file = null)
    {
        list($response) = $this->putDestinationRateGroupItemWithHttpInfo($id, $destination_rate_group, $file);
        return $response;
    }

    /**
     * Operation putDestinationRateGroupItemWithHttpInfo
     *
     * Replaces the DestinationRateGroup resource.
     *
     * @param  string $id (required)
     * @param  string $destination_rate_group The updated DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationRateGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDestinationRateGroupItemWithHttpInfo($id, $destination_rate_group = null, $file = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateGroup';
        $request = $this->putDestinationRateGroupItemRequest($id, $destination_rate_group, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationRateGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDestinationRateGroupItemAsync
     *
     * Replaces the DestinationRateGroup resource.
     *
     * @param  string $id (required)
     * @param  string $destination_rate_group The updated DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDestinationRateGroupItemAsync($id, $destination_rate_group = null, $file = null)
    {
        return $this->putDestinationRateGroupItemAsyncWithHttpInfo($id, $destination_rate_group, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDestinationRateGroupItemAsyncWithHttpInfo
     *
     * Replaces the DestinationRateGroup resource.
     *
     * @param  string $id (required)
     * @param  string $destination_rate_group The updated DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDestinationRateGroupItemAsyncWithHttpInfo($id, $destination_rate_group = null, $file = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRateGroup';
        $request = $this->putDestinationRateGroupItemRequest($id, $destination_rate_group, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDestinationRateGroupItem'
     *
     * @param  string $id (required)
     * @param  string $destination_rate_group The updated DestinationRateGroup resource (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDestinationRateGroupItemRequest($id, $destination_rate_group = null, $file = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putDestinationRateGroupItem'
            );
        }

        $resourcePath = '/destination_rate_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($destination_rate_group !== null) {
            $formParams['destinationRateGroup'] = ObjectSerializer::toFormValue($destination_rate_group);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['multipart/form-data', 'application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDestinationRateItem
     *
     * Replaces the DestinationRate resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The updated DestinationRate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\DestinationRate
     */
    public function putDestinationRateItem($id, $destination_rate = null)
    {
        list($response) = $this->putDestinationRateItemWithHttpInfo($id, $destination_rate);
        return $response;
    }

    /**
     * Operation putDestinationRateItemWithHttpInfo
     *
     * Replaces the DestinationRate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The updated DestinationRate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\DestinationRate, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDestinationRateItemWithHttpInfo($id, $destination_rate = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRate';
        $request = $this->putDestinationRateItemRequest($id, $destination_rate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\DestinationRate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDestinationRateItemAsync
     *
     * Replaces the DestinationRate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The updated DestinationRate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDestinationRateItemAsync($id, $destination_rate = null)
    {
        return $this->putDestinationRateItemAsyncWithHttpInfo($id, $destination_rate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDestinationRateItemAsyncWithHttpInfo
     *
     * Replaces the DestinationRate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The updated DestinationRate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDestinationRateItemAsyncWithHttpInfo($id, $destination_rate = null)
    {
        $returnType = '\Delta/Voip\Model\DestinationRate';
        $request = $this->putDestinationRateItemRequest($id, $destination_rate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDestinationRateItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\DestinationRate $destination_rate The updated DestinationRate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDestinationRateItemRequest($id, $destination_rate = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putDestinationRateItem'
            );
        }

        $resourcePath = '/destination_rates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($destination_rate)) {
            $_tempBody = $destination_rate;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFixedCostItem
     *
     * Replaces the FixedCost resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The updated FixedCost resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCost
     */
    public function putFixedCostItem($id, $fixed_cost = null)
    {
        list($response) = $this->putFixedCostItemWithHttpInfo($id, $fixed_cost);
        return $response;
    }

    /**
     * Operation putFixedCostItemWithHttpInfo
     *
     * Replaces the FixedCost resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The updated FixedCost resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCost, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFixedCostItemWithHttpInfo($id, $fixed_cost = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCost';
        $request = $this->putFixedCostItemRequest($id, $fixed_cost);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCost',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFixedCostItemAsync
     *
     * Replaces the FixedCost resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The updated FixedCost resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFixedCostItemAsync($id, $fixed_cost = null)
    {
        return $this->putFixedCostItemAsyncWithHttpInfo($id, $fixed_cost)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFixedCostItemAsyncWithHttpInfo
     *
     * Replaces the FixedCost resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The updated FixedCost resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFixedCostItemAsyncWithHttpInfo($id, $fixed_cost = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCost';
        $request = $this->putFixedCostItemRequest($id, $fixed_cost);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFixedCostItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCost $fixed_cost The updated FixedCost resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFixedCostItemRequest($id, $fixed_cost = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putFixedCostItem'
            );
        }

        $resourcePath = '/fixed_costs/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($fixed_cost)) {
            $_tempBody = $fixed_cost;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFixedCostsRelInvoiceItem
     *
     * Replaces the FixedCostsRelInvoice resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The updated FixedCostsRelInvoice resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostsRelInvoice
     */
    public function putFixedCostsRelInvoiceItem($id, $fixed_costs_rel_invoice = null)
    {
        list($response) = $this->putFixedCostsRelInvoiceItemWithHttpInfo($id, $fixed_costs_rel_invoice);
        return $response;
    }

    /**
     * Operation putFixedCostsRelInvoiceItemWithHttpInfo
     *
     * Replaces the FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The updated FixedCostsRelInvoice resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostsRelInvoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFixedCostsRelInvoiceItemWithHttpInfo($id, $fixed_costs_rel_invoice = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoice';
        $request = $this->putFixedCostsRelInvoiceItemRequest($id, $fixed_costs_rel_invoice);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostsRelInvoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFixedCostsRelInvoiceItemAsync
     *
     * Replaces the FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The updated FixedCostsRelInvoice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFixedCostsRelInvoiceItemAsync($id, $fixed_costs_rel_invoice = null)
    {
        return $this->putFixedCostsRelInvoiceItemAsyncWithHttpInfo($id, $fixed_costs_rel_invoice)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFixedCostsRelInvoiceItemAsyncWithHttpInfo
     *
     * Replaces the FixedCostsRelInvoice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The updated FixedCostsRelInvoice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFixedCostsRelInvoiceItemAsyncWithHttpInfo($id, $fixed_costs_rel_invoice = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoice';
        $request = $this->putFixedCostsRelInvoiceItemRequest($id, $fixed_costs_rel_invoice);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFixedCostsRelInvoiceItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoice $fixed_costs_rel_invoice The updated FixedCostsRelInvoice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFixedCostsRelInvoiceItemRequest($id, $fixed_costs_rel_invoice = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putFixedCostsRelInvoiceItem'
            );
        }

        $resourcePath = '/fixed_costs_rel_invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($fixed_costs_rel_invoice)) {
            $_tempBody = $fixed_costs_rel_invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFixedCostsRelInvoiceSchedulerItem
     *
     * Replaces the FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The updated FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\FixedCostsRelInvoiceScheduler
     */
    public function putFixedCostsRelInvoiceSchedulerItem($id, $fixed_costs_rel_invoice_scheduler = null)
    {
        list($response) = $this->putFixedCostsRelInvoiceSchedulerItemWithHttpInfo($id, $fixed_costs_rel_invoice_scheduler);
        return $response;
    }

    /**
     * Operation putFixedCostsRelInvoiceSchedulerItemWithHttpInfo
     *
     * Replaces the FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The updated FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\FixedCostsRelInvoiceScheduler, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFixedCostsRelInvoiceSchedulerItemWithHttpInfo($id, $fixed_costs_rel_invoice_scheduler = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceScheduler';
        $request = $this->putFixedCostsRelInvoiceSchedulerItemRequest($id, $fixed_costs_rel_invoice_scheduler);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\FixedCostsRelInvoiceScheduler',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFixedCostsRelInvoiceSchedulerItemAsync
     *
     * Replaces the FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The updated FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFixedCostsRelInvoiceSchedulerItemAsync($id, $fixed_costs_rel_invoice_scheduler = null)
    {
        return $this->putFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo($id, $fixed_costs_rel_invoice_scheduler)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo
     *
     * Replaces the FixedCostsRelInvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The updated FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFixedCostsRelInvoiceSchedulerItemAsyncWithHttpInfo($id, $fixed_costs_rel_invoice_scheduler = null)
    {
        $returnType = '\Delta/Voip\Model\FixedCostsRelInvoiceScheduler';
        $request = $this->putFixedCostsRelInvoiceSchedulerItemRequest($id, $fixed_costs_rel_invoice_scheduler);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFixedCostsRelInvoiceSchedulerItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\FixedCostsRelInvoiceScheduler $fixed_costs_rel_invoice_scheduler The updated FixedCostsRelInvoiceScheduler resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFixedCostsRelInvoiceSchedulerItemRequest($id, $fixed_costs_rel_invoice_scheduler = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putFixedCostsRelInvoiceSchedulerItem'
            );
        }

        $resourcePath = '/fixed_costs_rel_invoice_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($fixed_costs_rel_invoice_scheduler)) {
            $_tempBody = $fixed_costs_rel_invoice_scheduler;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFriendItem
     *
     * Replaces the Friend resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\Friend $friend The updated Friend resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Friend
     */
    public function putFriendItem($id, $friend = null)
    {
        list($response) = $this->putFriendItemWithHttpInfo($id, $friend);
        return $response;
    }

    /**
     * Operation putFriendItemWithHttpInfo
     *
     * Replaces the Friend resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Friend $friend The updated Friend resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Friend, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFriendItemWithHttpInfo($id, $friend = null)
    {
        $returnType = '\Delta/Voip\Model\Friend';
        $request = $this->putFriendItemRequest($id, $friend);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Friend',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFriendItemAsync
     *
     * Replaces the Friend resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Friend $friend The updated Friend resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFriendItemAsync($id, $friend = null)
    {
        return $this->putFriendItemAsyncWithHttpInfo($id, $friend)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFriendItemAsyncWithHttpInfo
     *
     * Replaces the Friend resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Friend $friend The updated Friend resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFriendItemAsyncWithHttpInfo($id, $friend = null)
    {
        $returnType = '\Delta/Voip\Model\Friend';
        $request = $this->putFriendItemRequest($id, $friend);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFriendItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Friend $friend The updated Friend resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFriendItemRequest($id, $friend = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putFriendItem'
            );
        }

        $resourcePath = '/friends/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($friend)) {
            $_tempBody = $friend;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putInvoiceItem
     *
     * Replaces the Invoice resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\Invoice $invoice The updated Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\Invoice
     */
    public function putInvoiceItem($id, $invoice = null, $_timezone = null)
    {
        list($response) = $this->putInvoiceItemWithHttpInfo($id, $invoice, $_timezone);
        return $response;
    }

    /**
     * Operation putInvoiceItemWithHttpInfo
     *
     * Replaces the Invoice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Invoice $invoice The updated Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function putInvoiceItemWithHttpInfo($id, $invoice = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\Invoice';
        $request = $this->putInvoiceItemRequest($id, $invoice, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putInvoiceItemAsync
     *
     * Replaces the Invoice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Invoice $invoice The updated Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInvoiceItemAsync($id, $invoice = null, $_timezone = null)
    {
        return $this->putInvoiceItemAsyncWithHttpInfo($id, $invoice, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putInvoiceItemAsyncWithHttpInfo
     *
     * Replaces the Invoice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Invoice $invoice The updated Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInvoiceItemAsyncWithHttpInfo($id, $invoice = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\Invoice';
        $request = $this->putInvoiceItemRequest($id, $invoice, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putInvoiceItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\Invoice $invoice The updated Invoice resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putInvoiceItemRequest($id, $invoice = null, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putInvoiceItem'
            );
        }

        $resourcePath = '/invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($invoice)) {
            $_tempBody = $invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putInvoiceNumberSequenceItem
     *
     * Replaces the InvoiceNumberSequence resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The updated InvoiceNumberSequence resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceNumberSequence
     */
    public function putInvoiceNumberSequenceItem($id, $invoice_number_sequence = null)
    {
        list($response) = $this->putInvoiceNumberSequenceItemWithHttpInfo($id, $invoice_number_sequence);
        return $response;
    }

    /**
     * Operation putInvoiceNumberSequenceItemWithHttpInfo
     *
     * Replaces the InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The updated InvoiceNumberSequence resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceNumberSequence, HTTP status code, HTTP response headers (array of strings)
     */
    public function putInvoiceNumberSequenceItemWithHttpInfo($id, $invoice_number_sequence = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceNumberSequence';
        $request = $this->putInvoiceNumberSequenceItemRequest($id, $invoice_number_sequence);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceNumberSequence',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putInvoiceNumberSequenceItemAsync
     *
     * Replaces the InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The updated InvoiceNumberSequence resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInvoiceNumberSequenceItemAsync($id, $invoice_number_sequence = null)
    {
        return $this->putInvoiceNumberSequenceItemAsyncWithHttpInfo($id, $invoice_number_sequence)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putInvoiceNumberSequenceItemAsyncWithHttpInfo
     *
     * Replaces the InvoiceNumberSequence resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The updated InvoiceNumberSequence resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInvoiceNumberSequenceItemAsyncWithHttpInfo($id, $invoice_number_sequence = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceNumberSequence';
        $request = $this->putInvoiceNumberSequenceItemRequest($id, $invoice_number_sequence);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putInvoiceNumberSequenceItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceNumberSequence $invoice_number_sequence The updated InvoiceNumberSequence resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putInvoiceNumberSequenceItemRequest($id, $invoice_number_sequence = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putInvoiceNumberSequenceItem'
            );
        }

        $resourcePath = '/invoice_number_sequences/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($invoice_number_sequence)) {
            $_tempBody = $invoice_number_sequence;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putInvoiceSchedulerItem
     *
     * Replaces the InvoiceScheduler resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The updated InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceScheduler
     */
    public function putInvoiceSchedulerItem($id, $invoice_scheduler = null, $_timezone = null)
    {
        list($response) = $this->putInvoiceSchedulerItemWithHttpInfo($id, $invoice_scheduler, $_timezone);
        return $response;
    }

    /**
     * Operation putInvoiceSchedulerItemWithHttpInfo
     *
     * Replaces the InvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The updated InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceScheduler, HTTP status code, HTTP response headers (array of strings)
     */
    public function putInvoiceSchedulerItemWithHttpInfo($id, $invoice_scheduler = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceScheduler';
        $request = $this->putInvoiceSchedulerItemRequest($id, $invoice_scheduler, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceScheduler',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putInvoiceSchedulerItemAsync
     *
     * Replaces the InvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The updated InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInvoiceSchedulerItemAsync($id, $invoice_scheduler = null, $_timezone = null)
    {
        return $this->putInvoiceSchedulerItemAsyncWithHttpInfo($id, $invoice_scheduler, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putInvoiceSchedulerItemAsyncWithHttpInfo
     *
     * Replaces the InvoiceScheduler resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The updated InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInvoiceSchedulerItemAsyncWithHttpInfo($id, $invoice_scheduler = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceScheduler';
        $request = $this->putInvoiceSchedulerItemRequest($id, $invoice_scheduler, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putInvoiceSchedulerItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceScheduler $invoice_scheduler The updated InvoiceScheduler resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putInvoiceSchedulerItemRequest($id, $invoice_scheduler = null, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putInvoiceSchedulerItem'
            );
        }

        $resourcePath = '/invoice_schedulers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($invoice_scheduler)) {
            $_tempBody = $invoice_scheduler;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putInvoiceTemplateItem
     *
     * Replaces the InvoiceTemplate resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The updated InvoiceTemplate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\InvoiceTemplate
     */
    public function putInvoiceTemplateItem($id, $invoice_template = null)
    {
        list($response) = $this->putInvoiceTemplateItemWithHttpInfo($id, $invoice_template);
        return $response;
    }

    /**
     * Operation putInvoiceTemplateItemWithHttpInfo
     *
     * Replaces the InvoiceTemplate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The updated InvoiceTemplate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\InvoiceTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function putInvoiceTemplateItemWithHttpInfo($id, $invoice_template = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceTemplate';
        $request = $this->putInvoiceTemplateItemRequest($id, $invoice_template);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\InvoiceTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putInvoiceTemplateItemAsync
     *
     * Replaces the InvoiceTemplate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The updated InvoiceTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInvoiceTemplateItemAsync($id, $invoice_template = null)
    {
        return $this->putInvoiceTemplateItemAsyncWithHttpInfo($id, $invoice_template)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putInvoiceTemplateItemAsyncWithHttpInfo
     *
     * Replaces the InvoiceTemplate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The updated InvoiceTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInvoiceTemplateItemAsyncWithHttpInfo($id, $invoice_template = null)
    {
        $returnType = '\Delta/Voip\Model\InvoiceTemplate';
        $request = $this->putInvoiceTemplateItemRequest($id, $invoice_template);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putInvoiceTemplateItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\InvoiceTemplate $invoice_template The updated InvoiceTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putInvoiceTemplateItemRequest($id, $invoice_template = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putInvoiceTemplateItem'
            );
        }

        $resourcePath = '/invoice_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($invoice_template)) {
            $_tempBody = $invoice_template;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putNotificationTemplateContentItem
     *
     * Replaces the NotificationTemplateContent resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The updated NotificationTemplateContent resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\NotificationTemplateContent
     */
    public function putNotificationTemplateContentItem($id, $notification_template_content = null)
    {
        list($response) = $this->putNotificationTemplateContentItemWithHttpInfo($id, $notification_template_content);
        return $response;
    }

    /**
     * Operation putNotificationTemplateContentItemWithHttpInfo
     *
     * Replaces the NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The updated NotificationTemplateContent resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\NotificationTemplateContent, HTTP status code, HTTP response headers (array of strings)
     */
    public function putNotificationTemplateContentItemWithHttpInfo($id, $notification_template_content = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateContent';
        $request = $this->putNotificationTemplateContentItemRequest($id, $notification_template_content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\NotificationTemplateContent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putNotificationTemplateContentItemAsync
     *
     * Replaces the NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The updated NotificationTemplateContent resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putNotificationTemplateContentItemAsync($id, $notification_template_content = null)
    {
        return $this->putNotificationTemplateContentItemAsyncWithHttpInfo($id, $notification_template_content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putNotificationTemplateContentItemAsyncWithHttpInfo
     *
     * Replaces the NotificationTemplateContent resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The updated NotificationTemplateContent resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putNotificationTemplateContentItemAsyncWithHttpInfo($id, $notification_template_content = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplateContent';
        $request = $this->putNotificationTemplateContentItemRequest($id, $notification_template_content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putNotificationTemplateContentItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\NotificationTemplateContent $notification_template_content The updated NotificationTemplateContent resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putNotificationTemplateContentItemRequest($id, $notification_template_content = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putNotificationTemplateContentItem'
            );
        }

        $resourcePath = '/notification_template_contents/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($notification_template_content)) {
            $_tempBody = $notification_template_content;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putNotificationTemplateItem
     *
     * Replaces the NotificationTemplate resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The updated NotificationTemplate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\NotificationTemplate
     */
    public function putNotificationTemplateItem($id, $notification_template = null)
    {
        list($response) = $this->putNotificationTemplateItemWithHttpInfo($id, $notification_template);
        return $response;
    }

    /**
     * Operation putNotificationTemplateItemWithHttpInfo
     *
     * Replaces the NotificationTemplate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The updated NotificationTemplate resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\NotificationTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function putNotificationTemplateItemWithHttpInfo($id, $notification_template = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplate';
        $request = $this->putNotificationTemplateItemRequest($id, $notification_template);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\NotificationTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putNotificationTemplateItemAsync
     *
     * Replaces the NotificationTemplate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The updated NotificationTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putNotificationTemplateItemAsync($id, $notification_template = null)
    {
        return $this->putNotificationTemplateItemAsyncWithHttpInfo($id, $notification_template)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putNotificationTemplateItemAsyncWithHttpInfo
     *
     * Replaces the NotificationTemplate resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The updated NotificationTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putNotificationTemplateItemAsyncWithHttpInfo($id, $notification_template = null)
    {
        $returnType = '\Delta/Voip\Model\NotificationTemplate';
        $request = $this->putNotificationTemplateItemRequest($id, $notification_template);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putNotificationTemplateItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\NotificationTemplate $notification_template The updated NotificationTemplate resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putNotificationTemplateItemRequest($id, $notification_template = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putNotificationTemplateItem'
            );
        }

        $resourcePath = '/notification_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($notification_template)) {
            $_tempBody = $notification_template;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putOutgoingRoutingItem
     *
     * Replaces the OutgoingRouting resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The updated OutgoingRouting resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\OutgoingRoutingWithCarriers
     */
    public function putOutgoingRoutingItem($id, $outgoing_routing = null)
    {
        list($response) = $this->putOutgoingRoutingItemWithHttpInfo($id, $outgoing_routing);
        return $response;
    }

    /**
     * Operation putOutgoingRoutingItemWithHttpInfo
     *
     * Replaces the OutgoingRouting resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The updated OutgoingRouting resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\OutgoingRoutingWithCarriers, HTTP status code, HTTP response headers (array of strings)
     */
    public function putOutgoingRoutingItemWithHttpInfo($id, $outgoing_routing = null)
    {
        $returnType = '\Delta/Voip\Model\OutgoingRoutingWithCarriers';
        $request = $this->putOutgoingRoutingItemRequest($id, $outgoing_routing);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\OutgoingRoutingWithCarriers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putOutgoingRoutingItemAsync
     *
     * Replaces the OutgoingRouting resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The updated OutgoingRouting resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putOutgoingRoutingItemAsync($id, $outgoing_routing = null)
    {
        return $this->putOutgoingRoutingItemAsyncWithHttpInfo($id, $outgoing_routing)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putOutgoingRoutingItemAsyncWithHttpInfo
     *
     * Replaces the OutgoingRouting resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The updated OutgoingRouting resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putOutgoingRoutingItemAsyncWithHttpInfo($id, $outgoing_routing = null)
    {
        $returnType = '\Delta/Voip\Model\OutgoingRoutingWithCarriers';
        $request = $this->putOutgoingRoutingItemRequest($id, $outgoing_routing);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putOutgoingRoutingItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\OutgoingRouting $outgoing_routing The updated OutgoingRouting resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putOutgoingRoutingItemRequest($id, $outgoing_routing = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putOutgoingRoutingItem'
            );
        }

        $resourcePath = '/outgoing_routings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($outgoing_routing)) {
            $_tempBody = $outgoing_routing;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRatingPlanGroupItem
     *
     * Replaces the RatingPlanGroup resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The updated RatingPlanGroup resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingPlanGroup
     */
    public function putRatingPlanGroupItem($id, $rating_plan_group = null)
    {
        list($response) = $this->putRatingPlanGroupItemWithHttpInfo($id, $rating_plan_group);
        return $response;
    }

    /**
     * Operation putRatingPlanGroupItemWithHttpInfo
     *
     * Replaces the RatingPlanGroup resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The updated RatingPlanGroup resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingPlanGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRatingPlanGroupItemWithHttpInfo($id, $rating_plan_group = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanGroup';
        $request = $this->putRatingPlanGroupItemRequest($id, $rating_plan_group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingPlanGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRatingPlanGroupItemAsync
     *
     * Replaces the RatingPlanGroup resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The updated RatingPlanGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRatingPlanGroupItemAsync($id, $rating_plan_group = null)
    {
        return $this->putRatingPlanGroupItemAsyncWithHttpInfo($id, $rating_plan_group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRatingPlanGroupItemAsyncWithHttpInfo
     *
     * Replaces the RatingPlanGroup resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The updated RatingPlanGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRatingPlanGroupItemAsyncWithHttpInfo($id, $rating_plan_group = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlanGroup';
        $request = $this->putRatingPlanGroupItemRequest($id, $rating_plan_group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRatingPlanGroupItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingPlanGroup $rating_plan_group The updated RatingPlanGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRatingPlanGroupItemRequest($id, $rating_plan_group = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putRatingPlanGroupItem'
            );
        }

        $resourcePath = '/rating_plan_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($rating_plan_group)) {
            $_tempBody = $rating_plan_group;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRatingPlanItem
     *
     * Replaces the RatingPlan resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The updated RatingPlan resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingPlan
     */
    public function putRatingPlanItem($id, $rating_plan = null)
    {
        list($response) = $this->putRatingPlanItemWithHttpInfo($id, $rating_plan);
        return $response;
    }

    /**
     * Operation putRatingPlanItemWithHttpInfo
     *
     * Replaces the RatingPlan resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The updated RatingPlan resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingPlan, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRatingPlanItemWithHttpInfo($id, $rating_plan = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlan';
        $request = $this->putRatingPlanItemRequest($id, $rating_plan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingPlan',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRatingPlanItemAsync
     *
     * Replaces the RatingPlan resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The updated RatingPlan resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRatingPlanItemAsync($id, $rating_plan = null)
    {
        return $this->putRatingPlanItemAsyncWithHttpInfo($id, $rating_plan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRatingPlanItemAsyncWithHttpInfo
     *
     * Replaces the RatingPlan resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The updated RatingPlan resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRatingPlanItemAsyncWithHttpInfo($id, $rating_plan = null)
    {
        $returnType = '\Delta/Voip\Model\RatingPlan';
        $request = $this->putRatingPlanItemRequest($id, $rating_plan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRatingPlanItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingPlan $rating_plan The updated RatingPlan resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRatingPlanItemRequest($id, $rating_plan = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putRatingPlanItem'
            );
        }

        $resourcePath = '/rating_plans/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($rating_plan)) {
            $_tempBody = $rating_plan;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRatingProfileItem
     *
     * Replaces the RatingProfile resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The updated RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RatingProfile
     */
    public function putRatingProfileItem($id, $rating_profile = null, $_timezone = null)
    {
        list($response) = $this->putRatingProfileItemWithHttpInfo($id, $rating_profile, $_timezone);
        return $response;
    }

    /**
     * Operation putRatingProfileItemWithHttpInfo
     *
     * Replaces the RatingProfile resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The updated RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RatingProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRatingProfileItemWithHttpInfo($id, $rating_profile = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\RatingProfile';
        $request = $this->putRatingProfileItemRequest($id, $rating_profile, $_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RatingProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRatingProfileItemAsync
     *
     * Replaces the RatingProfile resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The updated RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRatingProfileItemAsync($id, $rating_profile = null, $_timezone = null)
    {
        return $this->putRatingProfileItemAsyncWithHttpInfo($id, $rating_profile, $_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRatingProfileItemAsyncWithHttpInfo
     *
     * Replaces the RatingProfile resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The updated RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRatingProfileItemAsyncWithHttpInfo($id, $rating_profile = null, $_timezone = null)
    {
        $returnType = '\Delta/Voip\Model\RatingProfile';
        $request = $this->putRatingProfileItemRequest($id, $rating_profile, $_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRatingProfileItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RatingProfile $rating_profile The updated RatingProfile resource (optional)
     * @param  string $_timezone Use a time zone of choice instead of the token user one (Applies to both input and output) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRatingProfileItemRequest($id, $rating_profile = null, $_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putRatingProfileItem'
            );
        }

        $resourcePath = '/rating_profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_timezone !== null) {
            $queryParams['_timezone'] = ObjectSerializer::toQueryValue($_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($rating_profile)) {
            $_tempBody = $rating_profile;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putResidentialDeviceItem
     *
     * Replaces the ResidentialDevice resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The updated ResidentialDevice resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\ResidentialDevice
     */
    public function putResidentialDeviceItem($id, $residential_device = null)
    {
        list($response) = $this->putResidentialDeviceItemWithHttpInfo($id, $residential_device);
        return $response;
    }

    /**
     * Operation putResidentialDeviceItemWithHttpInfo
     *
     * Replaces the ResidentialDevice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The updated ResidentialDevice resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\ResidentialDevice, HTTP status code, HTTP response headers (array of strings)
     */
    public function putResidentialDeviceItemWithHttpInfo($id, $residential_device = null)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDevice';
        $request = $this->putResidentialDeviceItemRequest($id, $residential_device);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\ResidentialDevice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putResidentialDeviceItemAsync
     *
     * Replaces the ResidentialDevice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The updated ResidentialDevice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putResidentialDeviceItemAsync($id, $residential_device = null)
    {
        return $this->putResidentialDeviceItemAsyncWithHttpInfo($id, $residential_device)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putResidentialDeviceItemAsyncWithHttpInfo
     *
     * Replaces the ResidentialDevice resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The updated ResidentialDevice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putResidentialDeviceItemAsyncWithHttpInfo($id, $residential_device = null)
    {
        $returnType = '\Delta/Voip\Model\ResidentialDevice';
        $request = $this->putResidentialDeviceItemRequest($id, $residential_device);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putResidentialDeviceItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\ResidentialDevice $residential_device The updated ResidentialDevice resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putResidentialDeviceItemRequest($id, $residential_device = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putResidentialDeviceItem'
            );
        }

        $resourcePath = '/residential_devices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($residential_device)) {
            $_tempBody = $residential_device;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRetailAccountItem
     *
     * Replaces the RetailAccount resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The updated RetailAccount resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RetailAccount
     */
    public function putRetailAccountItem($id, $retail_account = null)
    {
        list($response) = $this->putRetailAccountItemWithHttpInfo($id, $retail_account);
        return $response;
    }

    /**
     * Operation putRetailAccountItemWithHttpInfo
     *
     * Replaces the RetailAccount resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The updated RetailAccount resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RetailAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRetailAccountItemWithHttpInfo($id, $retail_account = null)
    {
        $returnType = '\Delta/Voip\Model\RetailAccount';
        $request = $this->putRetailAccountItemRequest($id, $retail_account);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RetailAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRetailAccountItemAsync
     *
     * Replaces the RetailAccount resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The updated RetailAccount resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRetailAccountItemAsync($id, $retail_account = null)
    {
        return $this->putRetailAccountItemAsyncWithHttpInfo($id, $retail_account)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRetailAccountItemAsyncWithHttpInfo
     *
     * Replaces the RetailAccount resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The updated RetailAccount resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRetailAccountItemAsyncWithHttpInfo($id, $retail_account = null)
    {
        $returnType = '\Delta/Voip\Model\RetailAccount';
        $request = $this->putRetailAccountItemRequest($id, $retail_account);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRetailAccountItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RetailAccount $retail_account The updated RetailAccount resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRetailAccountItemRequest($id, $retail_account = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putRetailAccountItem'
            );
        }

        $resourcePath = '/retail_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($retail_account)) {
            $_tempBody = $retail_account;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRoutingPatternGroupItem
     *
     * Replaces the RoutingPatternGroup resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The updated RoutingPatternGroup resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternGroupWithPatterns
     */
    public function putRoutingPatternGroupItem($id, $routing_pattern_group = null)
    {
        list($response) = $this->putRoutingPatternGroupItemWithHttpInfo($id, $routing_pattern_group);
        return $response;
    }

    /**
     * Operation putRoutingPatternGroupItemWithHttpInfo
     *
     * Replaces the RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The updated RoutingPatternGroup resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternGroupWithPatterns, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRoutingPatternGroupItemWithHttpInfo($id, $routing_pattern_group = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupWithPatterns';
        $request = $this->putRoutingPatternGroupItemRequest($id, $routing_pattern_group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternGroupWithPatterns',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRoutingPatternGroupItemAsync
     *
     * Replaces the RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The updated RoutingPatternGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRoutingPatternGroupItemAsync($id, $routing_pattern_group = null)
    {
        return $this->putRoutingPatternGroupItemAsyncWithHttpInfo($id, $routing_pattern_group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRoutingPatternGroupItemAsyncWithHttpInfo
     *
     * Replaces the RoutingPatternGroup resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The updated RoutingPatternGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRoutingPatternGroupItemAsyncWithHttpInfo($id, $routing_pattern_group = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupWithPatterns';
        $request = $this->putRoutingPatternGroupItemRequest($id, $routing_pattern_group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRoutingPatternGroupItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroup $routing_pattern_group The updated RoutingPatternGroup resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRoutingPatternGroupItemRequest($id, $routing_pattern_group = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putRoutingPatternGroupItem'
            );
        }

        $resourcePath = '/routing_pattern_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($routing_pattern_group)) {
            $_tempBody = $routing_pattern_group;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRoutingPatternGroupsRelPatternItem
     *
     * Replaces the RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The updated RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPatternGroupsRelPattern
     */
    public function putRoutingPatternGroupsRelPatternItem($id, $routing_pattern_groups_rel_pattern = null)
    {
        list($response) = $this->putRoutingPatternGroupsRelPatternItemWithHttpInfo($id, $routing_pattern_groups_rel_pattern);
        return $response;
    }

    /**
     * Operation putRoutingPatternGroupsRelPatternItemWithHttpInfo
     *
     * Replaces the RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The updated RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPatternGroupsRelPattern, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRoutingPatternGroupsRelPatternItemWithHttpInfo($id, $routing_pattern_groups_rel_pattern = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupsRelPattern';
        $request = $this->putRoutingPatternGroupsRelPatternItemRequest($id, $routing_pattern_groups_rel_pattern);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPatternGroupsRelPattern',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRoutingPatternGroupsRelPatternItemAsync
     *
     * Replaces the RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The updated RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRoutingPatternGroupsRelPatternItemAsync($id, $routing_pattern_groups_rel_pattern = null)
    {
        return $this->putRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo($id, $routing_pattern_groups_rel_pattern)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo
     *
     * Replaces the RoutingPatternGroupsRelPattern resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The updated RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRoutingPatternGroupsRelPatternItemAsyncWithHttpInfo($id, $routing_pattern_groups_rel_pattern = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPatternGroupsRelPattern';
        $request = $this->putRoutingPatternGroupsRelPatternItemRequest($id, $routing_pattern_groups_rel_pattern);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRoutingPatternGroupsRelPatternItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPatternGroupsRelPattern $routing_pattern_groups_rel_pattern The updated RoutingPatternGroupsRelPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRoutingPatternGroupsRelPatternItemRequest($id, $routing_pattern_groups_rel_pattern = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putRoutingPatternGroupsRelPatternItem'
            );
        }

        $resourcePath = '/routing_pattern_groups_rel_patterns/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($routing_pattern_groups_rel_pattern)) {
            $_tempBody = $routing_pattern_groups_rel_pattern;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRoutingPatternItem
     *
     * Replaces the RoutingPattern resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The updated RoutingPattern resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingPattern
     */
    public function putRoutingPatternItem($id, $routing_pattern = null)
    {
        list($response) = $this->putRoutingPatternItemWithHttpInfo($id, $routing_pattern);
        return $response;
    }

    /**
     * Operation putRoutingPatternItemWithHttpInfo
     *
     * Replaces the RoutingPattern resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The updated RoutingPattern resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingPattern, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRoutingPatternItemWithHttpInfo($id, $routing_pattern = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPattern';
        $request = $this->putRoutingPatternItemRequest($id, $routing_pattern);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingPattern',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRoutingPatternItemAsync
     *
     * Replaces the RoutingPattern resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The updated RoutingPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRoutingPatternItemAsync($id, $routing_pattern = null)
    {
        return $this->putRoutingPatternItemAsyncWithHttpInfo($id, $routing_pattern)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRoutingPatternItemAsyncWithHttpInfo
     *
     * Replaces the RoutingPattern resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The updated RoutingPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRoutingPatternItemAsyncWithHttpInfo($id, $routing_pattern = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingPattern';
        $request = $this->putRoutingPatternItemRequest($id, $routing_pattern);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRoutingPatternItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingPattern $routing_pattern The updated RoutingPattern resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRoutingPatternItemRequest($id, $routing_pattern = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putRoutingPatternItem'
            );
        }

        $resourcePath = '/routing_patterns/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($routing_pattern)) {
            $_tempBody = $routing_pattern;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRoutingTagItem
     *
     * Replaces the RoutingTag resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The updated RoutingTag resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\RoutingTag
     */
    public function putRoutingTagItem($id, $routing_tag = null)
    {
        list($response) = $this->putRoutingTagItemWithHttpInfo($id, $routing_tag);
        return $response;
    }

    /**
     * Operation putRoutingTagItemWithHttpInfo
     *
     * Replaces the RoutingTag resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The updated RoutingTag resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\RoutingTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRoutingTagItemWithHttpInfo($id, $routing_tag = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingTag';
        $request = $this->putRoutingTagItemRequest($id, $routing_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\RoutingTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRoutingTagItemAsync
     *
     * Replaces the RoutingTag resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The updated RoutingTag resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRoutingTagItemAsync($id, $routing_tag = null)
    {
        return $this->putRoutingTagItemAsyncWithHttpInfo($id, $routing_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRoutingTagItemAsyncWithHttpInfo
     *
     * Replaces the RoutingTag resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The updated RoutingTag resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRoutingTagItemAsyncWithHttpInfo($id, $routing_tag = null)
    {
        $returnType = '\Delta/Voip\Model\RoutingTag';
        $request = $this->putRoutingTagItemRequest($id, $routing_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRoutingTagItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\RoutingTag $routing_tag The updated RoutingTag resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRoutingTagItemRequest($id, $routing_tag = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putRoutingTagItem'
            );
        }

        $resourcePath = '/routing_tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($routing_tag)) {
            $_tempBody = $routing_tag;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpecialNumberItem
     *
     * Replaces the SpecialNumber resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The updated SpecialNumber resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\SpecialNumber
     */
    public function putSpecialNumberItem($id, $special_number = null)
    {
        list($response) = $this->putSpecialNumberItemWithHttpInfo($id, $special_number);
        return $response;
    }

    /**
     * Operation putSpecialNumberItemWithHttpInfo
     *
     * Replaces the SpecialNumber resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The updated SpecialNumber resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\SpecialNumber, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpecialNumberItemWithHttpInfo($id, $special_number = null)
    {
        $returnType = '\Delta/Voip\Model\SpecialNumber';
        $request = $this->putSpecialNumberItemRequest($id, $special_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\SpecialNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSpecialNumberItemAsync
     *
     * Replaces the SpecialNumber resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The updated SpecialNumber resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpecialNumberItemAsync($id, $special_number = null)
    {
        return $this->putSpecialNumberItemAsyncWithHttpInfo($id, $special_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpecialNumberItemAsyncWithHttpInfo
     *
     * Replaces the SpecialNumber resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The updated SpecialNumber resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpecialNumberItemAsyncWithHttpInfo($id, $special_number = null)
    {
        $returnType = '\Delta/Voip\Model\SpecialNumber';
        $request = $this->putSpecialNumberItemRequest($id, $special_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpecialNumberItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\SpecialNumber $special_number The updated SpecialNumber resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSpecialNumberItemRequest($id, $special_number = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putSpecialNumberItem'
            );
        }

        $resourcePath = '/special_numbers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($special_number)) {
            $_tempBody = $special_number;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTransformationRuleItem
     *
     * Replaces the TransformationRule resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The updated TransformationRule resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TransformationRule
     */
    public function putTransformationRuleItem($id, $transformation_rule = null)
    {
        list($response) = $this->putTransformationRuleItemWithHttpInfo($id, $transformation_rule);
        return $response;
    }

    /**
     * Operation putTransformationRuleItemWithHttpInfo
     *
     * Replaces the TransformationRule resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The updated TransformationRule resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TransformationRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTransformationRuleItemWithHttpInfo($id, $transformation_rule = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRule';
        $request = $this->putTransformationRuleItemRequest($id, $transformation_rule);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TransformationRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putTransformationRuleItemAsync
     *
     * Replaces the TransformationRule resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The updated TransformationRule resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTransformationRuleItemAsync($id, $transformation_rule = null)
    {
        return $this->putTransformationRuleItemAsyncWithHttpInfo($id, $transformation_rule)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTransformationRuleItemAsyncWithHttpInfo
     *
     * Replaces the TransformationRule resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The updated TransformationRule resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTransformationRuleItemAsyncWithHttpInfo($id, $transformation_rule = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRule';
        $request = $this->putTransformationRuleItemRequest($id, $transformation_rule);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTransformationRuleItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\TransformationRule $transformation_rule The updated TransformationRule resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTransformationRuleItemRequest($id, $transformation_rule = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putTransformationRuleItem'
            );
        }

        $resourcePath = '/transformation_rules/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($transformation_rule)) {
            $_tempBody = $transformation_rule;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTransformationRuleSetItem
     *
     * Replaces the TransformationRuleSet resource.
     *
     * @param  string $id id (required)
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The updated TransformationRuleSet resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\TransformationRuleSet
     */
    public function putTransformationRuleSetItem($id, $transformation_rule_set = null)
    {
        list($response) = $this->putTransformationRuleSetItemWithHttpInfo($id, $transformation_rule_set);
        return $response;
    }

    /**
     * Operation putTransformationRuleSetItemWithHttpInfo
     *
     * Replaces the TransformationRuleSet resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The updated TransformationRuleSet resource (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\TransformationRuleSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTransformationRuleSetItemWithHttpInfo($id, $transformation_rule_set = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleSet';
        $request = $this->putTransformationRuleSetItemRequest($id, $transformation_rule_set);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\TransformationRuleSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putTransformationRuleSetItemAsync
     *
     * Replaces the TransformationRuleSet resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The updated TransformationRuleSet resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTransformationRuleSetItemAsync($id, $transformation_rule_set = null)
    {
        return $this->putTransformationRuleSetItemAsyncWithHttpInfo($id, $transformation_rule_set)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTransformationRuleSetItemAsyncWithHttpInfo
     *
     * Replaces the TransformationRuleSet resource.
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The updated TransformationRuleSet resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTransformationRuleSetItemAsyncWithHttpInfo($id, $transformation_rule_set = null)
    {
        $returnType = '\Delta/Voip\Model\TransformationRuleSet';
        $request = $this->putTransformationRuleSetItemRequest($id, $transformation_rule_set);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTransformationRuleSetItem'
     *
     * @param  string $id (required)
     * @param  \Delta/Voip\Model\TransformationRuleSet $transformation_rule_set The updated TransformationRuleSet resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTransformationRuleSetItemRequest($id, $transformation_rule_set = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putTransformationRuleSetItem'
            );
        }

        $resourcePath = '/transformation_rule_sets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($transformation_rule_set)) {
            $_tempBody = $transformation_rule_set;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putWebPortalItem
     *
     * Replaces the WebPortal resource.
     *
     * @param  string $id id (required)
     * @param  string $web_portal The updated WebPortal resource (optional)
     * @param  \SplFileObject $logo logo (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Delta/Voip\Model\WebPortal
     */
    public function putWebPortalItem($id, $web_portal = null, $logo = null)
    {
        list($response) = $this->putWebPortalItemWithHttpInfo($id, $web_portal, $logo);
        return $response;
    }

    /**
     * Operation putWebPortalItemWithHttpInfo
     *
     * Replaces the WebPortal resource.
     *
     * @param  string $id (required)
     * @param  string $web_portal The updated WebPortal resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Delta/Voip\Model\WebPortal, HTTP status code, HTTP response headers (array of strings)
     */
    public function putWebPortalItemWithHttpInfo($id, $web_portal = null, $logo = null)
    {
        $returnType = '\Delta/Voip\Model\WebPortal';
        $request = $this->putWebPortalItemRequest($id, $web_portal, $logo);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Delta/Voip\Model\WebPortal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putWebPortalItemAsync
     *
     * Replaces the WebPortal resource.
     *
     * @param  string $id (required)
     * @param  string $web_portal The updated WebPortal resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putWebPortalItemAsync($id, $web_portal = null, $logo = null)
    {
        return $this->putWebPortalItemAsyncWithHttpInfo($id, $web_portal, $logo)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putWebPortalItemAsyncWithHttpInfo
     *
     * Replaces the WebPortal resource.
     *
     * @param  string $id (required)
     * @param  string $web_portal The updated WebPortal resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putWebPortalItemAsyncWithHttpInfo($id, $web_portal = null, $logo = null)
    {
        $returnType = '\Delta/Voip\Model\WebPortal';
        $request = $this->putWebPortalItemRequest($id, $web_portal, $logo);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putWebPortalItem'
     *
     * @param  string $id (required)
     * @param  string $web_portal The updated WebPortal resource (optional)
     * @param  \SplFileObject $logo (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putWebPortalItemRequest($id, $web_portal = null, $logo = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putWebPortalItem'
            );
        }

        $resourcePath = '/web_portals/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($web_portal !== null) {
            $formParams['webPortal'] = ObjectSerializer::toFormValue($web_portal);
        }
        // form params
        if ($logo !== null) {
            $multipart = true;
            $formParams['Logo'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($logo), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/ld+json'],
                ['multipart/form-data', 'application/json', 'application/ld+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webportalLogoWebPortalItem
     *
     * Retrieves a WebPortal resource.
     *
     * @param  string $id id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webportalLogoWebPortalItem($id)
    {
        $this->webportalLogoWebPortalItemWithHttpInfo($id);
    }

    /**
     * Operation webportalLogoWebPortalItemWithHttpInfo
     *
     * Retrieves a WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \Delta/Voip\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webportalLogoWebPortalItemWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->webportalLogoWebPortalItemRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webportalLogoWebPortalItemAsync
     *
     * Retrieves a WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webportalLogoWebPortalItemAsync($id)
    {
        return $this->webportalLogoWebPortalItemAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webportalLogoWebPortalItemAsyncWithHttpInfo
     *
     * Retrieves a WebPortal resource.
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webportalLogoWebPortalItemAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->webportalLogoWebPortalItemRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webportalLogoWebPortalItem'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webportalLogoWebPortalItemRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webportalLogoWebPortalItem'
            );
        }

        $resourcePath = '/web_portals/{id}/logo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
